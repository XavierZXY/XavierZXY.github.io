

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo128.svg">
  <link rel="icon" href="/img/logo32.svg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Xavier ZXY">
  <meta name="keywords" content="">
  
    <meta name="description" content="本文为学习操作系统源码 (低并发编程)所作笔记，仅供学习参考，不做任何商业用途,若有侵权，请联系删除。  第四部分 shell程序的到来 第三十一回 | 拿到硬盘信息  第31回 | 拿到硬盘信息 (qq.com)  上一个大部分的名字叫一个新进程的诞生，讲述了进程 0 调用了 fork 函数创建了一个新的进程 —— 进程 1，并且使其达到了可以被调度的状态，fork 就">
<meta property="og:type" content="article">
<meta property="og:title" content="你管这破玩意儿叫操作系统源码(八)">
<meta property="og:url" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/index.html">
<meta property="og:site_name" content="Xavier ZXY">
<meta property="og:description" content="本文为学习操作系统源码 (低并发编程)所作笔记，仅供学习参考，不做任何商业用途,若有侵权，请联系删除。  第四部分 shell程序的到来 第三十一回 | 拿到硬盘信息  第31回 | 拿到硬盘信息 (qq.com)  上一个大部分的名字叫一个新进程的诞生，讲述了进程 0 调用了 fork 函数创建了一个新的进程 —— 进程 1，并且使其达到了可以被调度的状态，fork 就">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/640.png">
<meta property="og:image" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-16807682290973.png">
<meta property="og:image" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-16807683744746.png">
<meta property="og:image" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-16807689781229.png">
<meta property="og:image" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-168076901755712.png">
<meta property="og:image" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-168076906648015.png">
<meta property="og:image" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-168076924037418.png">
<meta property="og:image" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-168076930453321.png">
<meta property="og:image" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-168076960235024.png">
<meta property="og:image" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-168076981160127.png">
<meta property="og:image" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-168076981160228.png">
<meta property="og:image" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/640.png">
<meta property="og:image" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-16809201736683.png">
<meta property="og:image" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-16809201736684.png">
<meta property="article:published_time" content="2023-04-06T07:54:30.000Z">
<meta property="article:modified_time" content="2023-04-08T02:18:24.225Z">
<meta property="article:author" content="Xavier ZXY">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/640.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>你管这破玩意儿叫操作系统源码(八) - Xavier ZXY</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.spacezxy.top","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>SapceZXY</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/wallpaper.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="你管这破玩意儿叫操作系统源码(八)"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-06 15:54" pubdate>
          2023年4月6日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          116 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">你管这破玩意儿叫操作系统源码(八)</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>本文为学习<a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;__biz=Mzk0MjE3NDE0Ng==&amp;scene=1&amp;album_id=2123743679373688834&amp;count=3#wechat_redirect">操作系统源码
(低并发编程)</a>所作笔记，仅供学习参考，不做任何商业用途,若有侵权，请联系删除。</p>
</blockquote>
<h1 id="第四部分-shell程序的到来">第四部分 shell程序的到来</h1>
<h1 id="第三十一回-拿到硬盘信息">第三十一回 | 拿到硬盘信息</h1>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247502161&amp;idx=1&amp;sn=219186a1e587f40308515852d293aaf4&amp;chksm=c2c5b3fcf5b23aead170092d4042abd54b272694cbaac3f750eb3adea584ee29653c72ad2915&amp;scene=178&amp;cur_album_id=2123743679373688834#rd">第31回
| 拿到硬盘信息 (qq.com)</a></p>
</blockquote>
<p>上一个大部分的名字叫<a
target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247501947&amp;idx=1&amp;sn=cb94f53c75d674d30fb4903778c74c08&amp;chksm=c2c5b2d6f5b23bc027d9652d3e9949e55fd3b101beb87f6f80dd77d8233c0b51bede73edad46&amp;scene=21#wechat_redirect">一个新进程的诞生</a>，讲述了进程
0 调用了 fork 函数创建了一个新的进程 —— 进程
1，并且使其达到了可以被调度的状态，fork 就算正式完成了自己的使命。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-selector-tag">main</span>(void) &#123;<br>    ...<br>    <span class="hljs-built_in">move_to_user_mode</span>();<br>    if (!fork()) &#123;<br>        <span class="hljs-built_in">init</span>();<br>    &#125;<br>    <span class="hljs-built_in">for</span>(;;) <span class="hljs-attribute">pause</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于 fork 函数一调用，就又多出了一个进程，子进程（进程 1）会返回
0，父进程（进程 0）返回子进程的 ID，所以 <strong>init</strong>
函数只有进程 1 才会执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> pid,i;<br>    setup((<span class="hljs-type">void</span> *) &amp;drive_info);<br>    (<span class="hljs-type">void</span>) open(<span class="hljs-string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="hljs-number">0</span>);<br>    (<span class="hljs-type">void</span>) dup(<span class="hljs-number">0</span>);<br>    (<span class="hljs-type">void</span>) dup(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!(pid=fork())) &#123;<br>        open(<span class="hljs-string">&quot;/etc/rc&quot;</span>,O_RDONLY,<span class="hljs-number">0</span>);<br>        execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>,argv_rc,envp_rc);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pid&gt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span> (pid != wait(&amp;i))<br>            <span class="hljs-comment">/* nothing */</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!pid=fork()) &#123;<br>            close(<span class="hljs-number">0</span>);close(<span class="hljs-number">1</span>);close(<span class="hljs-number">2</span>);<br>            setsid();<br>            (<span class="hljs-type">void</span>) open(<span class="hljs-string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="hljs-number">0</span>);<br>            (<span class="hljs-type">void</span>) dup(<span class="hljs-number">0</span>);<br>            (<span class="hljs-type">void</span>) dup(<span class="hljs-number">0</span>);<br>            _exit(execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>,argv,envp));<br>        &#125;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">if</span> (pid == wait(&amp;i))<br>                <span class="hljs-keyword">break</span>;<br>        sync();<br>    &#125;<br>    _exit(<span class="hljs-number">0</span>);   <span class="hljs-comment">/* NOTE! _exit, not exit() */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们就只讲第一行代码 <strong>setup</strong>
的一部分，硬盘信息的获取。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">drive_info</span> &#123;</span> <span class="hljs-type">char</span> dummy[<span class="hljs-number">32</span>]; &#125; drive_info;<br><br><span class="hljs-comment">// drive_info = (*(struct drive_info *)0x90080);</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    setup((<span class="hljs-type">void</span> *) &amp;drive_info);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先看入参。</p>
<p>drive_info 是来自内存 0x90080 的数据，这部分是由之前 <a
target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247499558&amp;idx=1&amp;sn=d5d057fae2fb835d38f82804c2649463&amp;chksm=c2c5858bf5b20c9de2db5c31dd34fbe766f6c46cda17f54f4518a75fc1838f2ada6fe5717aad&amp;scene=21#wechat_redirect">第5回
| 进入保护模式前的最后一次折腾内存</a> 讲的 setup.s 程序将硬盘 1
的参数信息放在这里了，包括柱面数、磁头数、扇区数等信息。</p>
<p>setup 是个系统调用，会通过中断最终调用到 sys_setup
函数。关于系统调用的原理，在 <a
target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247501700&amp;idx=1&amp;sn=1b0167cf9852f89748a337d9b06c940b&amp;chksm=c2c5bd29f5b2343ff01c68f1cbc654fbb12148f00eff8c21bb2e725a6054a7a6fbddbc253afb&amp;scene=21#wechat_redirect">第25回
| 通过 fork 看一次系统调用</a> 中已经讲得很清楚了，此处不再赘述。</p>
<p>所以直接看 sys_setup
函数，我仍然是对代码做了少许的简化，去掉了日志打印和错误判断分支，并且仅当作只有一块硬盘，去掉了一层
for 循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_setup</span><span class="hljs-params">(<span class="hljs-type">void</span> * BIOS)</span> &#123;<br><br>    hd_info[<span class="hljs-number">0</span>].cyl = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *) BIOS;<br>    hd_info[<span class="hljs-number">0</span>].head = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) (<span class="hljs-number">2</span>+BIOS);<br>    hd_info[<span class="hljs-number">0</span>].wpcom = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *) (<span class="hljs-number">5</span>+BIOS);<br>    hd_info[<span class="hljs-number">0</span>].ctl = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) (<span class="hljs-number">8</span>+BIOS);<br>    hd_info[<span class="hljs-number">0</span>].lzone = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *) (<span class="hljs-number">12</span>+BIOS);<br>    hd_info[<span class="hljs-number">0</span>].sect = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) (<span class="hljs-number">14</span>+BIOS);<br>    BIOS += <span class="hljs-number">16</span>;<br><br>    hd[<span class="hljs-number">0</span>].start_sect = <span class="hljs-number">0</span>;<br>    hd[<span class="hljs-number">0</span>].nr_sects = <br>        hd_info[<span class="hljs-number">0</span>].head * hd_info[<span class="hljs-number">0</span>].sect * hd_info[<span class="hljs-number">0</span>].cyl;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> *<span class="hljs-title">bh</span> =</span> bread(<span class="hljs-number">0x300</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-number">0x1BE</span> + (<span class="hljs-type">void</span> *)bh-&gt;b_data;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">5</span>;i++,p++) &#123;<br>        hd[i].start_sect = p-&gt;start_sect;<br>        hd[i].nr_sects = p-&gt;nr_sects;<br>    &#125;<br>    brelse(bh);<br>    <br>    rd_load();<br>    mount_root();<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先看第一部分，硬盘基本信息的赋值的操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_setup</span><span class="hljs-params">(<span class="hljs-type">void</span> * BIOS)</span> &#123;<br>    hd_info[<span class="hljs-number">0</span>].cyl = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *) BIOS;<br>    hd_info[<span class="hljs-number">0</span>].head = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) (<span class="hljs-number">2</span>+BIOS);<br>    hd_info[<span class="hljs-number">0</span>].wpcom = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *) (<span class="hljs-number">5</span>+BIOS);<br>    hd_info[<span class="hljs-number">0</span>].ctl = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) (<span class="hljs-number">8</span>+BIOS);<br>    hd_info[<span class="hljs-number">0</span>].lzone = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *) (<span class="hljs-number">12</span>+BIOS);<br>    hd_info[<span class="hljs-number">0</span>].sect = *(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *) (<span class="hljs-number">14</span>+BIOS);<br>    BIOS += <span class="hljs-number">16</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>刚刚说了，入参 BIOS 是来自内存 0x90080 的数据，这部分是由之前 <a
target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247499558&amp;idx=1&amp;sn=d5d057fae2fb835d38f82804c2649463&amp;chksm=c2c5858bf5b20c9de2db5c31dd34fbe766f6c46cda17f54f4518a75fc1838f2ada6fe5717aad&amp;scene=21#wechat_redirect">第5回
| 进入保护模式前的最后一次折腾内存</a> 讲的 setup.s 程序将硬盘 1
的参数信息放在这里了，包括柱面数、磁头数、扇区数等信息。</p>
<p>所以，一开始先往 <strong>hd_info</strong> 数组的 0
索引处存上这些信息。我们假设就只有一块硬盘，所以这个数组也只有一个元素。</p>
<p>这个数组里的结构就是
<strong>hd_i_struct</strong>，就表示硬盘的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hd_i_struct</span> &#123;</span><br>    <span class="hljs-comment">// 磁头数、每磁道扇区数、柱面数、写前预补偿柱面号、磁头着陆区柱面号、控制字节</span><br>    <span class="hljs-type">int</span> head,sect,cyl,wpcom,lzone,ctl;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hd_i_struct</span> <span class="hljs-title">hd_info</span>[] =</span> &#123;&#125;；<br></code></pre></td></tr></table></figure>
<p>最终效果就是这样。</p>
<img src="/2023/04/06/OperatingSystem/Operating-system-source-code-8/640.png" srcset="/img/loading.gif" lazyload class="" title="图片">
<p>看第二部分，硬盘分区表的设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hd_struct</span> &#123;</span><br>    <span class="hljs-type">long</span> start_sect;<br>    <span class="hljs-type">long</span> nr_sects;<br>&#125; hd[<span class="hljs-number">5</span>] = &#123;&#125;<br><br><span class="hljs-type">int</span> sys_setup(<span class="hljs-type">void</span> * BIOS) &#123;<br>    ...<br>    hd[<span class="hljs-number">0</span>].start_sect = <span class="hljs-number">0</span>;<br>    hd[<span class="hljs-number">0</span>].nr_sects = <br>        hd_info[<span class="hljs-number">0</span>].head * hd_info[<span class="hljs-number">0</span>].sect * hd_info[<span class="hljs-number">0</span>].cyl;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> *<span class="hljs-title">bh</span> =</span> bread(<span class="hljs-number">0x300</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">partition</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-number">0x1BE</span> + (<span class="hljs-type">void</span> *)bh-&gt;b_data;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;<span class="hljs-number">5</span>;i++,p++) &#123;<br>        hd[i].start_sect = p-&gt;start_sect;<br>        hd[i].nr_sects = p-&gt;nr_sects;<br>    &#125;<br>    brelse(bh);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只看最终效果，就是给 hd 数组的五项附上了值。</p>
<img src="/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-16807682290973.png" srcset="/img/loading.gif" lazyload class="" title="图片">
<p>这表示硬盘的分区信息，每个分区用 <strong>start_sect</strong> 和
<strong>nr_sects</strong>，也就是开始扇区和总扇区数来记录。</p>
<p>这些信息是从哪里获取的呢？就是在硬盘的第一个扇区的 0x1BE
偏移处，这里存储着该硬盘的分区信息，只要把这个地方的数据拿到就 OK
了。</p>
<p>所以 bread 就是干这事的，从硬盘读取数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_head</span> *<span class="hljs-title">bh</span> =</span> bread(<span class="hljs-number">0x300</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<p>第一个参数 0x300
是第一块硬盘的主设备号，就表示要读取的块设备是硬盘一。第二个参数 0
表示读取第一个块，一个块为 1024 字节大小，也就是连续读取硬盘开始处 0 ~
1024 字节的数据。</p>
<p>拿到这部分数据后，再取 0x1BE 偏移处，就得到了分区信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">partition</span> *p = <span class="hljs-number">0x1BE</span> + (<span class="hljs-type">void</span> *)bh-&gt;b_data;<br></code></pre></td></tr></table></figure>
<p>就这么点事。</p>
<img src="/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-16807683744746.png" srcset="/img/loading.gif" lazyload class="" title="图片">
<p>至于如何从硬盘中读取指定位置（块）的数据，也就是
<strong>bread</strong>
函数的内部实现，那是相当复杂的，涉及到与缓冲区配合的部分，还有读写请求队列的设置，以及中断。</p>
<p>OK，目前我们已经把硬盘的基本信息存入了
hd_info[]，把硬盘的分区信息存入了 hd[]，我们继续往下看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_setup</span><span class="hljs-params">(<span class="hljs-type">void</span> * BIOS)</span> &#123;<br>    ...<br>    rd_load();<br>    mount_root();<br>    <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>就剩两个函数了。</p>
<p>其中 <strong>rd_load</strong> 是当有 ramdisk
时，也就是虚拟内存盘，才会执行。虚拟内存盘是通过软件将一部分内存（RAM）模拟为硬盘来使用的一种技术，一种小玩法而已，我们就先当做没有，否则很影响看主流程的心情。</p>
<p><strong>mount_root</strong>
直译过来就是<strong>加载根</strong>，再多说几个字是<strong>加载根文件系统</strong>，有了它之后，操作系统才能从一个根开始找到所有存储在硬盘中的文件，所以它是文件系统的基石，很重要。</p>
<p>为了加载根文件系统，或者说所谓的加载根文件系统，就是把硬盘中的数据加载到内存里，以文件系统的数据格式来解读这些信息。</p>
<p>所以第一，需要硬盘本身就有文件系统的信息，硬盘不能是裸盘，这个不归操作系统管，你为了启动我的
Linux 0.11，必须拿来一块做好了文件系统的硬盘来。</p>
<p>第二，需要读取硬盘的数据到内存，那就必须需要知道硬盘的参数信息，这就是我们本讲所做的事情的意义。</p>
<h1 id="第三十二回-加载根文件系统">第三十二回 | 加载根文件系统</h1>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247502181&amp;idx=1&amp;sn=b6dcbd1d2cf930002852008a1c4e6a65&amp;chksm=c2c5b3c8f5b23ade1532b725995dbc3b0138202555e44a6e308b84d668a2ef3041eb5cf77f86&amp;cur_album_id=2123743679373688834&amp;scene=190#rd">第32回
| 加载根文件系统 (qq.com)</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mount_root</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> i,<span class="hljs-built_in">free</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> * <span class="hljs-title">p</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">mi</span>;</span><br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">64</span>;i++)<br>        file_table[i].f_count=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(p = &amp;super_block[<span class="hljs-number">0</span>] ; p &lt; &amp;super_block[<span class="hljs-number">8</span>] ; p++) &#123;<br>        p-&gt;s_dev = <span class="hljs-number">0</span>;<br>        p-&gt;s_lock = <span class="hljs-number">0</span>;<br>        p-&gt;s_wait = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    p=read_super(<span class="hljs-number">0</span>);<br>    mi=iget(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br><br>    mi-&gt;i_count += <span class="hljs-number">3</span> ;<br>    p-&gt;s_isup = p-&gt;s_imount = mi;<br>    current-&gt;pwd = mi;<br>    current-&gt;root = mi;<br>    <span class="hljs-built_in">free</span>=<span class="hljs-number">0</span>;<br>    i=p-&gt;s_nzones;<br>    <span class="hljs-keyword">while</span> (-- i &gt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">if</span> (!set_bit(i&amp;<span class="hljs-number">8191</span>,p-&gt;s_zmap[i&gt;&gt;<span class="hljs-number">13</span>]-&gt;b_data))<br>            <span class="hljs-built_in">free</span>++;<br><br>    <span class="hljs-built_in">free</span>=<span class="hljs-number">0</span>;<br>    i=p-&gt;s_ninodes+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (-- i &gt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">if</span> (!set_bit(i&amp;<span class="hljs-number">8191</span>,p-&gt;s_imap[i&gt;&gt;<span class="hljs-number">13</span>]-&gt;b_data))<br>            <span class="hljs-built_in">free</span>++;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从整体上说，它就是要把硬盘中的数据，以文件系统的格式进行解读，加载到内存中设计好的数据结构，这样操作系统就可以通过内存中的数据，以文件系统的方式访问硬盘中的一个个文件了。</p>
<img src="/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-16807689781229.png" srcset="/img/loading.gif" lazyload class="" title="图片">
<h2 id="硬盘中的文件系统格式是怎样的">硬盘中的文件系统格式是怎样的</h2>
<p>首先硬盘中的文件系统，无非就是硬盘中的一堆数据，我们按照一定格式去解析罢了。Linux-0.11
中的文件系统是 <strong>MINIX</strong> 文件系统，它就长成这个样子。</p>
<img src="/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-168076901755712.png" srcset="/img/loading.gif" lazyload class="" title="图片">
<p>每一个块结构的大小是 1024 字节，也就是
1KB，硬盘里的数据就按照这个结构，妥善地安排在硬盘里。</p>
<p><strong>引导块</strong>就是我们系列最开头说的启动区，当然不一定所有的硬盘都有启动区，但我们还是得预留出这个位置，以保持格式的统一。</p>
<p><strong>超级块</strong>用于描述整个文件系统的整体信息，我们看它的字段就知道了，有后面的
inode
数量，块数量，第一个块在哪里等信息。有了它，整个硬盘的布局就清晰了。</p>
<p><strong>inode
位图和块位图</strong>，就是位图的基本操作和作用了，表示后面 inode
和块的使用情况，和我们之前讲的内存占用位图 mem_map[] 是类似的。</p>
<p>再往后，<strong>inode</strong>
存放着每个文件或目录的元信息和索引信息，元信息就是文件类型、文件大小、修改时间等，索引信息就是大小为
9 的 i_zone[9] 块数组，表示这个文件或目录的具体数据占用了哪些块。</p>
<p>其中块数组里，0~6 表示直接索引，7 表示一次间接索引，8
表示二次间接索引。当文件比较小时，比如只占用 2 个块就够了，那就只需要
zone[0] 和 zone[1] 两个直接索引即可。</p>
<img src="/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-168076906648015.png" srcset="/img/loading.gif" lazyload class="" title="图片">
<p>再往后，就都是存放具体文件或目录实际信息的<strong>块</strong>了。如果是一个普通文件类型的
inode 指向的块，那里面就直接是文件的二进制信息。如果是一个目录类型的
inode 指向的块，那里面存放的就是这个目录下的文件和目录的 inode
索引以及文件或目录名称等信息。</p>
<p>好了，文件系统格式的说明，我们就简单说明完毕了，MINIX
文件系统已经过时，你可以阅读我之前写的 <a
target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247494176&amp;idx=1&amp;sn=b4680b50090bb3c7b9c49379241c536c&amp;chksm=c2c5908df5b2199b361885b32b07ab0f597ab25cd1d70bb75ca13fb897c200285685318f145f&amp;scene=21#wechat_redirect">图解
| 你管这破玩意叫文件系统？</a>来全面了解一个 ext2
文件系统的来龙去脉，基本思想都是一样的。</p>
<h2
id="内存中用于文件系统的数据结构有哪些">内存中用于文件系统的数据结构有哪些</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> f_mode;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> f_flags;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> f_count;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">f_inode</span>;</span><br>    <span class="hljs-type">off_t</span> f_pos;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">mount_root</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">64</span>;i++)<br>        file_table[i].f_count=<span class="hljs-number">0</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>把 64 个 <strong>file_table</strong> 里的 f_count 清零。</p>
<p><strong>这个 file_table
表示进程所使用的文件</strong>，进程每使用一个文件，都需要记录在这里，包括文件类型、文件
inode 索引信息等，而这个 f_count
表示被引用的次数，此时还没有引用，所以设置为零。</p>
<p>而这个 file_table
的索引（当然准确说是进程的filp索引才是），就是我们通常说的文件描述符。比如有如下命令。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">echo</span> <span class="hljs-string">&quot;hello&quot;</span> &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
<p>就表示把 hello 输出到 0 号文件描述符。</p>
<p>0 号文件描述符是哪个文件呢？就是 file_table[0] 所表示的文件。</p>
<p>这个文件在哪里呢？注意到 file 结构里有个 f_inode 字段，通过 f_inode
即可找到它的 inode 信息，inode
信息包含了一个文件所需要的全部信息，包括文件的大小、文件的类型、文件所在的硬盘块号，这个所在硬盘块号，就是文件的位置咯。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> <span class="hljs-title">super_block</span>[8];</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mount_root</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> * <span class="hljs-title">p</span>;</span><br>    <span class="hljs-keyword">for</span>(p = &amp;super_block[<span class="hljs-number">0</span>] ; p &lt; &amp;super_block[<span class="hljs-number">8</span>] ; p++) &#123;<br>        p-&gt;s_dev = <span class="hljs-number">0</span>;<br>        p-&gt;s_lock = <span class="hljs-number">0</span>;<br>        p-&gt;s_wait = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>又是把一个数组 <strong>super_block</strong> 做清零工作。</p>
<p>这个 super_block
存在的意义是，操作系统与一个设备以文件形式进行读写访问时，就需要把这个设备的超级块信息放在这里。</p>
<img src="/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-168076924037418.png" srcset="/img/loading.gif" lazyload class="" title="图片">
<p>这样通过这个超级块，就可以掌控这个设备的文件系统全局了。</p>
<p>果然，接下来的操作，就是读取硬盘的超级块信息到内存中来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mount_root</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    p=read_super(<span class="hljs-number">0</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>read_super 就是读取硬盘中的超级块。</p>
<p>接下来，读取根 inode 信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">mi</span>;</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">mount_root</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    mi=iget(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后把该 inode 设置为当前进程（也就是进程
1）的当前工作目录和根目录。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mount_root</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    current-&gt;pwd = mi;<br>    current-&gt;root = mi;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后记录块位图信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mount_root</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    i=p-&gt;s_nzones;<br>    <span class="hljs-keyword">while</span> (-- i &gt;= <span class="hljs-number">0</span>)<br>        set_bit(i&amp;<span class="hljs-number">8191</span>, p-&gt;s_zmap[i&gt;&gt;<span class="hljs-number">13</span>]-&gt;b_data);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后记录 inode 位图信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mount_root</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    i=p-&gt;s_ninodes+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (-- i &gt;= <span class="hljs-number">0</span>)<br>        set_bit(i&amp;<span class="hljs-number">8191</span>, p-&gt;s_imap[i&gt;&gt;<span class="hljs-number">13</span>]-&gt;b_data);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>就完事了。</p>
<p>其实整体上就是把硬盘中文件系统的各个信息，搬到内存中。之前的图可以说非常直观了。</p>
<img src="/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-168076930453321.png" srcset="/img/loading.gif" lazyload class="" title="图片">
<p>有了内存中的这些结构，我们就可以顺着根 inode，找到所有的文件了。</p>
<p>我们继续往下看 init 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    setup((<span class="hljs-type">void</span> *) &amp;drive_info);<br>    (<span class="hljs-type">void</span>) open(<span class="hljs-string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="hljs-number">0</span>);<br>    (<span class="hljs-type">void</span>) dup(<span class="hljs-number">0</span>);<br>    (<span class="hljs-type">void</span>) dup(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看到这相信你也明白了。</p>
<p>之前 setup 函数的一番折腾，加载了根文件系统，顺着根 inode
可以找到所有文件，就是为了下一行 open
函数可以通过文件路径，从硬盘中把一个文件的信息方便地拿到。</p>
<h1 id="第三十三回-打开终端设备文件">第三十三回 | 打开终端设备文件</h1>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247502230&amp;idx=1&amp;sn=44e023bf0b9b37261e35a6e3722bc57f&amp;chksm=c2c5b33bf5b23a2d10a9dd36606c497f41a1c3dced57845ce7ef12741a348fab82beba462a8a&amp;cur_album_id=2123743679373688834&amp;scene=189#wechat_redirect">第33回
| 打开终端设备文件 (qq.com)</a></p>
</blockquote>
<p>open 函数会触发 0x80 中断，最终调用到 sys_open
这个系统调用函数，相信你已经很熟悉了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c">open.c<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> <span class="hljs-title">file_table</span>[64] =</span> &#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">sys_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * filename,<span class="hljs-type">int</span> flag,<span class="hljs-type">int</span> mode)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">m_inode</span> * <span class="hljs-title">inode</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">f</span>;</span><br>    <span class="hljs-type">int</span> i,fd;<br>    mode &amp;= <span class="hljs-number">0777</span> &amp; ~current-&gt;umask;<br><br>    <span class="hljs-keyword">for</span>(fd=<span class="hljs-number">0</span> ; fd&lt;<span class="hljs-number">20</span>; fd++)<br>        <span class="hljs-keyword">if</span> (!current-&gt;filp[fd])<br>            <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (fd&gt;=<span class="hljs-number">20</span>)<br>        <span class="hljs-keyword">return</span> -EINVAL;<br>    current-&gt;close_on_exec &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;fd);<br><br>    f=<span class="hljs-number">0</span>+file_table;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">64</span> ; i++,f++)<br>        <span class="hljs-keyword">if</span> (!f-&gt;f_count) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (i&gt;=<span class="hljs-number">64</span>)<br>        <span class="hljs-keyword">return</span> -EINVAL;<br><br>    (current-&gt;filp[fd]=f)-&gt;f_count++;<br><br>    i = open_namei(filename,flag,mode,&amp;inode);<br><br>    <span class="hljs-keyword">if</span> (S_ISCHR(inode-&gt;i_mode))<br>        <span class="hljs-keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="hljs-number">0</span>])==<span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;leader &amp;&amp; current-&gt;tty&lt;<span class="hljs-number">0</span>) &#123;<br>                current-&gt;tty = MINOR(inode-&gt;i_zone[<span class="hljs-number">0</span>]);<br>                tty_table[current-&gt;tty].pgrp = current-&gt;pgrp;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (MAJOR(inode-&gt;i_zone[<span class="hljs-number">0</span>])==<span class="hljs-number">5</span>)<br>            <span class="hljs-keyword">if</span> (current-&gt;tty&lt;<span class="hljs-number">0</span>) &#123;<br>                iput(inode);<br>                current-&gt;filp[fd]=<span class="hljs-literal">NULL</span>;<br>                f-&gt;f_count=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">return</span> -EPERM;<br>            &#125;<br>    <span class="hljs-keyword">if</span> (S_ISBLK(inode-&gt;i_mode))<br>        check_disk_change(inode-&gt;i_zone[<span class="hljs-number">0</span>]);<br><br>    f-&gt;f_mode = inode-&gt;i_mode;<br>    f-&gt;f_flags = flag;<br>    f-&gt;f_count = <span class="hljs-number">1</span>;<br>    f-&gt;f_inode = inode;<br>    f-&gt;f_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> (fd);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这么大一坨别怕，我们慢慢来分析，我先用一张图来描述这一大坨代码的作用。</p>
<img src="/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-168076960235024.png" srcset="/img/loading.gif" lazyload class="" title="图片">
<p><strong>第一步，在进程文件描述符数组 filp
中找到一个空闲项。</strong>还记得进程的 task_struct 结构吧，其中有一个
filp
数组的字段，就是我们常说的文件描述符数组，这里先找到一个空闲项，将空闲地方的索引值即为
fd。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * filename,<span class="hljs-type">int</span> flag,<span class="hljs-type">int</span> mode)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> fd=<span class="hljs-number">0</span> ; fd&lt;<span class="hljs-number">20</span>; fd++)<br>        <span class="hljs-keyword">if</span> (!current-&gt;filp[fd])<br>            <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (fd&gt;=<span class="hljs-number">20</span>)<br>        <span class="hljs-keyword">return</span> -EINVAL;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于此时当前进程，也就是进程 1，还没有打开过任何文件，所以 0
号索引处就是空闲的，fd 自然就等于 0。</p>
<p><strong>第二步，在系统文件表 file_table
中找到一个空闲项。</strong>一样的玩法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * filename,<span class="hljs-type">int</span> flag,<span class="hljs-type">int</span> mode)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    ...<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">f</span>=</span><span class="hljs-number">0</span>+file_table;<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">64</span>; i++,f++)<br>        <span class="hljs-keyword">if</span> (!f-&gt;f_count) <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (i&gt;=<span class="hljs-number">64</span>)<br>        <span class="hljs-keyword">return</span> -EINVAL;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意到，进程的 filp 数组大小是 20，系统的 file_table 大小是
64，可以得出，每个进程最多打开 20 个文件，整个系统最多打开 64
个文件。</p>
<p><strong>第三步，将进程的文件描述符数组项和系统的文件表项，对应起来。</strong>代码中就是一个赋值操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * filename,<span class="hljs-type">int</span> flag,<span class="hljs-type">int</span> mode)</span> &#123;<br>    ...<br>    current-&gt;filp[fd] = f;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>第四步，根据文件名从文件系统中找到这个文件。</strong>其实相当于找到了这个
tty0 文件对应的 <strong>inode</strong> 信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * filename,<span class="hljs-type">int</span> flag,<span class="hljs-type">int</span> mode)</span> &#123;<br>    ...<br>    <span class="hljs-comment">// filename = &quot;/dev/tty0&quot;</span><br>    <span class="hljs-comment">// flag = O_RDWR 读写</span><br>    <span class="hljs-comment">// 不是创建新文件，所以 mode 没用</span><br>    <span class="hljs-comment">// inode 是返回参数</span><br>    open_namei(filename,flag,mode,&amp;inode);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接下来判断 tty0 这个 inode
是否是字符设备，如果是字符设备文件，那么如果设备号是 4
的话，则设置当前进程的 tty 号为该 inode 的子设备号。并设置当前进程tty
对应的tty 表项的父进程组号等于进程的父进程组号。</p>
<p><strong>最后第五步，填充 file 数据。</strong>其实就是初始化这个
f，包括刚刚找到的 inode 值。最后返回给上层文件描述符 fd
的值，也就是零。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * filename,<span class="hljs-type">int</span> flag,<span class="hljs-type">int</span> mode)</span> &#123;<br>    ...<br>    f-&gt;f_mode = inode-&gt;i_mode;<br>    f-&gt;f_flags = flag;<br>    f-&gt;f_count = <span class="hljs-number">1</span>;<br>    f-&gt;f_inode = inode;<br>    f-&gt;f_pos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> (fd);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>打开文件，返回给上层的是一个文件描述符，然后操作系统底层进行了一系列精巧的构造，使得一个进程可以通过一个文件描述符
fd，找到对应文件的 inode 信息。</p>
<p>好了，我们接着再往下看两行代码。接下来，两个一模一样的 dup
函数，什么意思呢？</p>
<p>其实，刚刚的 open 函数返回的为 0 号
fd，这个<strong>作为标准输入设备</strong>。</p>
<p>接下来的 dup 为 1 号 fd
赋值，这个作为<strong>标准输出设备</strong>。</p>
<p>再接下来的 dup 为 2 号 fd
赋值，这个作为<strong>标准错误输出设备</strong>。</p>
<p>熟不熟悉？这就是我们 Linux 中常说的
<strong>stdin</strong>、<strong>stdout</strong>、<strong>stderr</strong>。</p>
<p>那这个 dup
又是什么原理呢？非常简单，首先仍然是通过系统调用方式，调用到 sys_dup
函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_dup</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fildes)</span> &#123;<br>    <span class="hljs-keyword">return</span> dupfd(fildes,<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// fd 是要复制的文件描述符</span><br><span class="hljs-comment">// arg 是指定新文件描述符的最小数值</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dupfd</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> arg)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">while</span> (arg &lt; <span class="hljs-number">20</span>)<br>        <span class="hljs-keyword">if</span> (current-&gt;filp[arg])<br>            arg++;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    ...<br>    (current-&gt;filp[arg] = current-&gt;filp[fd])-&gt;f_count++;<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我仍然是把一些错误校验的旁路逻辑去掉了。</p>
<p>那这个函数的逻辑非常单纯，<strong>就是从进程的 filp
中找到下一个空闲项，然后把要复制的文件描述符 fd
的信息，统统复制到这里</strong>。</p>
<p>那根据上下文，这一步其实就是把 0 号文件描述符，复制到 1
号文件描述符，那么 0 号和 1
号文件描述符，就统统可以通过一条路子，找到最终 tty0 这个设备文件的 inode
信息了。</p>
<img src="/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-168076981160127.png" srcset="/img/loading.gif" lazyload class="" title="图片">
<p>那下一个 dup 就自然理解了吧，直接再来一张图。</p>
<img src="/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-168076981160228.png" srcset="/img/loading.gif" lazyload class="" title="图片">
<p>ok，进程 1 的 init 函数的前四行就讲完了，此时进程 1 已经比进程 0
多了<strong>与 外设交互的能力</strong>，具体说来是 tty0
这个外设（也是个文件，因为 Linux
下一切皆文件）交互的能力，这句话怎么理解呢？什么叫多了这个能力？</p>
<p>因为进程 fork 出自己子进程的时候，这个 filp
数组也会被复制，那么当进程 1 fork 出进程 2 时，进程 2
也会拥有这样的映射关系，也可以操作 tty0
这个设备，这就是“能力”二字的体现。</p>
<p>而进程 0 是不具备与外设交互的能力的，因为它并没有打开任何的文件，filp
数组也就没有任何作用。</p>
<p>进程 1 刚刚创建的时候，是 fork 的进程
0，所以也不具备这样的能力，而通过 setup 加载根文件系统，open 打开 tty0
设备文件等代码，使得进程 1 具备了与外设交互的能力，同时也使得之后从进程
1 fork 出来的进程 2 也天生拥有和进程 1 同样的与外设交互的能力。</p>
<h1 id="第三十四回-进程2的创建">第三十四回 | 进程2的创建</h1>
<blockquote>
<p><a
target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247502269&amp;idx=1&amp;sn=19f6831de5bac0d8a588b80757dbb1f4&amp;chksm=c2c5b310f5b23a0633df6a75e36f4dae515e9d9aee1fa046888573e3d60e62752612edae536a&amp;scene=178&amp;cur_album_id=2123743679373688834#rd">第34回
| 进程2的创建 (qq.com)</a></p>
</blockquote>
<p>到此为止，标志着进程 1
的工作基本结束了，准确说是能力建设的工作结束了，接下来就是<strong>控制流程</strong>和<strong>创建新的进程</strong>了，我们继续往下看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (!(pid=fork())) &#123;<br>        close(<span class="hljs-number">0</span>);<br>        open(<span class="hljs-string">&quot;/etc/rc&quot;</span>,O_RDONLY,<span class="hljs-number">0</span>);<br>        execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>,argv_rc,envp_rc);<br>        _exit(<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pid&gt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">while</span> (pid != wait(&amp;i))<br>            <span class="hljs-comment">/* nothing */</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!(pid=fork())) &#123;<br>            close(<span class="hljs-number">0</span>);close(<span class="hljs-number">1</span>);close(<span class="hljs-number">2</span>);<br>            setsid();<br>            (<span class="hljs-type">void</span>) open(<span class="hljs-string">&quot;/dev/tty0&quot;</span>,O_RDWR,<span class="hljs-number">0</span>);<br>            (<span class="hljs-type">void</span>) dup(<span class="hljs-number">0</span>);<br>            (<span class="hljs-type">void</span>) dup(<span class="hljs-number">0</span>);<br>            _exit(execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>,argv,envp));<br>        &#125;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">if</span> (pid == wait(&amp;i))<br>                <span class="hljs-keyword">break</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n\rchild %d died with code %04x\n\r&quot;</span>,pid,i);<br>        sync();<br>    &#125;<br>    _exit(<span class="hljs-number">0</span>);   <span class="hljs-comment">/* NOTE! _exit, not exit() */</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>别急，我们一点点看，我仍然是去掉了一些错误校验的旁路分支。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (!(pid=fork())) &#123;<br>        close(<span class="hljs-number">0</span>);<br>        open(<span class="hljs-string">&quot;/etc/rc&quot;</span>,O_RDONLY,<span class="hljs-number">0</span>);<br>        execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>,argv_rc,envp_rc);<br>        _exit(<span class="hljs-number">2</span>);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>先看这个第一段，我们先尝试口述翻译一遍。</p>
<p><strong>1.</strong> fork 一个新的子进程，此时就是进程 2 了。</p>
<p><strong>2.</strong> 在进程 2 里<strong>关闭（close）</strong> 0
号文件描述符。</p>
<p><strong>3.</strong> 只读形式<strong>打开（open）</strong> rc
文件。</p>
<p><strong>4.</strong> 然后<strong>执行（execve）</strong> sh 程序。</p>
<p>听起来还蛮合逻辑的，创建进程（fork）、关闭（close）、打开（open）、执行（execve）四步走，接下来我们一点点拆解。</p>
<h2 id="fork">fork</h2>
<p>fork 前面讲过了，就是将进程的 task_struct 结构进行一下复制，比如进程
0 fork 出进程 1 的时候。</p>
<img src="/2023/04/06/OperatingSystem/Operating-system-source-code-8/640.png" srcset="/img/loading.gif" lazyload class="" title="图片">
<p>之后，新进程再重写一些基本信息，包括元信息和 tss
里的寄存器信息。再之后，用 copy_page_tables
复制了一下页表（这里涉及到写时复制的伏笔）。</p>
<p>比如进程 0 复制出进程 1 的时候，页表是这样复制的。</p>
<img src="/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-16809201736683.png" srcset="/img/loading.gif" lazyload class="" title="图片">
<p>而这里的进程 1 fork 出进程
2，也是同样的流程，不同之处在于两点细节：</p>
<p><strong>第一点</strong>，进程 1 打开了三个文件描述符并指向了
tty0，那这个也被复制到进程 2 了，具体说来就是进程结构 task_struct 里的
flip[] 数组被复制了一份。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">task_struct</span> &#123;<br>    ...<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">file</span> *filp[NR_OPEN];<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>而进程 0 fork 出进程 1 时是没有复制这部分信息的，因为进程 0
没有打开任何文件。这也是刚刚说的与外设交互能力的体现，即进程 0
没有与外设交互的能力，进程 1 有，哎，其实就是这个 flip
数组里有没有东西而已嘛~</p>
<p><strong>第二点</strong>，进程 0 复制进程 1 时页表的复制只有 160
项，也就是映射 640K，而之后进程的复制，统统都是复制 1024 项，也就是映射
4M 空间。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> copy<span class="hljs-constructor">_page_tables(<span class="hljs-params">unsigned</span> <span class="hljs-params">long</span> <span class="hljs-params">from</span>,<span class="hljs-params">unsigned</span> <span class="hljs-params">long</span> <span class="hljs-params">to</span>,<span class="hljs-params">long</span> <span class="hljs-params">size</span>)</span> &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span>nr = (from==<span class="hljs-number">0</span>)?<span class="hljs-number">0xA0</span>:<span class="hljs-number">1024</span>;<span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure>
<p>整体看就是如图所示。</p>
<img src="/2023/04/06/OperatingSystem/Operating-system-source-code-8/640-16809201736684.png" srcset="/img/loading.gif" lazyload class="" title="图片">
<p>除此之外，就没有别的区别了。</p>
<h2 id="close">close</h2>
<p>好了，我们继续看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (!(pid=fork())) &#123;<br>        close(<span class="hljs-number">0</span>);<br>        open(<span class="hljs-string">&quot;/etc/rc&quot;</span>,O_RDONLY,<span class="hljs-number">0</span>);<br>        execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>,argv_rc,envp_rc);<br>        _exit(<span class="hljs-number">2</span>);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>fork 完之后，后面 if 里面的代码都是进程 2 在执行了。</p>
<p>close(0) 就是<strong>关闭 0 号文件描述符</strong>，也就是进程 1
复制过来的打开了 tty0 并作为标准输入的文件描述符，那么此时 0
号文件描述符就空出来了。</p>
<p>下面是 close 对应的系统调用函数，很简单。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_close</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> fd)</span> &#123;   <br>    ...<br>    current-&gt;filp[fd] = <span class="hljs-literal">NULL</span>;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="open">open</h2>
<p>下来 open 函数以只读形式打开了一个叫 /etc/rc 的文件，刚好占据了 0
号文件描述符的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (!(pid=fork())) &#123;<br>        ...<br>        open(<span class="hljs-string">&quot;/etc/rc&quot;</span>,O_RDONLY,<span class="hljs-number">0</span>);<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个 rc
文件表示配置文件，具体什么内容，取决于你的硬盘里这个位置处放了什么内容，与操作系统内核无关，所以我们暂且不用管。</p>
<p>此时，进程 2 与进程 1 几乎完全一样，只不过进程 2 通过 close 和 open
操作，将原来进程 1 的指向标准输入的 0 号文件描述符，重新指向了 /etc/rc
文件。</p>
<h2 id="execve">execve</h2>
<p>好，接下来进程 2 就将变得不一样了，会通过一个经典的，也是最难理解的
execve 函数调用，使自己摇身一变，成为 /bin/sh
程序继续运行，这就是下一章的重点！</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (!(pid=fork())) &#123;<br>        ...<br>        execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>,argv_rc,envp_rc);<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里就包含着操作系统究竟是如何加载并执行一个程序的原理，包括如何从文件系统中找到这个文件，如何解析一个可执行文件（在现代的
Linux 里称作 ELF
可执行文件），如何讲可执行文件中的代码和数据加载到内存并运行。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="category-chain-item">操作系统</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>你管这破玩意儿叫操作系统源码(八)</div>
      <div>https://www.spacezxy.top/2023/04/06/OperatingSystem/Operating-system-source-code-8/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Xavier ZXY</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/04/08/OperatingSystem/Operating-system-source-code-10/" title="你管这破玩意儿叫操作系统源码(九)">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">你管这破玩意儿叫操作系统源码(九)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/04/06/OperatingSystem/Operating-system-source-code-7/" title="你管这破玩意儿叫操作系统源码(七)">
                        <span class="hidden-mobile">你管这破玩意儿叫操作系统源码(七)</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a>
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      湘ICP备  2021018889
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
